[{"categories":["Java"],"content":"Java有四个访问控制符用于控制变量、方法、类被允许访问的范围： default public protected private 你真的彻底理解他们的使用方式吗？ 我们经常会看到这样一张表，但你真的理解这张表的实际内涵吗？ 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N N default Y Y Y N N private Y N N N N 很多人凭借着死记硬背的本事来记这些东西，令人唏嘘不已，让大家在理解的基础上记忆是我写这篇文章的初衷。 ","date":"2020-11-19","objectID":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/:0:0","tags":["Java"],"title":"深入理解Java访问控制符","uri":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/"},{"categories":["Java"],"content":"default\u0026public\u0026private 在解释之前，我们要理解什么是“跨包”、“同包”。 ","date":"2020-11-19","objectID":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/:1:0","tags":["Java"],"title":"深入理解Java访问控制符","uri":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/"},{"categories":["Java"],"content":"跨包的误区 首先，建立我们的目录： - Outpack - Out.java - Pack - Target.java - Equal.java - Inpack - In.java 其中有三级目录，Outpack、Pack、Inpack。Pack是我们的主要的目录，包含Target.java、Equal.java；Outpack是Pack的父包，包含Out.java；Inpack是Pack的子包，包含In.java。 请问，在以上的所有java文件中，与Target.java同包（即不存在“跨包”关系）的文件是什么？ 我猜你可能会有两种答案： Equal.java（正确） Equal.java和In.java（错误） 注意这是一个常见的误区，子包也算是“跨包”而不是“同包”。 “同包”即在同一个目录下，“跨包”即先祖包、子孙包。 ","date":"2020-11-19","objectID":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/:1:1","tags":["Java"],"title":"深入理解Java访问控制符","uri":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/"},{"categories":["Java"],"content":"三大基础修饰符 接下来来看我们的Target.java文件： public class Target { public int publicVar; protected int protectedVar; private int privateVar; int defaultVar; } default：默认的访问范围是“同包”，即在同一个目录下能够访问，用default修饰（因为默认通常可忽略）。Target.java、Equal.java能够访问defaultVar。 public：允许跨包访问，“同包”+“跨包”，无论是同包、先祖包还是子孙包都能够访问，用public修饰。上述所有java文件都能访问publicVar。 private：不想被其他java文件“访问”，用private修饰。仅允许Target.java自身能访问privateVar。 ","date":"2020-11-19","objectID":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/:1:2","tags":["Java"],"title":"深入理解Java访问控制符","uri":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/"},{"categories":["Java"],"content":"protected protected的意义是为了应对继承中的访问关系，他其实是在default的基础上加上一条：允许子类访问父类中的protected。 ","date":"2020-11-19","objectID":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/:2:0","tags":["Java"],"title":"深入理解Java访问控制符","uri":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/"},{"categories":["Java"],"content":"操作指南 官方操作指南：https://www.jenv.be/ ","date":"2020-11-07","objectID":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/:1:0","tags":["Java"],"title":"MacOS下jenv管理多版本JDK","uri":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/"},{"categories":["Java"],"content":"安装jenv 使用brew安装jenv $ brew install jenv ","date":"2020-11-07","objectID":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/:2:0","tags":["Java"],"title":"MacOS下jenv管理多版本JDK","uri":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/"},{"categories":["Java"],"content":"配置变量 配置命令行变量，我使用的是zsh $ echo 'export PATH=\"$HOME/.jenv/bin:$PATH\"' \u003e\u003e ~/.zshrc $ echo 'eval \"$(jenv init -)\"' \u003e\u003e ~/.zshrc 配置完后关闭命令行重新打开，确保变量重新被加载。 ","date":"2020-11-07","objectID":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/:3:0","tags":["Java"],"title":"MacOS下jenv管理多版本JDK","uri":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/"},{"categories":["Java"],"content":"链接目录 将jdk链接到jenv目录下。这会将JDK从MacOS的默认地址/System/Library/Java/JavaVirtualMachines链接到jenv的目录下/Users/{username}/.jenv/versions。但是jenv的目录没有被创建，所以我们要手动创建.jenv/versions，否则链接的时候会找不到文件夹。 // 创建目录 $ cd ~ $ mkdir .jenv $ cd .jenv $ mkdir versions 链接的命令格式如下 $ jenv add {jdk's path} {jdk's name} added 我们还需要知道jdk的路径和jdk的名称，如何操作？通过下述命令可以知道当前所有Java虚拟机的信息： $ /usr/libexec/java_home -V Matching Java Virtual Machines (2): 14.0.1, x86_64: \"OpenJDK 14.0.1\" /Users/neville/Library/Java/JavaVirtualMachines/openjdk-14.0.1/Contents/Home 11.0.9, x86_64: \"OpenJDK 11.0.9\" /Library/Java/JavaVirtualMachines/openjdk-11.jdk/Contents/Home /Users/neville/Library/Java/JavaVirtualMachines/openjdk-14.0.1/Contents/Home 然后粘贴复制一下 $ jenv add /Users/neville/Library/Java/JavaVirtualMachines/openjdk-14.0.1/Contents/Home openjdk-14.0.1 added 14 added 14.0 added 14.0.1 added openjdk-14.0.1 added $ jenv add /Library/Java/JavaVirtualMachines/openjdk-11.jdk/Contents/Home openjdk-11.0.9 added 11 added 11.0 added 11.0.9 added openjdk-11.0.9 added 我们会发现jenv为我们创建了4个链接，这些链接都是等价的，因为他们连接的虚拟机地址都是/Users/neville/Library/Java/JavaVirtualMachines/openjdk-14.0.1/Contents/Home。后面你要切换版本14，那你输入的版本号可以是： 14 14.0 14.0.1 openjdk-14.0.1 进入/Users/{username}/.jenv/versions，你也会看到相应的软链接目录。 输入jenv versions，你会看到jenv管理的所有链接（当前使用的是14）。 $ jenv versions system 11 11.0 11.0.9 * 14 (set by /Users/neville/.jenv/version) 14.0 14.0.1 openjdk64-11.0.9 openjdk64-14.0.1 ","date":"2020-11-07","objectID":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/:4:0","tags":["Java"],"title":"MacOS下jenv管理多版本JDK","uri":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/"},{"categories":["Java"],"content":"切换版本 链接完成，切换到11试试。正如前文所说，这里你输入11、11.0、11.0.9、openjdk64-11.0.9都是等价的，因为这四个链接连接的都是同一个虚拟机。 $java -version openjdk version \"14.0.1\" 2020-04-14 OpenJDK Runtime Environment (build 14.0.1+7) OpenJDK 64-Bit Server VM (build 14.0.1+7, mixed mode, sharing) $ jenv local 11 $ java -version openjdk version \"11.0.9\" 2020-10-20 OpenJDK Runtime Environment (build 11.0.9+11) OpenJDK 64-Bit Server VM (build 11.0.9+11, mixed mode) JDK的版本从14变为了11。 java local {version}仅仅是作用于当前目录。当你输入jenv local 11的时候，你会发现在当前目录下多了一个.java-version的文件，打开后里面写着链接号11，这意味着当前目录下的JDK版本是11 java local {version}作用于全局。比如，想要全局切换到11，则需要使用 $ jenv global 11 最后，祝您用餐愉快！ ","date":"2020-11-07","objectID":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/:5:0","tags":["Java"],"title":"MacOS下jenv管理多版本JDK","uri":"/macos%E4%B8%8Bjenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACjdk/"},{"categories":["Java"],"content":"获取源码 直接从OpenJDK的官网获取，我选用的是JDK12 http://hg.openjdk.java.net/jdk/jdk12/ 点击左侧栏的zip就会开始下载 ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:1:0","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"主要环境 MacOS 10.15.5 Xcode 12.1 Clang 12.0.0 Java 11 我是如何知道编译需要这些的？前三者通过两条途径得知： 官网的OpenJDKWiki https://wiki.openjdk.java.net/display/Build/Supported+Build+Platforms 下载的JDK源码的doc目录下building.html 安装方式多种多样，大家各显神通吧。 Java则是从后来检查依赖环境时的日志中得知： configure: (Your Boot JDK version must be one of: 11 12) 你可以使用Homebrew直接安装Java \u003e brew search java ==\u003e Formulae app-engine-java java11 jslint4java google-java-format javacc libreadline-java java javarepl pdftk-java ==\u003e Casks eclipse-java netbeans-java-se eclipse-javascript oracle-jdk-javadoc font-noto-sans-javanese homebrew/cask-versions/java-beta netbeans-java-ee \u003e brew install java11 // 这里会提示如果想要被找到，则需要将其链接到java虚拟机的目录下 For the system Java wrappers to find this JDK, symlink it with sudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk ... \u003e sudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:2:0","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"命令行环境 Xcode安装完毕后，要在Preference-\u003eLocations选择Command Line Tools（我选的是Xcode 12.1）从而为命令行添加Xcode的编译环境，否则编译的时候检测不到Xcode的相关工具，编译无法正常进行。 另外，要写一个脚本来设置clang及其他各种命令行的参数，网上有各种版本，仅供参考： # 设定语言选项，必须设置 export LANG=C # Mac平台，C编译器不再是GCC，是clang export CC=gcc # 跳过clang的一些严格的语法检查，不然会将N多的警告作为Error export COMPILER_WARNINGS_FATAL=false # 链接时使用的参数 export LFLAGS='-Xlinker -lstdc++' # 是否使用clang export USE_CLANG=true # 使用64位数据模型 export LP64=1 # 告诉编译平台是64位，不然会按32位来编译 export ARCH_DATA_MODEL=64 # 允许自动下载依赖 export ALLOW_DOWNLOADS=true # 并行编译的线程数，编译时间长，为了不影响其他工作，我选择为2 export HOTSPOT_BUILD_JOBS=2 # 是否跳过与先前版本的比较 export SKIP_COMPARE_IMAGES=true # 是否使用预编译头文件，加快编译速度 export USE_PRECOMPILED_HEADER=true # 是否使用增量编译 export INCREMENTAL_BUILD=true # 编译内容 export BUILD_LANGTOOLS=true export BUILD_JAXP=false export BUILD_JAXWS=false export BUILD_CORBA=false export BUILD_HOTSPOT=true export BUILD_JDK=true # 编译版本 export SKIP_DEBUG_BUILD=true export SKIP_FASTDEBUG_BUILD=false export DEBUG_NAME=debug # 避开javaws和浏览器Java插件之类的部分的build export BUILD_DEPLOY=false export BUILD_INSTALL=false # 加上产生调试信息时需要的 objcopy export OBJCOPY=gobjcopy ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:3:0","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"依赖环境 编译自然不会这么简单，还需要一些依赖环境，我们如何知道需要什么？ 依赖环境根据你想要的编译版本（例如FastDebug版或者其他各种类型的版本）来决定，进入jdk源码根目录，可以通过 bash configure -help 来查看可以添加的参数，通过这些参数来决定编译的目标版本。 例如变异FastDebug版、仅含Server模式的HotSpot虚拟机，命令行就是 bash configure --enable-debug --with-jvm-variants=server 执行后目录下会新增build文件夹（还没编译所以是空的）和日志文件config.log、configure.log，我们根据命令行给出的各种提示逐步安装所需要的依赖。 如果一切配置准备就绪，执行完毕会出现： ==================================================== A new configuration has been successfully created in /Users/neville/lab/jdk/openjdk/jdk12/build/macosx-x86_64-server-fastdebug using configure arguments '--enable-debug --with-jvm-variants=server'. Configuration summary: * Debug level: fastdebug * HS debug level: fastdebug * JVM variants: server * JVM features: server: 'aot cds cmsgc compiler1 compiler2 dtrace epsilongc g1gc graal jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs' * OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64 * Version string: 12-internal+0-adhoc.neville.jdk12 (12-internal) Tools summary: * Boot JDK: openjdk version \"11.0.9\" 2020-10-20 OpenJDK Runtime Environment (build 11.0.9+11) OpenJDK 64-Bit Server VM (build 11.0.9+11, mixed mode) (at /Library/Java/JavaVirtualMachines/openjdk-11.jdk/Contents/Home) * Toolchain: clang (clang/LLVM from Xcode 12.1) * C Compiler: Version 12.0.0 (at /usr/bin/gcc) * C++ Compiler: Version 12.0.0 (at /usr/bin/clang++) Build performance summary: * Cores to use: 16 * Memory limit: 32768 MB ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:4:0","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"编译源码 make all 如果有多个版本可以用参数CONF指定版本，版本名称是build目录下的文件夹名： make CONF=[版本名称] 例如 make CONF=macosx-x86_64-server-fastdebug ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:5:0","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"错误1 /src/hotspot/share/runtime/arguments.cpp:1452:35: if (old_java_vendor_url_bug != DEFAULT_VENDOR_URL_BUG) { 修改 if (old_java_vendor_url_bug != DEFAULT_VENDOR_URL_BUG) { 为 if (strcmp(old_java_vendor_url_bug, DEFAULT_VENDOR_URL_BUG) != 0) { ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:5:1","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"错误2 /test/hotspot/gtest/classfile/test_symbolTable.cpp:62:6: s1 = s1; // self assignment 这行代码应该是没用的，可以直接注释，毕竟自己给自己赋值是没有意义… 也可以参考这个回答修改代码http://hg.openjdk.java.net/jdk/jdk/rev/297ddf282627 ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:5:2","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"错误3 /src/hotspot/share/runtime/sharedRuntime.cpp:2873:85 error: expression does not compute the number of elements in this array; element type is 'double', not 'relocInfo' buffer.insts()-\u003einitialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo)); 参考了这个文件中别处使用initialize_shared_locs()的方式，将修改 double locs_buf[20]; buffer.insts()-\u003einitialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo)); 为 short locs_buf[20]; buffer.insts()-\u003einitialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo)); ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:5:3","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"错误4 /test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/FollowReferences/followref003/followref003.cpp:813:14: error: comparison of different enumeration types in switch statement ('jvmtiHeapReferenceKind' and 'jvmtiObjectReferenceKind') [-Werror,-Wenum-compare-switch] case JVMTI_REFERENCE_ARRAY_ELEMENT: 一个case中套了多种类型，一种是Heap的枚举类，一种是Object的枚举类。因此根据周边的改为相同的类型即可。周边代码： case JVMTI_REFERENCE_ARRAY_ELEMENT: case JVMTI_HEAP_REFERENCE_JNI_GLOBAL: case JVMTI_HEAP_REFERENCE_SYSTEM_CLASS: case JVMTI_HEAP_REFERENCE_MONITOR: case JVMTI_HEAP_REFERENCE_OTHER: 所以应当使用应该使用jvmtiHeapReferenceKind，即Heap的枚举类。 修改 case JVMTI_REFERENCE_ARRAY_ELEMENT: 为 case JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT: ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:5:4","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"错误5 /Users/neville/lab/jdk/openjdk/jdk12/src/java.desktop/macosx/native/libawt_lwawt/awt/CSystemColors.m:134:9: error: converting the result of '?:' with integer constants to a boolean always evaluates to 'true' [-Werror,-Wtautological-constant-compare] if (colorIndex \u003c (useAppleColor) ? sun_lwawt_macosx_LWCToolkit_NUM_APPLE_COLORS : java_awt_SystemColor_NUM_COLORS) { 修改方式https://github.com/openjdk/jdk/commit/4622a18a ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:5:5","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"编译完成 我个人修改完上述五个问题后，就编译成功了。每个人所使用的工具、依赖和编译版本不同，可能遇到的bug也不同。源码也并不是完美的，还是要手动改一改。如果你遇到了和我同样的问题，很高兴能帮到你。 最后再验证一下，运行下述命令查看编译后的jdk的版本： \u003e build/macosx-x86_64-normal-server-slowdebug/jdk/bin/java -version openjdk version \"12-internal\" 2019-03-19 OpenJDK Runtime Environment (fastdebug build 12-internal+0-adhoc.neville.jdk12) OpenJDK 64-Bit Server VM (fastdebug build 12-internal+0-adhoc.neville.jdk12, mixed mode) ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:6:0","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Java"],"content":"调试 ","date":"2020-11-05","objectID":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/:7:0","tags":["Java"],"title":"MacOS下编译JDK12","uri":"/macos%E4%B8%8B%E7%BC%96%E8%AF%91jdk12/"},{"categories":["Android Framework"],"content":"基础示例 // ExampleThread.java public class ExampleThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public void handleMessage(Message msg) { // TODO：处理消息 switch(msg.what) { case ...: ... case ...: ... } } } Looper.loop() } public static void sendMessageToExampleThread() { Message msg = new Message() handler.sendMessage(msg) } } ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:1:0","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"架构 Handler.class：持有Looper和Message。 // Handler.java public class Handler { final Looper mLooper; final MessageQueue mQueue; } Message.class:持有Handler // Message.java public class Message { Handler target; } MessageQueue.class：持有Message。 // MessageQueue.java public class MessageQueue() { Message mMessages; } Looper.class：持有MessageQueue和Thread。 // Looper.java public class Looper() { final MessageQueue mQueue; final Thread mThread; } 架构图image-20200908105152908 \" 架构图 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:2:0","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"Looper ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:3:0","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"准备 准备，在开始时，我们都会调用 // ExampleThread.java Looper.prepare() 代码为 // Looper.java public static void prepare() { prepare(true); } 调用了Looper.prepare(boolean quitAllowed) // Looper.java static final ThreadLocal\u003cLooper\u003e sThreadLocal = new ThreadLocal\u003cLooper\u003e(); private static void prepare(boolean quitAllowed) { // 如果ThreadLocal中已经有数据了，就抛出异常。 if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } // 创建Looper对象，并将其存储到当前线程的ThreadLocal sThreadLocal.set(new Looper(quitAllowed)); } ThreadLocal ThreadLocal：即Thread Local Storage，简称TLS，是每个线程的私有的本地存储区域。 ThreadLocal.set()：将数据存储到“当前线程”的TLS。 // ThreadLocal.java public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } ThreadLocal.get()：获取“当前线程”的TLS。 // ThreadLocal.java public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } 然后再次回到这段代码 private static void prepare(boolean quitAllowed) { // 如果ThreadLocal中已经有数据了，就抛出异常“每个线程只能创建一个Looper”。 if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } // 创建Looper对象，并将其存储到当前线程的ThreadLocal sThreadLocal.set(new Looper(quitAllowed)); } 第一次调用Looper.perpare()，当前线程的TLS为空，会执行sThreadLocal.set(new Looper(quitAllowed))来设置TLS，之后TLS不为空。这时，如果再次调用Looper.prepare()，会抛出异常。 也就是说每个线程只能执行一次Looper.prepare()。 new Looper() 我们在sThreadLocal.set(new Looper(quitAllowed));时需要创建一个Looper。这个创建过程为Looper创建了一个MessageQueue，并将Thread的引用指向当前线程。 final MessageQueue mQueue; final Thread mThread; private Looper(boolean quitAllowed) { // 创建一个MessageQueue mQueue = new MessageQueue(quitAllowed); // 当前线程 mThread = Thread.currentThread(); } prepareMainLooper() 我们的主线程在运行的时候会自动调用prepareMainLooper()，并且创建的Looper为主Looper，不可退出。 因此，主线程中不需要工程师手动Looper.prepare()。 // Looper.java public static void prepareMainLooper() { // Looper不允许被退出 prepare(false); synchronized (Looper.class) { // 不允许重复创建sMainLooper if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } // 将当前的Looper存储为sMainLooper sMainLooper = myLooper(); } } Looper.prepare()的主要工作是创建了一个带有MessageQueue并且指向“当前线程”的Looper，并将这个Looper存储到当前线程的TLS中。 每个线程想要调用Looper执行相关操作时，就必须执行Looper.prepare()来创建自己的Looper，否则连Looper都没有还怎么执行。其中，主线程在创建的时候已经自动执行了prepareMainLooper()并将Looper设置为不可退出，因此不需要工程师手动Looper.prepare()。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:3:1","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"消息循环 消息循环，调用Looper.loop() // Looper.java public static void loop() { // 获取当前线程存储在TLS中的Looper final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } // 获取Looper中的MessageQueue final MessageQueue queue = me.mQueue; /** * 接下来着两行代码不是很重要，别纠结 * 主要作用就是loop的时候要进入某种状态 * 所以做点状态上的准备并且记录一个令牌 * 到时候根据这个令牌再恢复状态 */ // 清理掉调用线程，用本地线程的uid和pid替代 Binder.clearCallingIdentity(); // 记录恢复令牌 final long ident = Binder.clearCallingIdentity(); final int thresholdOverride = SystemProperties.getInt(\"log.looper.\" + Process.myUid() + \".\" + Thread.currentThread().getName() + \".slow\", 0); boolean slowDeliveryDetected = false; for (;;) { // 【重要】读取MessageQueue中的下一条信息 Message msg = queue.next(); if (msg == null) { // 【重要】如果MessageQueue中已经没有Message了，就结束loop() return; } // Debug日志打印，不重要... final Printer logging = me.mLogging; if (logging != null) { logging.println(\"\u003e\u003e\u003e\u003e\u003e Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } // 观察者 final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride \u003e 0) { slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; } final boolean logSlowDelivery = (slowDeliveryThresholdMs \u003e 0) \u0026\u0026 (msg.when \u003e 0); final boolean logSlowDispatch = (slowDispatchThresholdMs \u003e 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 \u0026\u0026 Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) { token = observer.messageDispatchStarting(); } long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try { // 【重要】向目标Handler分发消息 msg.target.dispatchMessage(msg); if (observer != null) { // 【重要】向观察者分发消息 observer.messageDispatched(token, msg); } dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; // 一堆异常处理，不重要... } catch (Exception exception) { if (observer != null) { observer.dispatchingThrewException(token, msg, exception); } throw exception; } finally { ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) { Trace.traceEnd(traceTag); } } // 一堆日志打印，不重要... if (logSlowDelivery) { if (slowDeliveryDetected) { if ((dispatchStart - msg.when) \u003c= 10) { Slog.w(TAG, \"Drained\"); slowDeliveryDetected = false; } } else { if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\", msg)) { slowDeliveryDetected = true; } } } if (logSlowDispatch) { showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg); } if (logging != null) { logging.println(\"\u003c\u003c\u003c\u003c\u003c Finished to \" + msg.target + \" \" + msg.callback); } // 恢复 final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); } // 【重要】将Message放入消息池 msg.recycleUnchecked(); } } Looper.loop()中的无限循环，不断通过Message msg = queue.next()读取下一条消息，直到读完消息队列中所有消息为止。 每次循环，拿到Message后，开始分发消息： 给Handler分发消息：msg.target.dispatchMessage(msg)分发消息给Message的目标Handler。 给Observer分发消息：observer.messageDispatched(token, msg)分发消息给Observer。 分发完消息后会调用msg.recycleUnchecked()将利用完的Message放入消息池，以便复用。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:3:2","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"退出 退出，调用Looper.quit() // Looper.java public void quit() { // 调用MessageQueue中的quit() mQueue.quit(false); } // MessageQueue.java void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(\"Main thread not allowed to quit.\"); } // 互斥：一个Looper在清空消息时，不允许其他Looper清空消息 synchronized (this) { if (mQuitting) { return; } mQuitting = true; // 【重要】根据safe选择消息的退出方式 if (safe) { // 如果安全，则移除尚未使用的消息 removeAllFutureMessagesLocked(); } else { // 如果不安全，则移除所有消息 removeAllMessagesLocked(); } nativeWake(mPtr); } } 消息的退出方式： safe==true，安全，则移除尚未使用的消息。 safe==false，不安全，则移除所有消息。 根据Looper.quit()的代码，safe==false，会移除所有所有消息。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:3:3","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"myLooper() 用于获取当前线程TLS中存储的Looper。 // Looper.java public static @Nullable Looper myLooper() { return sThreadLocal.get(); } ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:3:4","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"myQueue() 用于从当前线程的Looper中获取MessageQueue。 public static @NonNull MessageQueue myQueue() { return myLooper().mQueue; } ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:3:5","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"Message ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:4:0","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"成员变量 // Message.java public int what; // 消息标识 public int arg1; // 参数1 public int arg2; // 参数2 public Object obj; // 消息内容，传递任意数据 public long when; // 传递时间 public Messenger replyTo; // 跨进程访问的信使，我们这里是跨线程访问，因此暂不涉及 Bundle data; // 数据包，传递Bundle类型的数据包 Handler target; // 目标handler Runnable callback; // 回调方法 Message next; // 下一条消息 int flags; // 状态 static final int FLAG_IN_USE = 1 \u003c\u003c 0; // 正在被使用 static final int FLAG_ASYNCHRONOUS = 1 \u003c\u003c 1; // 异步 static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; // 如果消息正在清除或者复制，则设置状态为“正在被使用” // 设置是否异步 public void setAsynchronous(boolean async) { if (async) { flags |= FLAG_ASYNCHRONOUS; } else { flags \u0026= ~FLAG_ASYNCHRONOUS; } } 消息标识 what作为消息标识，Handler可以在拿到消息后根据what来分辨消息，从而进行特定的操作。 mHandler = new Handler() { public void handleMessage(Message msg) { // 根据what做不同的操作 switch(msg.what) { case 1: // 刷个牙 case 2: // 洗个脸 } } } 保留字 arg1和arg2是保留字段，arg1通常用来作为同步屏障SyncBarriar的token，后文MessageQueue会讲到。 消息内容 Object obj和Bundle data都可以用来在Message存储内容，一般情况下用Bundle data，而Object obj仅作为保留手段。 消息类型 普通消息：target!=null 异步消息：falgs被设置为FLAG_ASYNCHRONOUS。 同步消息：falgs未被设置为FLAG_ASYNCHRONOUS。 特殊消息：target==null 同步屏障：SyncBarriar， 消息是否异步，通过Message.setAsynchronous()来设置消息是否异步，也通过Message.isAsynchronous()来查看消息是否异步。 同步屏障会挡在同步消息，不让同步消息穿过，而让异步消息穿过。也就是说在有同步屏障的情况下，异步消息优先执行，同步消息等所有异步消息完成之后再执行。详见后文MessageQueue的同步屏障。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:4:1","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"消息复用 消息是Android中高频创建的对象，而创建对象需要消耗很多资源。因此，Google的工程师们构建了消息池，对消息进行复用。 消息使用完毕后，调用Message.recycle()，进而调用recycleUnchecked()回收消息。 // Message.java public void recycle() { if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException(\"This message cannot be recycled because it \" + \"is still in use.\"); } return; } recycleUnchecked(); } void recycleUnchecked() { // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) { if (sPoolSize \u003c MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } } } Handler需要创建消息的时候，就调用Handler.obtainMessage()，进而调用Message.obtain()，先从消息池中拿曾经被回收的消息，如果消息池中没有消息再创建消息，以此达到节约资源的目的。 // Handler.java public final Message obtainMessage(...) { return Message.obtain(...); } // Message.java public static Message obtain(...) { ... return new Message(); } ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:4:2","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"MessageQueue 消息队列，以Message为元素的队列，那就会有消息入队、下一条消息、消息出队等方法。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:0","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"成员变量 // MessageQueue.java // 是否允许退出 private final boolean mQuitAllowed; // 是否正在退出 private boolean mQuitting; // 是否被阻塞 private boolean mBlocked; // Native层中的MessageQueue的指针 private long mPtr; // 指向MessageQueue的第一个元素 Message mMessages; // 用来保存Handler所在线程空闲时执行的的事务 // 当Handler所在的线程空闲时（MessageQueue中没有Message时），会执行这个数组中的事务 private final ArrayList\u003cIdleHandler\u003e mIdleHandlers = new ArrayList\u003cIdleHandler\u003e(); // 与Native层相关，暂不陈述 private SparseArray\u003cFileDescriptorRecord\u003e mFileDescriptorRecords; // 保存要被执行的IdelHandler private IdleHandler[] mPendingIdleHandlers; // 下一个BarrierToken（同步屏障会用到，后文详解） private int mNextBarrierToken; 关于队列的退出，我们刚开始说过Looper存储在线程中，而MessageQueue存储在Looper中，只要线程还活着，Looper一旦被线程创建就会无限循环运转，MessageQueue也会一直存在。那么MessageQueue退出的时候，也就说明Looper即将消亡，Looper即将消亡则意味着线程即将消亡。这时，如果我们发消息过去，则消息会被直接回收掉，在下面的“消息入队”中我们马上回看到。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:1","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"消息入队 消息入队，调用MessageQueue.enqueueMessage() // MessageQueue.java boolean enqueueMessage(Message msg, long when) { // 健壮性判断 // 1.消息的handler不可为空，即只入队接收同步消息 // 2.消息要未被使用 if (msg.target == null) { throw new IllegalArgumentException(\"Message must have a target.\"); } if (msg.isInUse()) { throw new IllegalStateException(msg + \" This message is already in use.\"); } synchronized (this) { // 【重要】如果队列正在退出（即线程即将消亡），则新到达的消息直接回收掉 if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } // 标志消息“使用中” msg.markInUse(); // 消息的传递时间 msg.when = when; // p是MessageQueue的第一条消息，msg是即将入队的新消息 // 如果p为空，则说明MessageQueue为空 Message p = mMessages; // 是否需要唤醒队列 boolean needWake; if (p == null || when == 0 || when \u003c p.when) { // 如果MessageQueue为空，或者msg的传递时间是最早的，则直接处理 // 下一条消息设置为新传入的消息 msg.next = p; // MessageQueue的第一条消息设置为新传入的msg mMessages = msg; // MessageQueue的第一条消息更新，需要唤醒队列 needWake = mBlocked; } else { // 【重要】如果MessageQueue不为空，则将msg按照传递时间顺序插入队列中 // 通常情况下不需要唤醒队列，除非MessageQueue中第一条消息p是同步屏障并且新传来的消息msg是异步消息（代码段后我会解释） needWake = mBlocked \u0026\u0026 p.target == null \u0026\u0026 msg.isAsynchronous(); // 后面就是简单的插入的代码（看不懂的买一本《数据结构》），不赘述 Message prev; for (;;) { prev = p; p = p.next; if (p == null || when \u003c p.when) { break; } if (needWake \u0026\u0026 p.isAsynchronous()) { needWake = false; } } msg.next = p; prev.next = msg; } // 如果队列被唤醒了，就给Native层发个队列信号mPtr，Native层会做一些操作，暂不详述 if (needWake) { nativeWake(mPtr); } } return true; } 整体逻辑就是一个队列的插入： MessageQueue为空就直接插入，并被设置为第一个元素。 MessageQueue不为空就根据传递时间的顺序，找到合适的地方插入队列。 学过《数据结构》的小伙伴肯定要吐槽了，你跟我说这东西叫“队列”？实际上它不是严格意义上的队列，而是一个有序单链表，其主要逻辑比较符合队列的特征：消息根据传递时间排好队，然后依次一件件处理。 有些情况下我们需要的唤醒队列：（建议回顾下Message中的消息类型，再来看这段解析） MessageQueue空，插入新消息，需要唤醒队列。因为队列为空，插入的新元素，无论有没有开启同步屏障同步消息还是异步消息，都可以执行。 MessageQueue非空，插入异步消息、MessageQueue中第一条消息p是同步屏障并且新传来的消息msg是异步消息，需要唤醒队列。首先，p.target == null说明MessageQueue的第一条消息p是同步屏障，这说明开启了同步屏障机制，同步消息前会添加一个同步屏障阻止同步消息的执行，要在所有异步消息执行完毕后才能执行同步消息。而新传来的消息msg是异步消息，需要优先执行，因此需要唤醒线程来执行新消息msg。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:2","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"下一条消息 下一条消息，调用Looper.next()。 // MessageQueue.java Message next() { // 当消息循环已经退出，则mPtr == 0，直接退出 final long ptr = mPtr; if (ptr == 0) { return null; } // 待执行的IdleHandler的数量，也是IdleHandler[]的长度（可以先看Handler的时候会讲到，再回头看相关内容） int pendingIdleHandlerCount = -1; /** * 下一次轮询的倒计时 * nextPollTimeoutMillis==-1：一直阻塞 * nextPollTimeoutMillis== 0：不会阻塞，立即返回 * nextPollTimeoutMillis \u003e 0：最长阻塞时间为nextPollTimeoutMillis毫秒 */ int nextPollTimeoutMillis = 0; // 无限循环 for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } // 【重要】阻塞，等待一定的时常后被唤醒 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // 检索下一条消息，如果找到则将其返回 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //【重要】要求是普通消息 // 如果消息的target为空，则说明开启了同步屏障机制，那就要优先找异步消息 if (msg != null \u0026\u0026 msg.target == null) { // 优先寻找异步消息 do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026\u0026 !msg.isAsynchronous()); } if (msg != null) { // 如果有消息 if (now \u003c msg.when) { // 当前时间小于事件的触发时间时，说明还没轮到这个事件，则设置下一次轮训的倒计时为两者的时间差 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // 【重要】当前触发事件大于时间的触发时间时，说明已经轮到了，开始获取这条消息 // 取消消息队列的阻塞状态 mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); // 设置消息的使用状态为“使用中” msg.markInUse(); // 返回这条消息 return msg; } } else { // 如果没消息，下一次轮询的倒计时设置为-1，即一直阻塞 nextPollTimeoutMillis = -1; } // 如果MessageQueue正在退出，则返回null if (mQuitting) { dispose(); return null; } // 准备开始执行IdleHandler // 先初始化IdleHandler[]，再执行IdleHandler[]中的任务。 // 看看有没有待执行IdleHandler if (pendingIdleHandlerCount \u003c 0 \u0026\u0026 (mMessages == null || now \u003c mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } // 如果没有待执行IdleHandler需要运行，则消息队列阻塞，持续循环等待 if (pendingIdleHandlerCount \u003c= 0) { mBlocked = true; continue; } // 如果IdleHandler为空，则创建一个IdleHandler if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // 执行IdleHandler[]中的任务 for (int i = 0; i \u003c pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \"IdleHandler threw exception\", t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // 所有IdleHandler运行完毕后，pendingIdleHandlerCount为0。 pendingIdleHandlerCount = 0; // IdleHandler处理完毕后，不经过等待，直接查询未处理的消息。 nextPollTimeoutMillis = 0; } } 基本逻辑： 先处理Handler中的消息，再处理IdleHandler中的事务。 Handler消息处理时，如果开启了同步屏障机制，就要优先处理异步消息。 nativePollOnce()作为阻塞操作就涉及到native层的代码，留坑待填。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:3","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"消息移除 移除消息，调用Looper.removeMessages() // MessageQueue.java void removeMessages(Handler h, int what, Object object) { if (h == null) { return; } synchronized (this) { Message p = mMessages; // 消息队列从头到尾，移除所有符合条件的消息 while (p != null \u0026\u0026 p.target == h \u0026\u0026 p.what == what \u0026\u0026 (object == null || p.obj == object)) { Message n = p.next; mMessages = n; // 回收到消息池 p.recycleUnchecked(); p = n; } // 移除剩余的符合条件的消息 while (p != null) { Message n = p.next; if (n != null) { if (n.target == h \u0026\u0026 n.what == what \u0026\u0026 (object == null || n.obj == object)) { Message nn = n.next; // 回收到消息池 n.recycleUnchecked(); p.next = nn; continue; } } p = n; } } } ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:4","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"同步屏障 同步屏障。如果开启同步屏障机制，就会优先处理异步消息。在同步消息前添加一个同步屏障，待异步消息处理完后，再执行同步消息。 例如下图的MessageQueue中，如果同步小消息执行顺序为“异步消息1”“异步消息2”，执行完后再执行“同步消息1”。具体的代码执行在MessageQueue中将详细讲解。 使用postSyncBarrier()向队列中发送同步屏障。 // Looper.java public int postSyncBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); } private int postSyncBarrier(long when) { // barrier token入队， synchronized (this) { // barrier token累加，并记录到token中 final int token = mNextBarrierToken++; // 从消息池中获取Message final Message msg = Message.obtain(); // 标记这条消息“使用中” msg.markInUse(); // 为消息赋值了when和token，token但是没有target，即target==null，因此这条消息是同步屏障 msg.when = when; msg.arg1 = token; // 构造同步屏障后，将其插入到合适的地方 Message prev = null; // MessageQueue的第一个消息 Message p = mMessages; if (when != 0) { while (p != null \u0026\u0026 p.when \u003c= when) { prev = p; p = p.next; } } if (prev != null) { msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } } Looper.removeSyncBarrier()用于移除同步屏障。 // MessageQueue.java public void removeSyncBarrier(int token) { // barrier token出队 synchronized (this) { Message prev = null; // MessageQueue的第一个消息 Message p = mMessages; // 【重要】找到同步屏障：从消息队列中找到target==null并且token相等的Message，即为需要移出的同步屏障，将其移除。 while (p != null \u0026\u0026 (p.target != null || p.arg1 != token)) { prev = p; p = p.next; } if (p == null) { throw new IllegalStateException(\"The specified message queue synchronization \" + \" barrier token has not been posted or has already been removed.\"); } final boolean needWake; if (prev != null) { prev.next = p.next; needWake = false; } else { mMessages = p.next; needWake = mMessages == null || mMessages.target != null; } // 回收到消息池 p.recycleUnchecked(); if (needWake \u0026\u0026 !mQuitting) { nativeWake(mPtr); } } } ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:5","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"连接Native层的桥梁 点一下，只需要知道MessageQueue与Native层关系密切，Native的章节会详细讲。 // MessageQueue.java MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; // 初始化与native相关 mPtr = nativeInit(); } private void dispose() { if (mPtr != 0) { // 销毁与native相关 nativeDestroy(mPtr); mPtr = 0; } } // 一堆与native相关的犯法 private native static long nativeInit(); private native static void nativeDestroy(long ptr); private native void nativePollOnce(long ptr, int timeoutMillis); private native static void nativeWake(long ptr); private native static boolean nativeIsPolling(long ptr); private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events); ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:6","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"IdleHandler Handler，处理消息。 IdleHandler，只在线程空闲的时候执行一些业务逻辑，通常不是很紧要的任务 IdleHandler定义在MessageQueue.java中： // MessageQueue.java public static interface IdleHandler { boolean queueIdle(); } 通过MessageQueue.addIdleHandler()来添加IdleHandler任务 // MessageQueue.java public void addIdleHandler(@NonNull IdleHandler handler) { if (handler == null) { throw new NullPointerException(\"Can't add a null IdleHandler\"); } synchronized (this) { mIdleHandlers.add(handler); } } 通过MessageQueue.removeIdleHandler()来移除IdleHandler任务 // MessageQueue.java public void removeIdleHandler(@NonNull IdleHandler handler) { synchronized (this) { mIdleHandlers.remove(handler); } } 使用示例 // Example.java MessageQueue messageQueue = Looper.myQueue(); messageQueue.addIdleHandler(new MessageQueue.IdleHandler() { @Override public boolean queueIdle() { // TODO return false; } }); ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:5:7","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"Handler ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:6:0","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"获取消息 前文有提到过，调用Handler.obtainMessage()进而调用Message.obtain()从消息池中获取消息。 // Handler.java public final Message obtainMessage(...) { return Message.obtain(...) } ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:6:1","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"发送消息 最基础的sendMessage()系列 public final boolean sendMessage(@NonNull Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) { Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis); } ... 用法 Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); switch(msg.what) { // TODO: Use the data from msg to do Something } } }; new Thread(new Runnable() { @Override public void run() { Message msg = new Message(); msg.what = 1; handler.sendMessage(msg); } }); 最好用的post()系列 public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } public final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) { return sendMessageAtTime(getPostMessage(r), uptimeMillis); } public final boolean postDelayed(@NonNull Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } ... 用法 Handler mHandler = new Handler(); String data = \"data\" new Thread(new Runnable() { @Override public void run() { handler.post(new Runnable() { @Override public void run() { // TODO: Use data to do something } }); } }).start(); 这些方法最终都是调用MessageQueue.enqueueMessage()，鉴于方法太多，这里汇总成一张图： ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:6:2","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"处理消息 在上文发送消息中其实演示过用法了，这里过一遍handleMessage()的源码。 // Handler.java // 回调函数的接口 public interface Callback { boolean handleMessage(@NonNull Message msg); } // handleMessage public void handleMessage(@NonNull Message msg) { } // 分发消息 public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 我们通常在回调函数Callback中重写handleMessage()，然后handleMessage()中的代码会在dispatchMessage()中执行。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:6:3","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"总结 总体架构的过程如图： 发送消息的过程如图： MessageQueue.euqueueMessage()向MessageQueue中插入一个Message。 MessageQueue.next()从MessageQueue中提取一个Message。 ","date":"2020-09-09","objectID":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/:7:0","tags":["Android Framework"],"title":"Android消息机制（Java层）","uri":"/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"},{"categories":["Android Framework"],"content":"Activity事件传递 以“按下”事件为例，首先由Activity捕获点击事件，因此查看Activity.class中的dispatchTouchEvent()。 // Activity.java public boolean dispatchTouchEvent(MotionEvent ev) { // 可无视：判断是否是“按下”，如果是则执行onUserInteraction()，这个方法与事件分发机制关联不大。 if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // 关键：事件分发，跟踪这个方法可以看到事件一层层地传递 if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 处理后事：如果事件没有向下传递，那么调用这个方法直接消费事件。 return onTouchEvent(ev); } ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:1:0","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"事件 在MotionEvent.class中所有带ACTION_的： // MotionEvent.java // Action的掩码 public static final int ACTION_MASK = 0xff; // 手指按下 public static final int ACTION_DOWN = 0; // 手指抬起 public static final int ACTION_UP = 1; // 手指在屏幕上滑动 public static final int ACTION_MOVE = 2; // 非人为因素取消 public static final int ACTION_CANCEL = 3; // 还有很多其他事件，自己去看 ... 基本流程： ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:1:1","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"用户交互函数 // Activity.java /** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and {@link #onUserLeaveHint} are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notification. * * \u003cp\u003eAll calls to your activity's {@link #onUserLeaveHint} callback will * be accompanied by calls to {@link #onUserInteraction}. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * \u003cp\u003eNote that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */ public void onUserInteraction() { } 根据注释中给出的信息，onUserInteraction会在按键、触摸、滑动的情况下调用。 找了ComponentActivity、FragmentActivity、AppCompatActivity，都没有onUserInteraction的实现，也就是说这个方法是留工程师使用的。你可以在Activity以及它的任意子类中重写它： // MainActivity.java class MainActivity: AppCompatActivity() { override fun onUserInteraction() { ... } } ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:1:2","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"事件传递 调用Window.superDispatchTouchEvent()进行事件传递。 getWindow().superDispatchTouchEvent(ev) PhoneWindow getWindow()获取了Activity.class中的mWindow变量。 // Activity.java public Window getWindow() { return mWindow; } mWindow在attach()方法中被赋值为PhoneWindow对象。所以getWindow()拿到的是PhoneWindow。 // Activity.java final void attach(...) { mWindow = new PhoneWindow(this, window, activityConfigCallback); } 源码读到这里，PhoneWindow会报红，直接双击Shift按键，输入PhoneWindow进行搜索。 DecorView PhoneWindow中的superDispatchTouchEvent()调用了mDecor的superDispatchTouchEvent() // PhoneWindow.java @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } mDecor是一个DecorView对象。 // PhoneWindow.java private DecorView mDecor; public PhoneWindow(...) { if (preservedWindow != null) { ... mDecor = (DecorView) preservedWindow.getDecorView(); ... } } 打开DecorView： DecorView.superDispatchTouchEvent()调用了ViewGroup.dispatchTouchEvent()。 DecorView继承FrameLayout，包含ViewGroup mContentRoot，所以DecorView是顶级布局。 // DecorView.java public class DecorView extends FrameLayout ... { // 根内容是ViewGroup ViewGroup mContentRoot; // 继续调用... public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } } getWindow()拿到了PhoneWindow对象，PhoneWindow中的DecorView执行事件superDispatchTouchEvent，再进一步传递给ViewGroup执行ViewGroup.dispatchTouchEvent()。再往下传递就是ViewGroup之间的事件传递了，将在后文讲解。 ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:1:3","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"处理未消费的事件 return onTouchEvent(ev) 调用了Activity.onTouchEvent()用来处理没有在传递过程中没有被消费的事件。 // Activity.java public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; } 调用了Window.shouldCloseOnTouch()，方法中判断了方法是否越界、是否按下、是否超出顶级布局，满足条件则Activity消费事件，否则丢弃事件。 // Window.java public boolean shouldCloseOnTouch(Context context, MotionEvent event) { if (mCloseOnTouchOutside \u0026\u0026 event.getAction() == MotionEvent.ACTION_DOWN \u0026\u0026 isOutOfBounds(context, event) \u0026\u0026 peekDecorView() != null) { return true; } return false; } ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:1:4","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"ViewGroup事件传递 逻辑全部在ViewGroup.dispatchTouchEvent中 // ViewGroup.java @Override public boolean dispatchTouchEvent(MotionEvent ev) { ... } ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:2:0","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"检查 在开始正式传递事件前，进行了：一致性检查、焦点检查、隐私政策检查。 // ViewGroup.java @Override public boolean dispatchTouchEvent(MotionEvent ev) { // 一致性检查：确保手势动作完整 if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // 焦点检查：确定事件的类型是焦点事件还是普通事件 if (ev.isTargetAccessibilityFocus() \u0026\u0026 isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; // 安全性检查：如果窗口处于隐藏状态则丢弃事件，确保不会触发隐藏窗口 if (onFilterTouchEventForSecurity(ev)) { 一致性检查 // ViewGroup.java if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } mInputEventConsistencyVerifier在View.class中，在注释中我们看到这个变量是Debugge时使用的。 // View.java /** * Consistency verifier for debugging purposes. * @hide */ protected final InputEventConsistencyVerifier mInputEventConsistencyVerifier = InputEventConsistencyVerifier.isInstrumentationEnabled() ? new InputEventConsistencyVerifier(this, 0) : null; 在Debugge模式下，肯定要启动Instrumentation（仪表）用于获取测试信息，因此isInstrumentationEnabled==true，则mInputEventConsistencyVerifier被赋值为InputEventConsistencyVerifier对象，触发InputEventConsistencyVerifier.onTouchEvent(ev, 1)来进行事件的一致性检查。 在用户模式下，isInstrumentationEnabled==false，不做事件的一致性检查。在开发者模式下，isInstrumentationEnabled()==true如果ViewGroup的isInstrumentationEnabled()。 什么是事件的一致性检查？我们平时用手机，如果你想在屏幕上进行“单击”操作，除了按下还要抬起，才是一个完整“单击”手势，如果只是按下没有抬起，这个手势就不是“单击”手势了。事件的一致性检查就是看你有没有与“按下”配对的“抬起”操作。 // InputEventConsistencyVerifier.java public void onTouchEvent(MotionEvent event, int nestingLevel) { switch (action) { case MotionEvent . ACTION_DOWN : if (mTouchEventStreamPointers != 0) { // 如果出现不一致就会报错 problem(\"ACTION_DOWN but pointers are already down. \" + \"Probably missing ACTION_UP from previous gesture.\"); } ensureHistorySizeIsZeroForThisAction(event); ensurePointerCountIsOneForThisAction(event); mTouchEventStreamPointers = 1 \u003c \u003c event . getPointerId (0); break; } } 焦点检查 // ViewGroup.java if (ev.isTargetAccessibilityFocus() \u0026\u0026 isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false) } ev.isTargetAccessibilityFocus()：事件是否要交给有焦点的View处理。 isAccessibilityFocusedViewOrHost()：当前ViewGroup中是否存在有焦点的View。 如果两者都满足，这说明当前ViewGroup的子视图中存在处理焦点事件的视图。那么对于当前ViewGroup，这个事件就是普通事件。将事件通过setTargetAccessibilityFocus(false)转化为普通事件进行处理。 // MotionEvent.java /** @hide */ public final void setTargetAccessibilityFocus(boolean targetsFocus) { final int flags = getFlags(); nativeSetFlags(mNativePtr, targetsFocus ? flags | FLAG_TARGET_ACCESSIBILITY_FOCUS : flags \u0026 ~FLAG_TARGET_ACCESSIBILITY_FOCUS); } 安全性检查 // ViewGroup.java // 安全性检查 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { 使用安全过滤器进行安全性检查 // ViewGroup.java public boolean onFilterTouchEventForSecurity(MotionEvent event) { if ((mViewFlags \u0026 FILTER_TOUCHES_WHEN_OBSCURED) != 0 \u0026\u0026 (event.getFlags() \u0026 MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) { // 如果当前窗口是隐藏的，那就丢弃这个事件 return false; } // 否则消费这个事件 return true; } ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:2:1","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"拦截器 完成一些简单的参数赋值和状态清空后，我们要确定是否拦截。 // ViewGroup.java // 参数赋值 final int action = ev.getAction(); final int actionMasked = action \u0026 MotionEvent.ACTION_MASK; // 重置状态 if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); resetTouchState(); } // 拦截器确定是否拦截 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags \u0026 FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { intercepted = true; } 参数赋值 // ViewGroup.java // 参数赋值 final int action = ev.getAction(); final int actionMasked = action \u0026 MotionEvent.ACTION_MASK; 将事件中的MotionEvent.action直接赋值给action变量 MotionEvent.action和MotionEvent.ACTION_MASK的并运算结果作为掩码actionMasked。 重置状态 // ViewGroup.java // 重置状态 if (actionMasked == MotionEvent.ACTION_DOWN) { // 取消和清空所有触摸目标的状态 cancelAndClearTouchTargets(ev); // 重置触摸状态 resetTouchState(); } ViewGroup会保留上一次事件的触摸目标的状态，因此开始新的事件的时候，要先将各种状态重置，以便记录新事件的状态。 是否拦截 // ViewGroup.java // 拦截器确定是否拦截 /** * intercepted：拦截标志位 * true：已拦截 * false：未拦截 */ final boolean intercepted; // 默认情况下都允许拦截，如果是\"按下\"或者\"事件曾经经过其他视图【重点，代码段后马上填坑】\"，则需要再进一步判断 // 用到了参数赋值时的actionMaksed变量 // 子视图可以通过ViewGroup.requestDisallowInterceptTouchEvent()来禁止父视图对事件的拦截 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 根据ViewGroup自身的信息确定是否拦截 final boolean disallowIntercept = (mGroupFlags \u0026 FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { // ViewGroup允许拦截，则调用拦截函数进行拦截，并为拦截标志位赋值 intercepted = onInterceptTouchEvent(ev); // 将事件中的action值恢复（前面进行了位操作，要重新赋值还原） // 用到了参数赋值时的action变量 ev.setAction(action); } else { // ViewGroup不允许拦截，则不拦截，拦截标志位置false intercepted = false; } } else { // 默认情况下都允许拦截，拦截标志位置true intercepted = true; } mFirstTouchTarget != null ，为什么意味着“事件曾经经过其他视图”？事件会从父视图向子视图往下传递，如果父视图没有消费掉视图，就会向子视图传递。在这个过程中，会有一个由TouchTarget作为结点组成的单链表，用于存储事件向下传递过程中经过的视图，每经过一个视图就在这个单链表末尾新增一个TouchTarget。例如视图层次从父到子是ABC，则单链表从头到尾是CBA，而mFirstTouchTarget就指向表头，mFirstTouchTarget != null 意味着表不为空，意味着事件曾经经过其他视图。如何得出这个过程？答案在后续的代码中。 拦截函数onInterceptTouchEvent public boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.isFromSource(InputDevice.SOURCE_MOUSE) // 事件源来自可点击输入设备（屏幕） \u0026\u0026 ev.getAction() == MotionEvent.ACTION_DOWN // 是“按下”事件 \u0026\u0026 ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) // 是否有屏幕点击或者按键组合 \u0026\u0026 isOnScrollbarThumb(ev.getX(), ev.getY()) // 点击的位置是否在视图范围内 ) { // 拦截 return true; } // 不拦截 return false; } ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:2:2","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"分发事件 分发准备 // ViewGroup.java // 如果事件已拦截而且曾经经过其他视图，则将事件设定为普通事件 if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // 取消标志位，检查事件是不是被中途取消 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 变量准备 final boolean split = (mGroupFlags \u0026 FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; // 新的TouchTarget，用于存储新触摸目标 boolean alreadyDispatchedToNewTouchTarget = false; // 已分发至新触摸目标标志位 // 如果事件没被取消且没被拦截，则执行后续代码（如果有符合条件的子视图，就会将事件传递给子视图） if (!canceled \u0026\u0026 !intercepted) { View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; // 对于“按下”事件... if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026\u0026 actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { // 事件的索引 final int actionIndex = ev.getActionIndex(); // 运用事件的索引来获取事件的唯一标识符 final int idBitsToAssign = split ? 1 \u003c\u003c ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 清理掉早前的id，以便后续赋值新的id removePointersFromTouchTargets(idBitsToAssign); 确定目标 如果不拦截，就找到符合条件的子视图向下传递事件；如果没有符合条件的子视图，那就“另谋出路”，代码段后会解释。 // ViewGroup.java // 子视图数量 final int childrenCount = mChildrenCount; // 如果有子视图... if (newTouchTarget == null \u0026\u0026 childrenCount != 0) { // 事件的横坐标 final float x = ev.getX(actionIndex); // 事件的纵坐标 final float y = ev.getY(actionIndex); // 从前到后遍历子视图，获得的子视图列表 final ArrayList\u003cView\u003e preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026\u0026 isChildrenDrawingOrderEnabled(); final View[] children = mChildren; // 从前到后遍历子视图 for (int i = childrenCount - 1; i \u003e= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 如果子视图无法获取焦点，则跳过本次循环 if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //如果子视图不可见，或者触摸的坐标不在子视图的范围内，则跳过本次循环 if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } // 经过上述过滤后，找到的第一个符合条件的子视图作为“新的触摸目标”，也就是事件的接收方 newTouchTarget = getTouchTarget(child); // 如果有符合条件的视图，那就跳出整个循环 if (newTouchTarget != null) { // 把新的id赋值给新的触摸目标 newTouchTarget.pointerIdBits |= idBitsToAssign; break; } // 重置取消或抬起标志位 resetCancelNextUpFlag(child); // 【重点】将事件传递给第一个符合条件的子视图 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // 子视图接收“按下”事件的时间点 mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // 从子视图列表中找到子视图的id并记录到mLastTouchDownIndex for (int j = 0; j \u003c childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // 【重点】addTouchTarget，将以子视图为内容构建的新结点插入TouchTarget链表的表头 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // 将事件设置为普通事件 ev.setTargetAccessibilityFocus(false); } // 清理下内存 if (preorderedList != null) preorderedList.clear(); } // 如果没有找到符合条件的子视图，将TouchTarget单链表头的元素mFirstTouchTarget赋值给新触摸目标 if (newTouchTarget == null \u0026\u0026 mFirstTouchTarget != null) { newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } // 重写分配id newTouchTarget.pointerIdBits |= idBitsToAssign; } } } addTouchTarget的代码： private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; } 前面提到了mFirstTouchTarget从而引出了TouchTarget单链表的原因，正是因为addTouchTarget方法。 TouchTarget.class是以View为内容的结点。事件不断从父视图传向子视图，每传递一次，子视图收到事件时就会触发一次addTouchTarget，子视图就会被构造为新结点，以头插入的方式插入子节点，并将新插入的结点赋值给mFirstTouchTarget（因此mFirstTouchTarget就指向表头）。 如果没有找到符合条件的子视图，mFirstTouchTarget就是上一次被插入TouchTarget单","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:2:3","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"传递事件 确定mFirstTouchTarget之后，开始传递事件，如果是向子视图的传递事件，那已经在上述代码中完成了，下面是当前视图的传递事件。 // ViewGroup.java if (mFirstTouchTarget == null) { // 【重点】如果没有触摸目标，直接由当前视图进行处理 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // 如果有触摸目标，那么ACTION_MOVE、ACTION_UP等事件开始相继执行。 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026\u0026 target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // 发生抬起或非人为因素取消时，更新触摸目标 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split \u0026\u0026 actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 \u003c\u003c ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled \u0026\u0026 mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 传递事件过程的主要函数是dispatchTransformedTouchEvent()，注意其中的View.dispatchTouchEvent()函数的调用。 // ViewGroup.class private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { // 如果传入的子视图为null，就调用当前视图的dispatchTouchEvent()，相当于分发给当前视图。 handled = super.dispatchTouchEvent(event); } else { // 如果传入的子视图不为null，则执行子视图的dispatchTouchEvent()，相当于分发给子视图。 handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } ... return handled; } 注意，这里调用的不是ViewGroup.dispatchTouchEvent()而是View.dispatchTouchEvent()。从个方法开始进入View的事件传递。 ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:2:4","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"View事件传递 // View.class public boolean dispatchTouchEvent(MotionEvent event) { // 焦点事件的处事方式 if (event.isTargetAccessibilityFocus()) { if (!isAccessibilityFocusedViewOrHost()) { return false; } // 处理完后转为普通事件 event.setTargetAccessibilityFocus(false); } boolean result = false; // 一致性检查 if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { // 如果存在滚动操作，立刻停止 stopNestedScroll(); } // 安全性检查 if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags \u0026 ENABLED_MASK) == ENABLED \u0026\u0026 handleScrollBarDragging(event)) { result = true; } ListenerInfo li = mListenerInfo; // 先执行OnTouchListener.onTouch()消费事件 if (li != null \u0026\u0026 li.mOnTouchListener != null \u0026\u0026 (mViewFlags \u0026 ENABLED_MASK) == ENABLED \u0026\u0026 li.mOnTouchListener.onTouch(this, event)) { result = true; } // 如果OnTouchListener.onTouch()消费事件没有消费事件，再执行onTouchEvent()消费事件 if (!result \u0026\u0026 onTouchEvent(event)) { result = true; } } if (!result \u0026\u0026 mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN \u0026\u0026 !result)) { stopNestedScroll(); } return result; } View.onTouchEvent()代码，大致逻辑：如果视图可以被点击或者长按并且在特定手势下满足一些特定条件，则返回true，表示已经被消费；否则返回false，表示未被消费。 public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags \u0026 CLICKABLE) == CLICKABLE || (viewFlags \u0026 LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026 CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags \u0026 ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP \u0026\u0026 (mPrivateFlags \u0026 PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable; } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } if (clickable || (viewFlags \u0026 TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: mPrivateFlags3 \u0026= ~PFLAG3_FINGER_DOWN; if ((viewFlags \u0026 TOOLTIP) == TOOLTIP) { handleTooltipUp(); } if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } boolean prepressed = (mPrivateFlags \u0026 PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026 PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() \u0026\u0026 isFocusableInTouchMode() \u0026\u0026 !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress \u0026\u0026 !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClickInternal(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivat","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:3:0","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Android Framework"],"content":"总结 事件分发顺序：Activity=\u003eViewGroup=\u003eView Activity事件传递机制：Activity通过PhoneWindow将事件传递给顶级布局DecorView，顶级布局将事件传给它内含的ViewGroup，调用ViewGroup的ViewGroup.dispatchTouchEvent()来分发事件。 ViewGroup事件传递机制：ViewGroup.dispatchTouchEvent()中先通过ViewGroup.onInterceptTouchEvent()判断是否拦截，如果拦截则将事件传递给子视图，不拦截则将事件传递给当前视图，从而确定触摸目标mFirstTouchTarget是子视图还是当前视图。再调用ViewGroup.dispatchTransformedTouchEvent()将事件分发给mFirstTouchTarget，当前视图和子视图都通过调用View.dispatchTouchEvent()来消费事件。 View事件传递机制：View.dispatchTouchEvent()中通过调用OnTouchListener.onTouch()消费事件，若成功消费则返回true，否则调用View.onTouchEvent()事件并返回false，并且层层返回false，最后由Activity.onTouchEvent()来消费事件。 ","date":"2020-09-07","objectID":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/:4:0","tags":["Android Framework"],"title":"Android事件分发机制","uri":"/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":["Jetpack"],"content":"任务排序 我们使用WorkManager的函数： beginWith() then() 来完成任务排序，例如： WorkManager .getInstance(myContext) // 开始时对数据进行过滤 .beginWith(filter) // 再对数据进行压缩 .then(compress) // 再上传数据 .then(upload) // 千万别忘记enqueue()，进入队列后才能执行 .enqueue() ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/:1:0","tags":["Jetpack"],"title":"WorkManager之任务关联","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/"},{"categories":["Jetpack"],"content":"链接原理 在《WorkManager之添加任务》中我们提到过WorkContinuation，他是用于任务排序的。 WorkManager之所能像这样执行，是因为beginWith()会返回WorkContinuation，每个WorkContinuation又能执行then()，执行完then之后又返回WorkContinuation…由此不断循环，构成最终的一个WorkContinuation，将其传入执行队列中。 这就是一个单向单链表的构造的过程，每次添加新结点，都返回新的链条，WorkContinuation就相当于每次返回的链条。 此外，不仅仅是能加入新结点实现纵向连接，链表和链表之间还可以横向连接： /* * \u003cpre\u003e * A C * | | * B D * | | * +-------+ * | * E \u003c/pre\u003e */ WorkContinuation left = workManager.beginWith(A).then(B); WorkContinuation right = workManager.beginWith(C).then(D); WorkContinuation final = WorkContinuation.combine(Arrays.asList(left, right)).then(E); final.enqueue(); 上述代码就是先构造了左链表和右链表，最后在左右链表结合后再添加E结点，形成最终的工作链final。当final开始执行时，左右链表会先按各自规定的顺序执行AB、CD，等左右链表的最后一个任务B和D执行完后，再执行E。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/:1:1","tags":["Jetpack"],"title":"WorkManager之任务关联","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/"},{"categories":["Jetpack"],"content":"输出合并 我们在《WorkManager之添加任务》中学习了“任务输入/输出”。在工作链中，父级任务的输出将作为输入传递给直接相连的子任务，例如A的输出会传给B作为输入，C的输出会传给D作为输入，B和D的输出会作为输入传给E。 等等，有点不对劲。B和D两个输入源，怎么输出给E呢？既然E要等B和D，说明B和D肯定是同时用到的，两者必须同时传入，不可能先传一个再传另一个。没错，因此我们必须将两者的结果进行合并。 我们通过给WorkRequest设置InputMerger来实现，例如对于OneTimeWorkRequest： val compress: OneTimeWorkRequest = OneTimeWorkRequestBuilder\u003cCompressWorker\u003e() // 设置合并方式为ArrayCreatingInputMerger .setInputMerger(ArrayCreatingInputMerger::class) .build() 有两种合并的方式： OverwritingInputMerger:覆盖式，将所有输入中的所有键添加到输出中。如果发生冲突，后面的键会覆盖前面的键。 ArrayCreatingInputMerger:保留式，会创建数组用于存储所有输入。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/:2:0","tags":["Jetpack"],"title":"WorkManager之任务关联","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/"},{"categories":["Jetpack"],"content":"链接与状态 我们在《WorkManager之任务信息》中提到了WorkInfo.State，我们要注意三点： 仅当所有父级任务成功完成后，当前任务会变为ENQUEUED。 任意父级任务失败后，当前任务会变成FAILED。 任意父级任务取消后，当前任务会变成CANCELLED。 这里详细陈述取消任务。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/:3:0","tags":["Jetpack"],"title":"WorkManager之任务关联","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/"},{"categories":["Jetpack"],"content":"取消任务 CANCELLED ，表示已经被取消的任务。 我们取消任务时，可能是取消一个，通过id取消 // 根据id取消特定的一个任务 cancelWorkById(@NonNull UUID id) 也可能是取消一批，那就要考虑关联的方式 任务之间的关联方式： 标签Tag 链接WorkContinuation（之前有提过，是任务排序用的，下一章详细讲解） // 根据tag取消所有带有这个tag的任务 cancelAllWorkByTag(@NonNull final String tag) // 如果任务之间是有链接关系的，那么取消了当前这个任务，后续的任务都会直接。 cancelWorkById(@NonNull UUID id) 也可能是取消全部 cancelAllWork() 被取消后的任务全部进去CANCELLED状态。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/:3:1","tags":["Jetpack"],"title":"WorkManager之任务关联","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94/"},{"categories":["Jetpack"],"content":"前言 我们在《WorkManager之任务请求》结尾提到了标签Tag可以用来观察任务，它其实是任务信息WorkInfo的一部分，本章将详细陈述任务信息。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/:0:0","tags":["Jetpack"],"title":"WorkManager之任务信息","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/"},{"categories":["Jetpack"],"content":"任务信息 想要管理任务，首先我们要考虑拿到任务的相关信息，WorkInfo就是用于存储任务的信息的类： public final class WorkInfo { private @NonNull UUID mId; // 唯一id private @NonNull State mState; // 状态 private @NonNull Data mOutputData; // 输出数据 private @NonNull Set\u003cString\u003e mTags; // 标签 private @NonNull Data mProgress; // 进度 private int mRunAttemptCount; // 重试运行的次数 } 围绕它持有的属性信息，我们可以很快猜到它会有以下操作： 通过Id获取一个WorkInfo… 通过Tag获取一批WorkInfo… 通过获取状态，根据任务当前所处不同的状态，进项不同的操作… 获取输出（之前的章节提到过） 进度管理，可能是通过获取进度将进度通过UI界面展示给用户… 重试管理，可能是重试多少次后执行其他操作… 没错，其实主要的也就是这些操作。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/:1:0","tags":["Jetpack"],"title":"WorkManager之任务信息","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/"},{"categories":["Jetpack"],"content":"获取任务信息 通过id获取特定任务的信息 // androidx.work.WorkManager // 根据id获取Listenable\u003cWorkInfo\u003e public @NonNull ListenableFuture\u003cWorkInfo\u003e getWorkInfoById(@NonNull UUID id) { ... } // 根据id获取LiveData\u003cWorkInfo\u003e public @NonNull LiveData\u003cWorkInfo\u003e getWorkInfoByIdLiveData(@NonNull UUID id) { ... } 通过tag获取一批相关的信息 // androidx.work.WorkManager // 获取持有特定Tag的ListenableFuture\u003cList\u003cWorkInfo\u003e\u003e public @NonNull ListenableFuture\u003cList\u003cWorkInfo\u003e\u003e getWorkInfosByTag(@NonNull String tag) { ... } // 获取持有特定Tag的LiveData\u003cList\u003cWorkInfo\u003e\u003e public @NonNull LiveData\u003cList\u003cWorkInfo\u003e\u003e getWorkInfosByTagLiveData(@NonNull String tag) { ... } ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/:1:1","tags":["Jetpack"],"title":"WorkManager之任务信息","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/"},{"categories":["Jetpack"],"content":"添加观察者 看到LiveData相信你会自然而然地想到观察者Observer，事实也确实如此，我们为获取到的WorkInfo添加观察者，运用观察者的触发机制实现对Work的管理。 WorkManager // 获取WorkManager的实现类的实例 .getInstance(myContext) // 根据id获取到任务的LiveData\u003cWorkInfo\u003e .getWorkInfoByIdLiveData(uploadWorkRequest.id) .observe(lifecycleOwner, Observer { workInfo -\u003e // 根据WorkInfo的状态做出反应 if (workInfo != null \u0026\u0026 workInfo.state == WorkInfo.State.SUCCEEDED) { displayMessage(\"Work finished!\") } }) ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/:1:2","tags":["Jetpack"],"title":"WorkManager之任务信息","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/"},{"categories":["Jetpack"],"content":"任务状态 mState是WorkInfo.State枚举类，用于描述任务状态： ENQUEUED 延迟时间结束，已进入队列 RUNNING 正在运行 SUCCEEDED 运行结束且成功 FAILED 运行结束且失败 BLOCKED 阻塞 CANCELLED 已被取消 对于OneTimeWorkRequest有以上完整的状态；而对于PeriodicWorkRequest没有SUCCEEDED和FAILED 运行结束且失败，毕竟这两个是终止状态，而周期性任务（除非手动取消）不会自动终止。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/:2:0","tags":["Jetpack"],"title":"WorkManager之任务信息","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/"},{"categories":["Jetpack"],"content":"任务进度 一些下载任务，我们希望让用户看到进度，那就用到了任务进度。 为了能够使用进度信息，我们需要注意以下要点： 接入协程任务接口CoroutineWork（不了解协程的小伙伴可以看我在Kotlin分类下关于协程的文章）。 doWork要写成挂起函数（添加suspend关键字） import android.content.Context import androidx.work.CoroutineWorker import androidx.work.Data import androidx.work.WorkerParameters import kotlinx.coroutines.delay class ProgressWorker(context: Context, parameters: WorkerParameters) : CoroutineWorker(context, parameters) { companion object { const val Progress = \"Progress\" private const val delayDuration = 1L } override suspend fun doWork(): Result { val firstUpdate = workDataOf(Progress to 0) val lastUpdate = workDataOf(Progress to 100) setProgress(firstUpdate) delay(delayDuration) setProgress(lastUpdate) return Result.success() } } 使用示例： WorkManager .getInstance(applicationContext) // requestId是WorkRequest的id .getWorkInfoByIdLiveData(requestId) .observe(observer, Observer { workInfo: WorkInfo? -\u003e if (workInfo != null) { val progress = workInfo.progress val value = progress.getInt(Progress, 0) // TODO：运用进度信息做一些操作 } }) ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/:3:0","tags":["Jetpack"],"title":"WorkManager之任务信息","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF/"},{"categories":["Jetpack"],"content":"前言 继上一章《WorkMananger之添加任务》之后，我们再来详细学习任务请求WorkRequest。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:0:0","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"构造器 WorkRequest有两种构造器： OneTimeWorkRequestBuilder\u003cWorkRequest\u003e() 一次性任务构造器 PeriodicWorkRequestBuilder\u003cWorkRequest\u003e() 周期性任务构造器 分别构造两种WorkRequest： OneTimeWorkRequest 一次性任务 PeriodicWorkRequest 周期性任务 使用示例： // 一次性任务 var oneTimeWorkRequest = OneTimeWorkRequestBuilder\u003cMyWorkRequest\u003e() .builder() // 每10秒执行一次 var periodicWorkRequest = PeriodicWorkRequestBuilder\u003cMyWorkRequest\u003e(10, TimeUnit.SECONDS) .builder() 周期性任务的时间设置常用方式： Duration Long+TimeUnit 其他方式可自行查阅源码，此处不展开。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:1:0","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"约束 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:2:0","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"设置约束 任务满足约束条件，才会执行 // 创建约束 val constraints = Constraints.Builder() .setRequiresDeviceIdle(true) .setRequiresCharging(true) .build() // 设置约束 val compressionWork = OneTimeWorkRequestBuilder\u003cCompressWorker\u003e() .setConstraints(constraints) .build() ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:2:1","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"Constraints 包 androidx.work.Constraints 一般约束 包含以下约束方法： setRequiresDeviceIdle() 设备空闲时运行(Api23及以上） setRequiresCharging() 正在充电时运行 setRequiredNetworkType() 在特定网络类型下运行 setRequiresBatteryNotLow() 在电量充足时运行 setRequiresStorageNotLow() 在存储空间充足时运行 其他的好理解，网络类型补充说明一下，枚举类NetworkType声明了以下五种网络类型： NOT_REQUIRED 任务不需要网络 CONNECTED 任务要求连接网络 UNMETERED 任务要求非计量网络（不限量使用的网络，例如包月包年的宽带） NOT_ROAMING 要求非漫游网络（不是4G、5G之类的，而是连接wifi。别告诉我你手机可能连网线，如果可以那应该也算是非漫游） METERED 任务要求计量网络（按量收费的网络） 触发器式约束 除了上述约束，Constraints还包含以下一些触发器式的约束： addContentUriTrigger() 当本地特定的Uri更新时运行(Api24及以上） setTriggerContentUpdateDelay() 特定内容更新后延迟一段时再运行 setTriggerContentMaxDelay 特定内容更新后最大延迟多少时间再运行 其中setTriggerContentUpdateDelay()和setTriggerContentMaxDelay()： Api24及以上使用参数duration（延迟时间）和timeunit（时间单位） Api26以上使用参数duration(延迟时间） 前者规定了延迟时间的下限，后者规定了延迟时间的上限。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:2:2","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"延迟时间 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:3:0","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"设置延迟时间 调用setInitialDelay()设置延迟时间： // androidx.work.WorkRequest public @NonNull B setInitialDelay(long duration, @NonNull TimeUnit timeUnit) { ... } 使用示例： val uploadWorkRequest = OneTimeWorkRequestBuilder\u003cUploadWorker\u003e() .setInitialDelay(10, TimeUnit.MINUTES) .build() ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:3:1","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"实际延迟时间 结合我们在执行约束中提到的约束，我们可以知道任务实际执行的时间为：初始化延迟+约束延迟 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:3:2","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"重试与退避政策 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:4:0","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"设置退避政策 我们在上一章《WorkMananger之添加任务》提到过Worker执行完成后会返回三种状态： Result.success() 执行成功 Result.failure() 执行失败 Result.retry() 稍后重试 对于Result.retry()，我们可以设置退避政策BackoffPolicy，使得任务暂时退避不执行，等过一段时间后再执行，从而达到“稍后重试”的效果。 调用setBackoffCriteria()来设置BackoffPolicy： // androidx.work.WorkRequest public final @NonNull B setBackoffCriteria( @NonNull BackoffPolicy backoffPolicy, long backoffDelay, @NonNull TimeUnit timeUnit) 使用示例： val uploadWorkRequest = OneTimeWorkRequestBuilder\u003cUploadWorker\u003e() .setBackoffCriteria( BackoffPolicy.LINEAR, OneTimeWorkRequest.MIN_BACKOFF_MILLIS, TimeUnit.MILLISECONDS) .build() ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:4:1","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"退避政策的时间 退避政策BackoffPolicy是枚举类，包含两种时间延迟方式： EXPONENTIAL 指数增长型 LINEAR 线性增长型 每次重试失败后，后一次的时间延迟将按BackoffPlicy指定的方式增长。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:4:2","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"任务的输入/输出 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:5:0","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"数据包 任务的输入和输出，使用Data作为数据包，打包的过程由内联函数workOfData。 // androidx.work.Data inline fun workDataOf(vararg pairs: Pair\u003cString, Any?\u003e): Data { val dataBuilder = Data.Builder() for (pair in pairs) { dataBuilder.put(pair.first, pair.second) } return dataBuilder.build() } ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:5:1","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"设置输入包 我们调用setInputData()来设置数据包： // androidx.work.WorkRequest public final @NonNull B setInputData(@NonNull Data inputData) { ... } 使用示例： val imageData = workDataOf(Constants.KEY_IMAGE_URI to imageUriString) val uploadWorkRequest = OneTimeWorkRequestBuilder\u003cUploadWorker\u003e() .setInputData(imageData) .build() ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:5:2","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"设置输出包 同样使用workOfData来购建Data来作为输出，使用示例： class UploadWorker(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) { override fun doWork(): Result { // 获得输入 val imageUriInput = getInputData().getString(Constants.KEY_IMAGE_URI) // TODO：健壮性判断 // 使用输入完成工作 val response = uploadFile(imageUriInput) // 创建输出 val outputData = workDataOf(Constants.KEY_IMAGE_URL to response.imageUrl) // 返回输出 return Result.success(outputData) } } ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:5:3","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"标记 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:6:0","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"设置标记 生活中为事物做标记是为了快速找到并了解他们，在这里也是一样，为WorkRequest添加标记是为了方便后续观察他们。 使用addTag()为WorkRequest添加标记： // androidx.work.WorkRequest public final @NonNull B addTag(@NonNull String tag) { mTags.add(tag); return getThis(); } 在WorkRequest中的集合Set\u003cString\u003e mTags用于存储添加的标记。 使用示例： val cacheCleanupTask = OneTimeWorkRequestBuilder\u003cCacheCleanupWorker\u003e() .setConstraints(constraints) .addTag(\"cleanup\") .build() ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:6:1","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"取消标记 调用cancelAllWorkByTag()来取消所有带有特定Tag的任务： // androidx.work.WorkManagerImpl public @NonNull Operation cancelAllWorkByTag(@NonNull final String tag) { ... } 使用示例： WorkManager.getInstance(this).cancelAllWorkByTag() 关于如何通过标签来观察他们，我们将在后续的章节中陈述。 ","date":"2020-08-28","objectID":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/:6:2","tags":["Jetpack"],"title":"WorkManager之任务请求","uri":"/workmanager%E4%B9%8B%E4%BB%BB%E5%8A%A1%E8%AF%B7%E6%B1%82/"},{"categories":["Jetpack"],"content":"[TOC] 前言 Jetpack中的WorkManager用于管理后台运行的任务，可替代原先由Service执行的后台任务。 ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:0:0","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"使用 ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:1:0","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"Gradle gradle引入 implementation \"androidx.work:work-runtime-ktx:$work_version\" ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:1:1","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"Worker 实现Worker接口。 class MyWork( var appContext: Context, var workerParams: WorkerParameters ): Worker(appContext, workerParams) { override fun doWork(): Result { // TODO：执行任务的详细内容 /** * 返回执行结果 * 执行成功：Result.success() * 执行失败：Result.failure() * 稍后重试：Result.retry() */ return Result.success() } } ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:1:2","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"WorkerRequest 运用Worker构造任务请求WorkRequest /** * WorkerRequest两种类型 * OneTimeWorkRequest：一次性任务 * PeriodicWorkRequest：周期性任务 */ var myWorkRequest: OneTimeWorkRequest = OneTimeWorkRequestBuilder\u003cMyWorker\u003e().build() ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:1:3","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"WorkerManager 将任务添加到WorkerManager的队列中 // 获取WorkManager实例（单例模式），并将任务添加到WorkManager的队列中 WorkManager.getInstance(context).enqueue(myWorkRequest) ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:1:4","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"进入队列源码解析 我们解析“添加任务”过程的源码。 WorkManager.getInstance(context).enqueue(myWorkRequest) ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:2:0","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"获取WorkManager实例 WorkManager是一个抽象类，我们在获取WorkManager实例的时候获取到的是它的实现类WorkManagerImpl： // WorkManager.java // WorkManager获取实例的方法 public static @NonNull WorkManager getInstance(@NonNull Context context) { return WorkManagerImpl.getInstance(context); } ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:2:1","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"enqueue()添加任务请求 拿到实例后，我们将任务请求WorkRequest请求传入enqueue()方法，有两个主要的enqueue()方法： WorkManager中实现的enqueue(@NonNull WorkRequest workRequest)：用于添加一个任务请求。 WorkManagerImpl中实现的equeue(@NonNull List\u003c? extends WorkRequest\u003e workRequests)：用于添加一组任务请求。 WorkManager中的enqueue() // WorkManager @NonNull public final Operation enqueue(@NonNull WorkRequest workRequest) { // 调用了下面的enqueue(@NonNull List\u003c? extends WorkRequest\u003e requests) return enqueue(Collections.singletonList(workRequest)); } @NonNull public abstract Operation enqueue(@NonNull List\u003c? extends WorkRequest\u003e requests); 可见，即便是添加一个任务请求WorkRequest，这个任务请求依然会被转化为任务请求列表List\u003cWorkRequest，实际上执行的依然是enqueue(@NonNull List\u003c? extends WorkRequest\u003e requests)，而这个方法在WorkManagerImpl中被实现了。 WorkManagerImpl中的enqueue() 在WorkManagerImpl中我们实现了enqueue(@NonNull List\u003c? extends WorkRequest\u003e requests)，该方法执行了WorkContinuationImpl（即WorkContinuation的实现类）的enqueue()： // WorkManagerImpl.java @Override @NonNull public Operation enqueue( @NonNull List\u003c? extends WorkRequest\u003e workRequests ) { ... return new WorkContinuationImpl(this, workRequests).enqueue(); } WorkContinuation 我们并不清楚在WorkContinuation是什么，我们在WorkContinuation.java的头部注释看到这样的解释内容： /* * \u003cpre\u003e * A C * | | * B D * | | * +-------+ * | * E \u003c/pre\u003e * * you would write the following: * * \u003cpre\u003e * {@code * WorkContinuation left = workManager.beginWith(A).then(B); * WorkContinuation right = workManager.beginWith(C).then(D); * WorkContinuation final = WorkContinuation.combine(Arrays.asList(left, right)).then(E); * final.enqueue();}\u003c/pre\u003e */ 显而易见，WorkContinuation是用于任务排序用的。 在WorkManagerImpl中会首先构造WorkContinuation： WorkContinuationImpl( @NonNull WorkManagerImpl workManagerImpl, @NonNull List\u003c? extends WorkRequest\u003e work) { this( workManagerImpl, null, ExistingWorkPolicy.KEEP, work, // 传入List\u003cWorkRequest\u003e null ); } 调用了以下构造方法： WorkContinuationImpl( @NonNull WorkManagerImpl workManagerImpl, String name, ExistingWorkPolicy existingWorkPolicy, @NonNull List\u003c? extends WorkRequest\u003e work, @Nullable List\u003cWorkContinuationImpl\u003e parents ) { mWorkManagerImpl = workManagerImpl; mName = name; mExistingWorkPolicy = existingWorkPolicy; // List\u003cWorkRequest\u003e最终被传入mWork mWork = work; mParents = parents; mIds = new ArrayList\u003c\u003e(mWork.size()); mAllIds = new ArrayList\u003c\u003e(); if (parents != null) { for (WorkContinuationImpl parent : parents) { mAllIds.addAll(parent.mAllIds); } } for (int i = 0; i \u003c work.size(); i++) { String id = work.get(i).getStringId(); mIds.add(id); mAllIds.add(id); } } 我们传入的WorkRequest最终被传递到WorkContinuation的mWork这个队列中。 构造完成后，执行WorkContinuation中的enqueue()： @Override public @NonNull Operation enqueue() { ... if(!mEnqueued) { EnqueueRunnable runnable = new EnqueueRunnable(this); mWorkManagerImpl .getWorkTaskExecutor() .executeOnBackgroundThread(runnable); mOperation = runnable.getOperation(); } else { ... } return mOperation; } 他调用了WorkManagerImpl中的任务执行器WorkTaskExecutor将我们传入的任务调到后台线程中执行。 mWorkManagerImpl .getWorkTaskExecutor() .executeOnBackgroundThread(runnable); ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:2:2","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["Jetpack"],"content":"总结 Worker定义任务内容，WorkerRequest定义任务请求，WorkerManager管理任务的执行，WorkContinuation管理任务的顺序。 无论是添加一个任务请求Workquest还是一组任务请求List\u003cWorkRequest\u003e，执行的都是WorkManagerImpl中添加一组任务请求的方法enqueue(@NonNull List\u003c? extends WorkRequest\u003e requests)。 任务最终会被WorkManagerImpl中的WorkTaskExecutor调用到后台线程中执行。 代码的主体逻辑如下： ","date":"2020-08-27","objectID":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/:2:3","tags":["Jetpack"],"title":"WorkManager之添加任务","uri":"/workmanager%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1/"},{"categories":["设计模式"],"content":"释义 访问者模式，访问者可以改变访问目标类执行的算法。 访问者模式6e9e8a3abf669f2880278ac762e554b2 \" 访问者模式 访问目标类Target有Target1、Target2两个目标，Visitor作为访问者分别访问两个目标，访问者会根据访问的目标执行不同的算法。 ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：访问者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"访问者 interface Visitor { visit(target1: Target1) visit(target2: Target2) } class RealVisitor : Visitor { override visit(target1: Target1) { // do somthing for target1 } override visit(target2: Target2) { // do somthing for target2 } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：访问者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"访问目标 interface Target { fun accept(visitor: Visitor) } class Target1: Target { fun accept(visitor: Visitor) { visitor.visit(this) } } class Target2: Target { fun accept(visitor: Visitor) { visitor.visit(this) } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：访问者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 访问目标 val target1: Target = Target1() val target2: Target = Target2() // 访问者 val realVisitor: RealVisitor = RealVisitor() // 开始访问 // target1接受了访问者的访问，访问者执行了visit(target1: Target1） target1.accept(realVisitor) // target2接受了访问者的访问，访问者执行了visit(target2: Target2） target2.accept(realVisitor) } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：访问者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 模板模式，模板为抽象类，子类继承模板，但是调用的时候调用的是模版的方法。 模板模式2feaf82eae3f221420c979fc54df1fb9 \" 模板模式 子类Juice和Burger继承模板类Food，调用时将以抽象类中定义的方式进行。即形式上不是Juice.eat()而是Model.eat()，实质上时Juice.eat()。 ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：模板模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"抽象类 abstract class Food { fun eat() } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：模板模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"子类 class Juice : Food { fun eat() { println(\"drink juice\") } } class Burger : Food { fun eat() { println(\"eat burger\") } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：模板模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val food1: Food = Juice() val food2: Food = Burger() // 形式上调用的是父类的方法，实际上会调用子类的方法 food1.eat() food2.eat() } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：模板模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 策略模式，制定多种策略，主体对象根据需要使用不同的策略。 策略模式4b054073d842cbcaa716881d8dfbd732 \" 策略模式 主体类Subject中使用各种策略类AddStrategy、SubStrategy，按需执行策略类中的策略或更换策略。 ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：策略模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"策略类 interface Strategy { fun operation(param1: Int, param2: Int) } class AddStrategy : Strategy { override fun operation(param1: Int, param2: Int) { return param1+param2 } } class SubStrategy : Strategy { override fun operation(param1: Int, param2: Int) { return param1-param2 } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：策略模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"主体对象 class Subject( var strategy: Strategy ) { // 执行策略 fun executeStrategy(param1: Int, param2: Int) { strategy.operation(param1, param2) } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：策略模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 参数 val param1: Int = 1 val param2: Int = 2 // 策略类 val addStrategy: AddStrategy = AddStrategy() val subStrategy: SubStrategy = SubStrategy() // 主体类 val subject: Subject = Subject(addStrategy) // 执行策略 subject.executeStrategy(param1, param2) // 更换策略 subject.strategy = subStrategy // 执行新策略 subject.executeStrategy(param1, param2) } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：策略模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 空对象模式，用返回“空对象”而不是“判空”来应对“空”的情况。 空对象模式8c0402ce528d83f07ece90a9f83bcaad \" 空对象模式 工厂类SubjectFactory能够创建Subject，如果要求创建的对象的tag在工厂类的tags中，则创建实际对象RealSubject，否则创建空对象NullSubject。 ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：空对象模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"抽象对象 abstract class AbstractSubject ( var tag: String? ) { abstract fun isNull(): Boolean } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：空对象模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"实际对象 class RealSubject ( var tag: String ): AbstractSubject(tag) { override fun isNull(): Boolean { return false } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：空对象模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"空对象 class NullSubject: AbstractSubject(\"The Subject is null\") { override fun isNull(): Boolean { return true } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：空对象模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂类 class SubjectFactory( val tags: MutableList\u003cString\u003e = mutableListOf() ) { fun getSubject(tag: String) { for(item in tags) { if(tag == item) { return object : RealSubject(tag) } } return object : NullSubject() } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"行为型：空对象模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 构造工厂类 val tags = mutableListOf(\"tag1\",\"tag2\",\"tag3\") val subjectFactory: SubjectFactory = SubjectFactory(tags) // 从工厂类中获取对象 // subject1、subject2、subject3拿到RealSubject val subject1 = subjectFactory.getSubject(\"tag1\") val subject2 = subjectFactory.getSubject(\"tag2\") val subject3 = subjectFactory.getSubject(\"tag3\") // subject4拿到NullSubject val subject4 = subjectFactory.getSubject(\"tag4\") } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/:6:0","tags":["设计模式"],"title":"行为型：空对象模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 状态模式，多个状态类，将状态类传入主体类，主体类会随着状态类不同而做不同的操作。 状态模式7a40cc3bb31985e4fb6b3ef5694e112e \" 状态模式 两种状态StartState和StopState传给主体类Subject使用，主体类根据状态的不同会做不同的操作。 ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：状态模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"状态类 interface State { fun doAction(subject: Subject) } class StartState( var tag: String = \"start\" ) : State { // 将状态传给主体类 fun doAction(subject: Subject) { subject.setState(this) } } class StopState( var tag: String = \"stop\" ) : State { // 将状态传给主体类 fun doAction(subject: Subject) { subject.setState(this) } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：状态模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"主体类 class Subject( var state : State? = null ) {} ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：状态模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 状态类 val startState: StartState = StartState() val stopState: StopState = StopState() // 主体类 val subject: Subject = Subject() // 为subject设置状态为StartState startState.doAction(subject) // 输出StartState中的tag println(subject.state.tag) // 为subject设置状态为StopState stopState.doAction(subject) // 输出StopState中的tag println(subject.state.tag) } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：状态模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 观察者模式，观察者随着被观察者的变动而变动。 观察者模式a4f9fe7da950a960a35a0789754562b5 \" 观察者模式 主体类Subject有两个观察者FirstObserver和SecondObserver。当Subject更新时，两个观察者会做出相应的更新。 ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：观察者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"观察者 interface Observer { fun update() } class FirstObserver( val subject: Subject ) { fun update() { // do update } } class SecondObserver( val subject: Subject ) { fun update() { // do update } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：观察者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"主体类 class Subject( val observers: MutableList\u003cObserver\u003e = mutableListOf(), val state: Int ) { // 添加观察者 fun addObserver(observer: Observer) { this.attach(observer) } // 将观察者绑定到主体 fun attach(observer: Observer) { observers.add(observer) } // 更新Subject内容时，相应的更新观察者 fun setState(state: Int) { this.state = state notifyAllObserver() } fun notifyAllObserver() { for(observer in observers) { observer.update() } } } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：观察者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val fisrtObserver: Observer = FirstObserver() val secondObserver: Observer = SecondObserver() val subject: Subject = Subject(state = 0) // 绑定观察者 subject.addObserver(firstObserver) subject.addObserver(secondOBserver) // 主体更新，观察者也会做相应的更新操作 subject.setState(1) } ","date":"2020-08-15","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：观察者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 备忘录模式，存储对象状态，在需要时恢复。 备忘录模式b8e7c788a3bdf575c160966ffb09674a \" 备忘录模式 基础类Origin将自身的状态打包成存储类Save存储到备忘录类Recover中。必要时，从Recover中获取Save来恢复Origin。 ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：备忘录模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类 class Origin ( var state: String ) { // 将状态存入Save中，存储时用 fun saveStateToSave(): Save { return object : Save(this.state) } // 从Save中读取状态，恢复时用 fun getStateFromSave(save: Save) { state = Save.state } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：备忘录模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"存储类 data class Save( var state ) ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：备忘录模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"备忘录类 class Recover( // 存储Save的列表 val saves: MutableList\u003cSave\u003e = mutableListOf() ) { fun add(save: Save) { saves.add(save) } fun get(index: Int): Save { return saves.get(index) } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：备忘录模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val state: String = \"state\" val origin: Origin = Origin(state) val recover: Recover = Recover() // 存储状态 recover.add(origin.saveStateToSave) // 恢复状态 var index = 0 origin.getStateFromSave(recover.get(index)) } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"行为型：备忘录模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 中介者模式，在通信的两者间，增加一个中介类去处理通信问题，我们在通信时只需要维护中介类即可。 中介者模式e12e12f895f10e2d7d219550c8aedf39 \" 中介者模式 信源Source通过sendMessage发出的消息，通过调用中介类Meduim的showMessage()进行发送。 ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：中介者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"中介类 class Medium { companion object { fun showMessage(msg: String) { toShowMessage() } } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：中介者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"信源 class Source { fun sendMessage(msg: String) { // 调用中介类的方法完成通信 Medium.showMessage(msg) } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：中介者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val source: Source = Source() // 方法中会调用中介类的方法完成通信 source.sendMessage(\"Message\") } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：中介者模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 迭代器模式，迭代，即顺序访问对象集合。 迭代器模式5186f211a068baec8154b3b24b5f239c \" 迭代器模式 迭代器容器Container用于获取迭代器Iterator。 ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：迭代器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"迭代器 interface Iterator { fun hasNext(): Boolean fun next(): Object } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：迭代器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"迭代器容器 interface Container { fun getIterator(): Iterator } class UserContainer( val users: MutableList\u003cString\u003e ) { public fun getIterator(): Iterator { return object : UserIterator() } private class UserIterator( var index: Int = 0 ): Iterator { override fun hasNext() { if(index \u003c users.length) { return true } return false } override fun next(): String? { if(this.hasNext()){ return users[index++]; } return null; } } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：迭代器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 创建数据源 val users: MutableList\u003cString\u003e = mutableListOf( \"名称1\",\"名称2\" ) // 创建迭代器容器 val container: Container = UserContainer(users) // 从容器中获取迭代器 val iterator: Iterator = container.getIterator() // 迭代 for(item in 0..users.size) { if(!iterator.hasNext()) { break; } else { iterator.next() } } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：迭代器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 解释器模式，通过解释器对内容进行解释。 解释器模式034aa5120a20e4969f6be05a3e9ab3fe \" 解释器模式 表达式Expression由两个子类： 基础表达式BaseExpression 与解释器AndInterpreter 基础表达式的两个实例exp1和exp2传入与解释器，使用与解释器对interpreter()进行解释。 ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：解释器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"表达式 interface Expression { fun interpreter() } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：解释器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础表达式 class BaseExpression() : Expression { override fun interpreter(context: String) { doInterpreter(context) } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：解释器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"解释器 class AndInterpreter( var String exp1, var String exp2 ) { override fun interpreter() { // “与” exp1.interpreter()\u0026\u0026exp2.interpreter() } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：解释器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 创建基础表达式 val exp1: Expression = BaseExpression(\"string1\") val exp2: Expression = BaseExpression(\"string2\") // 创建解释器 val interpreter: AndInterpreter = AndInterpreter(exp1, exp2) // 解释 interpreter.interpreter() } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"行为型：解释器模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 命令模式，将请求封装为命令类，传给调用类，调用类寻找合适的对象执行命令。 命令模式540f04195f757b23e8f2cb4d54e2a9e1 \" 命令模式 调用类Call，使用Command命令。将BuyFood和SellFood两条命令交给Food去执行，分别调用Food中的buy()和sell()。 ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：命令模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"命令 interface Command() { fun execute() } class BuyFood(val food: Food) { fun execute() { food.buy() } } class SellFood(val food: Food) { fun execute() { food.sell() } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：命令模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"请求类 class Food { fun buy() { ... } fun sell() { ... } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：命令模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"调用类 class Call( // 创建一个命令队列 val commands: MutableList\u003cCommand\u003e = mutableListOf\u003cCommand\u003e() ) { // 向命令队列中新增命令 fun addCommand(command: Command) { list.add(command) } // 执行命令 fun executeCommand() { for(command in commands) { command.execute() } } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：命令模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 命令目标对象 val food: Food = Food() // 命令 val buyFood: BuyFood = BuyFood() val sellFood: SellFood = SellFood() // 命令调度器 val call: Call = Call() // 添加命令 call.addCommand(buyFood) call.addCommand(sellFood) // 执行命令 call.executeCommand() } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"行为型：命令模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 责任链模式，如果你无法完成这项任务，就交给下一位，直到找到能负责这项任务的人。 责任链模式c87aba7e6e835ff055787e943123758c \" 责任链模式 一份文件需要雇员Employee签署sign()，雇员分为三个层级： 基层员工Basic 经理Basic 技术总监CTO 如果这一层级的员工权限不够，则交由下一层级nextLevel。 如果基层员工的权限不够，则将文件交由经理，如果经理的权限也不够，则交给技术总监。 ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"行为型：责任链模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"雇员 open class Employee( var nextLevel: Employee?, // 下一层级的雇员 var currentAuth: Int, // 当前层级的权限 val BASIC: Int = 0x0, // 基础员工的权限 val MASTER: Int = 0x1, // 经理的权限 val CTO: Int = 0x2 // 技术总监的权限 ) { fun sign(targetAuth: Int) { // 有下一级，才继续传递 if(nextLevel != null) { if(currentAuth \u003c targetAuth) { // 全下不够，交由下一层级 nextLevel.sign(targetAuth) } else { // 权限足够则签署 doSign() } } else { // 如果没有下一级，则已经到了最高级，直接签署 doSign() } } } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"行为型：责任链模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"各层级雇员 class Basic( nextLevel: Master?, currentAuth: Employee.BASIC ) : Employee(nextLevel, currentAuth) {} class Master( nextLevel: CTO?, currentAuth: Employee.MASTER ) : Employee(nextLevel, currentAuth) {} class Master( nextLevel: null, currentAuth: Employee.CTO ) : Employee(nextLevel, currentAuth) {} ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"行为型：责任链模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 文件需要CTO签署 val targetAuth: Int = Employee.CTO // cto为最高层级 val cto: Employee = CTO() // master的下一级是cto val master: Employee = Master(cto) // basic的下一级是master val basic: Employee = Basic(basic) // basic的权限不够会传递给master，master权限不够会传递给cto，最终执行cto的sign() basic.sign(targetAuth) } ","date":"2020-08-14","objectID":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"行为型：责任链模式","uri":"/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 享元模式，“元”即某个属性，“享元”即共享属性。如果计划创建的对象有某个属性值与已存在的实例相同的话，则共享这个属性，即直接用这个实例而不是重新创建。 享元模式12980bdb503baa4f5700ec00eb5c5334 \" 享元模式 ShapeFactory创建Shape，如果计划创建的Shape的某个属性和Map\u003cShape\u003e中已经存在某个实例相同，则直接取用Map\u003cShape\u003e中的那个Shape。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：享元模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类 interface Shape { fun draw() } class Circle( var color ) : Shape { override fun draw() { drawCircle() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：享元模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂类 class ShapeFactory { private val circleMap: MutableMap\u003cString, Shape\u003e = mutableMapOf() fun getCircle(color: String) { // 查找Map中有没有相同color的Circle var circle: Circle = circleMap.get(color) as Shape // 如果没有则创建新的Circle if(circle == null) { circle = Circle(color) // 添加到Map中 circle.set(color, circle) } return circle } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：享元模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val red: String = \"Red\" val shapeFactory: ShapeFactory = ShapeFactory() // 第一次circleMap中还没有color为Red的，因此会创建 val circle1 = shapeFactory.getCircle(\"Red\") // 第二次circleMap中已经有color为Red的circle，会直接从circleMap中获取 val circle2 = shapeFactory.getCircle(\"Red\") } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：享元模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 外观模式，隐藏内部逻辑的复杂性，仅提供接口供客户端访问，这些接口就是“外观”。 外观模式ce53a2151e332a8cb18993a7dc9970a6 \" 外观模式 ShapeMaker是为客户端提供的接口，Circle和Square接入Shape。客户端通过ShapeMaker中的各种接口在ShapeMaker中创建Shape的各种实例并调用实例的方法。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类 interface Shape { fun draw() } class Circle : Shape { override fun draw() { drawCircle() } } class Square : Shape { override fun draw() { drawSquare() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接口 class ShapeMaker( // 包含的Shape类 private var circle : Circle private var square : Square ) { // 向客户端提供接口 public fun drawCircle() { circle.draw() } public fun drawSquare() { square.draw() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val circle: Circle = Circle() val square: Square = Square() val shapeMaker: ShapeMaker = ShapeMaker(circle, square) // 调用接口 shapeMaker.drawCircle() shapeMaker.drawSqaure() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 装饰器模式，在原来的基础上再加一点点。 装饰器模式eff1373ae046481f906c08ce236e9afd \" 装饰器模式 圆Circle和抽象装饰器Decorator都实现了图形Shape接口。圆Circle的draw()只能画出圆，我们可以用红色装饰器RedDecorator来为图形涂上红色：RedDecorator的draw()会在调用圆Shape的draw()的基础上再添加涂成红色的方法。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"图形 interface Shape { fun draw() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"圆 class Circle { override fun draw() { drawCircle() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"装饰器 abstract class Decorator(val shape: Shape): Shape { override fun draw() { shape.draw() } } class RedDecorator(shape: Shape): Shape(shape) { // Shape都可以 override fun draw() { shape.draw() // 调用Shape的方法来画出图形 drawRed(shape) // 把图形“装饰”成红色 } // 涂成红色 override fun drawRed() { ... } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val circle: Circle = Circle() // 被涂成红色的圆形 val redCircle: Decorator = RedDecorator(circle) redCircle.draw() // 会调用RedDecorator中的draw() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 代理模式，自己完不成的事交由另一位能完成的代理人去完成。 代理模式c19c222aa00e32333e041890b84f031e \" 代理模式 作家Write会写作write()。原作家RealWriter有一天需要请加，就请了一位代理作家ProxyWriter来完成自己当天的工作。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"父类 interface Person {} ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"原作家 class RealWriter : Person { fun write() { ... } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代理作家 class ProxyWriter : Person( // 注意引入作家 var writer: Writer ){ // 调用原作家的方法 fun write() { writer.write() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val proxyWriter: ProxyWriter = ProxyWriter() proxyWriter.writer() // 由proxyWriter代为执行，实际上执行的是RealWriter的方法 } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 组合模式，将结构相近的对象写为单一对象，并将这个对象作为树的节点类型，然后依据树形结构来构造对象。 组合模式b5768dc89a2325f5d226a85baf271b0d \" 组合模式 职员信息具有相近的结构，包括性别sex、名称name、部门dept、下级subs，可以作为单一对象。我们运用下级subs ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：组合模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单一对象 class Employee ( var sex: String var name: String var dept: String var subs: List\u003cEmployee\u003e = List\u003cEmployee\u003e() ) { fun addSub(sub: Employee) { subs.add(sub) } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：组合模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 创建雇员 val ceo: Employee = Employee( sex = \"男\", name = \"张三\", dept = \"总部\" ) val cto: Employee = Employee( sex = \"男\", name = \"李四\", dept = \"总部\" ) val cfo: Employee = Employee( sex = \"女\", name = \"王五\", dept = \"总部\" ) // 设置下级 ceo.addSub(cto) ceo.addSub(cfo) } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：组合模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 过滤器模式，运用不同标准的过滤器筛选出数据。 过滤器模式769a4d5cf4761be7e9f6a751104aad43 \" 过滤器模式 Male和Female是两个过滤器，分别用于筛选男性和女性。List\u003cPerson\u003e传入两个过滤器后，分别筛选出相应结果。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：过滤器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"过滤器 interface Filter { fun filteBySex() } class Male : Filter { override fun filteBySex(persons: List\u003cPerson\u003e): List\u003cPerson\u003e { val men: List\u003cPerson\u003e = List\u003cPerson\u003e() for(person in persons) { if(person.isMale()) { men.add(person) } else { // do Nothing } } return men } } class Female : Filter { override fun filteBySex(persons: List\u003cPerson\u003e): List\u003cPerson\u003e { val women: List\u003cPerson\u003e = List\u003cPerson\u003e() for(person in persons) { if(person.isFemale()) { women.add(person) } else { // do Nothing } } return women } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：过滤器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 初始化数据 val persons: List\u003cPersons\u003e = List\u003cPersons\u003e persons.add(object : Person(\"male\")) persons.add(object : Person(\"female\")) ... persons.add(object : Person(\"female\")) // 创建过滤器 val male: Male = Male() // 过滤 persons = Male().filteMale(persons) } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：过滤器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 桥接模式，在类的基础上，增加一个接口作为“桥”。接口的实现类和该类都可以独立变换而互不影响。 桥接模式41b8ab4c00e4fb477a9c86b18fe55eae \" 桥接模式 对于抽象类Shape，为他接入接口Drawable。Circle是抽象类Shape的实现类，Rabbit是接口Drawable的实现类。Circle和Rabbit可以互不干扰、独立实现。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"桥 interface Drawable { fun draw() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类 abstract class Shape : Drawable{ override fun draw() fun show() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"桥的实现类 class Rabbit : Drawable{ override fun draw() { drawRabbit() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类的实现类 class Circle : Shape { override fun draw() { drawCircle() } override fun show() { showCircle() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val rabbit: Rabbit = Rabbit() val circle: Circle = Circle() // rabbit实现Drawable，可以draw() rabbit.draw() // circle实现Shape，可以draw()和show() rabbit.draw() rabbit.show() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 适配器模式，实现接口兼容。为对象增加一个适配器，使得其兼容原先无法使用的内容。 适配器模式9c65ccf874a5d487704889f9147b3c1a \" 适配器模式 BasicReader只能读txt格式的文件，AdvancedReader能够读ppt格式和doc格式的文件。为了让BasicReader也能读ppt和doc，我们为其引入适配器ReaderAdapter，适配器中使用了AdvancedReader，因此BasicReader获得了读ppt和doc的能力，实现了对这两种格式的兼容。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"被兼容 interface AdvancedReader { fun readPpt() fun readDoc() } class Ppt() { override fun readPpt() { toReadPpt() } override fun readDoc() { // do Nothing } } class Doc() { override fun readPpt() { // do Nothing } override fun readDoc() { toReadDoc() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"适配器 class ReaderAdapter( val advancedReader: AdvancedReader ) { fun compatOpen(type: String) { when(type) { \"ppt\" -\u003e advancedReader.readPpt() \"doc\" -\u003e advanceReader.readDoc() } } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"兼容 interface BasicReader { fun readTxt() } class Txt(readerAdapter: ReaderAdapter) : BasicReader { override fun readTxt() { toReadTxt() } fun compatRead(type: String) { when(type) { // 如果是txt就调用自身的方法 \"txt\" -\u003e readTxt() // 如果是ppt和doc就通过适配器调用advancedReader的方法 \"doc\" -\u003e readerAdapter .advancedReader .compatOpen(type) \"ppt\" -\u003e readerAdapter .advancedReader .compatOpen(type) } } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { doc: Doc = Doc() readerAdapter: ReaderAdapter = ReaderAdapter(doc) txt: Txt = Txt(readerAdapter) // txt兼容打开doc txt.compatOpen(\"doc\") } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 原型模式，暂存一个原型，当需要创建该类的对象的时候（尤其是需要大量该类对象的时候），直接从这个原型复制一个对象出来而不是从头开始创建。 原型模式a1b59f8549bb36211a237d4f059a3141 \" 原型模式 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接入Cloneable 需要被克隆的类必须接上Cloneable，建议重写clone方法。 class Shape : Cloneable { open var name: String? = null public override fun clone(): Any? { var clone: Any? = null try { clone = super.clone() } catch (e: CloneNotSupportedException) { e.printStackTrace() } return clone } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"子类 Circle class Circle : Shape() { override var name = \"Circle\" ... } Square class Square : Shape() { override var name = \"Square\" ... } Rectangle class Rectangle : Shape() { override var name = \"Rectangle\" ... } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"存入ShapeMap 创建ShapeCache对象来存储ShapeMap class ShapeCache { private var shapeMap: MutableMap\u003cString, Shape\u003e = mutableMapOf() // 向缓存中放入Shape fun loadCache(shape: Shape) { shapeMap?.set(\"name\", shape) } fun getShape(name: String): Shape { return shapeMap.get(name) } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 创建三个对象 val circle: Circle = Circle() val square: Square = Square() val rectangle: Rectangle = Rectangle() // 创建缓存 val shapeCache: ShapeCache = ShapeCache() // 将对象存入缓存 shapeCache.loadCache(circle) shapeCache.loadCache(square) shapeCache.loadCache(rectangle) // 克隆 val circleClone: Circle = shapeCache.get(\"circle\").clone() as Circle val squareClone: Square = shapeCache.get(\"square\").clone() as Square val rectangleClone: Rectangle = shapeCache.get(\"rectangle\").clone() as Rectangle } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 单例模式，对象仅保持一个实例，并且这个实例由自己创建。通常这个实例是静态变量，创建实例的方法为静态方法。 单例模式5e817762086956cc02e9328ff6128b49 \" 单例模式 最直观的例子：数据库对象，创建费时费力，但是复用性很高。因此我们对于数据库对象可以使用单例模式，在首次获取实例时创建实例，后续获取实例则直接返回已存在的实例。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：单例模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"自我实例化 class Database() { companion object { private var instance: Database? = null fun getInstance(): Database { // 如果实例未被创建，则创建，否则直接返回已经存在的实例 if(instance == null) { instance = Database() } return instance } } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：单例模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 首次使用会创建实例 val database1 = Database.getInstance() // 再次使用直接返回已存在的实例 val database2 = Database.getInstance() } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：单例模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"建造者模式 建造者模式，如果一个对象很复杂，我们可以将其分割为各个子类，逐步构造子类，最后完成这个对象的构造，这个过程就像建筑师在建造房子时逐步添砖加瓦的过程。 建造者模式58fd5e8c21538eb3961126744d1d2caa \" 建造者模式 快餐店出售食品Food，食品的菜单是这样的： 饮料Drink 果汁Juice 可乐Cola 主食StapleFood 汉堡Burger 三明治Sandwich 配菜SideDish 鸡肉Chicken 薯条Chips 不过快餐店更希望将这些单品打包成套餐Meal进行出售，所以他们把菜单改成了这样： 套餐A 果汁Juice+汉堡Burger+鸡肉Chicken 套餐B 可乐Cola+三明治Sandwich+薯条Chips ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"套餐Meal class Meal { val drink: Drink val stapleFood: StapleFood val sideDish: SideDish } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"套餐打包器MealBuilder class MealBuilder { fun buildMealA() { val meal: Meal = Meal() meal.drink = Juice() meal.stapleFood = Burger() meal.sideDish = Chicken() return meal } fun buildMealB() { val meal: Meal = Meal() meal.drink = Cola() meal.stapleFood = Sandwich() meal.sideDish = Chips() return meal } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val mealA = MealBuilder().buildMealA() val mealB = MealBuilder().buildMealB() } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 抽象工厂模式，在工厂模式的基础上增加了一个能够生产工厂的超级工厂SuperFactory。抽象工厂AbstractFactory可以转变成模具厂ShapeFactory，也可以转变为颜料厂ColorFactory。 客户将订单交给超级工厂，超级工厂根据客户的需求，在抽象工厂的基础上建立模具厂或者颜料厂，并生产所需的产品。 抽象工厂模式9f49ba5a1c1b88338a8058978c9146da \" 抽象工厂模式 这个超级工厂可以生产ShapeFactory和ColorFactory两种工厂，这些工厂再分别去生产各自的产品。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"超级工厂 class SuperFactory { companion object { val COLOR: Int = 0x1 val SHAPE: Int = 0x2 } // 超级工厂根据type生产不同类型的工厂 fun getFactory(type: Int) { when(type) { COLOR -\u003e object : ColorFactory() SHAPE -\u003e object : ShapeFactory() } } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"抽象工厂 我们可以在抽象工厂的基础上建设模具厂或者颜料厂。 abstract class AbstractFactory { fun getShape(): Shape? fun getColor(): Color? } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"子工厂 // 变为模具厂 class ShapeFactory : AbstractFactory() { companion object { val CIRCLE = 0x0 val SQUARE = 0x1 val RECTANGLE = 0x2 } override fun getShape(type: Int): Shape? { // 与工厂模式相同，根据客户提交的type生产所需的产品 when(type) { CIRCLE -\u003e object : Circle() SQUARE -\u003e object : Square() RECTANGLE -\u003e object : Rectangle() } } // 模具厂无法生产颜料 override fun getColor(): Color? { return null } } 颜料厂同理，不赘述。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 // 生产Circle fun main() { val superFactory: SuperFactory = SuerpFactory() val circle: Circle = SuperFactory .getFactory(SuperFactory.SHAPE) .getShape(ShapeFactory.RED) } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 工厂模式，一个工厂可以生产一类产品，客户在订单中告诉工厂产品的具体要求，工厂为客户生产相应的产品。 工厂模式af6f3cd101a5ff31c42b961f3fc849e3 \" 工厂模式 这是一家生产磨具Shape的模具厂ShapeFactory，Shape包括Circle、Square、Rectangle三种形状。客户告诉模具厂自己想要的形状，模具厂就会为客户生产对应的形状。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"产品类 interface Shape {} ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:1","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"产品子类 Circle open class Circle : Shape {} Square open class Square : Shape {} Rectangle open class Rectangle : Shape {} ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:2","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂 通过参数type告诉Factory我们需要的Shape类型。 class ShapeFactory { companion object { val CIRCLE = 0x0 val SQUARE = 0x1 val RECTANGLE = 0x2 } // 传入type参数告诉工厂生产对应的Shape fun getShape(type: Int): Shape { when(type) { CIRCLE -\u003e object : Circle() SQUARE -\u003e object : Square() RECTANGLE -\u003e object : Rectangle() } } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:3","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 生产圆形模具Circle val shapeFactory: ShapeFactory = ShapeFactory() val circle: Circle = shapeFactory.getShape(ShapeFactory.CIRCLE) } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"创建型 在创建对象的同时隐藏创建逻辑。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:1:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"结构型 关注类和对象的组合。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:2:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"行为型 关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:3:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"J2EE型 关注表示层。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:4:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["Jetpack"],"content":"引言 我们在数据加载的过程中需要用到进度组件（例如加载圈、进度条）来显示加载状态。Paging为此提供了一个非常优秀的适配器LoadStateAdapter来支持这些进度组件。 代码用的是谷歌官方的Demo。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:0:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"挂载到PagingDataAdapater 我们在之前的文章中提到到PagingDataAdapater，它是用来给RecyclerView加载PaingData的。我们的LoadStateAdapter需要通过withLoadStateHeaderAndFooter挂载到PagingDataAdapater下。 mPagingDataAdapater.withLoadStateHeaderAndFooter { // 头部加载的适配器 header = mLoadStateAdapter(mPagingDataAdapater), // 底部加载的适配器 footer = mLoadStateAdapter(mPagingDataAdapater) } 我们将PagingDataAdapter传入到LoadStateAdapater中，这样LoadStateAdapter就能拿到PagingDataAdapter的状态了。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:1:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"LoadStateAdapter 然后就是适配器的常规操作，传入ViewHolder，绑定数据与视图。不过这里要注意的是： 绑定的是LoadState ViewHolder是NetworkStateItemViewHolder。这是一个自定义的ViewHolder，用于存放进度组件。 class MyLoadStateAdapter( private val adapter: PostsAdapter ) : LoadStateAdapter\u003cNetworkStateItemViewHolder\u003e() { override fun onBindViewHolder(holder: NetworkStateItemViewHolder, loadState: LoadState) { holder.bindTo(loadState) } override fun onCreateViewHolder( parent: ViewGroup, loadState: LoadState ): NetworkStateItemViewHolder { return NetworkStateItemViewHolder(parent) { adapter.retry() } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:2:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"ViewHolder 布局文件network_state_item.xml \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:padding=\"8dp\"\u003e \u003cTextView android:id=\"@+id/error_msg\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\"/\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" style=\"?android:attr/progressBarStyle\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\"/\u003e \u003cButton android:id=\"@+id/retry_button\" style=\"@style/Widget.AppCompat.Button.Colored\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"@string/retry\"/\u003e \u003c/LinearLayout\u003e ViewHolder实现 class NetworkStateItemViewHolder( parent: ViewGroup, private val retryCallback: () -\u003e Unit ) : RecyclerView.ViewHolder( LayoutInflater.from(parent.context).inflate(R.layout.network_state_item, parent, false) ) { private val binding = NetworkStateItemBinding.bind(itemView) private val progressBar = binding.progressBar private val errorMsg = binding.errorMsg private val retry = binding.retryButton .also { it.setOnClickListener { retryCallback() } } fun bindTo(loadState: LoadState) { progressBar.isVisible = loadState is Loading retry.isVisible = loadState is Error errorMsg.isVisible = !(loadState as? Error)?.error?.message.isNullOrBlank() errorMsg.text = (loadState as? Error)?.error?.message } } 我们在布局文件中放入了三个组件，分别是错误信息显示、加载圈、重试按钮。 我们在ViewHolder中的bindTo方法中，根据LoadState加载状态来改变组件的可见性从而实现加载效果。 这已经可以满足一般性的加载需求，你也可以根据自己的需要适当添加动画，来增强视觉观感。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:3:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"引言 Paging3的模型改了，主要特点是新增了中转器以实现网络数据的持久化存储。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:0:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Paging3模型 Paing数据加载的途径一：如果你希望数据实现持久化存储，你可以使用上述模型，网络与数据库的中转器RemoteMediator，将从NetworkService获取的数据写入数据库中，数据库返回PagingSource作为ViewModel的数据源。 Paing数据加载的途径二：如果你只是想从网络中加载数据而不打算持久化存储他们，你可以直接将创建PagingSource并从NetworkService将数据载入PagingSource。 下面，让我们一起来尝试一下，我将Google官方的Demo进一步简化，以方便你能快速抓住重点。 Demo的代码请点击PagingWithNetworkDemo ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:1:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"前置准备 非重点，一笔带过。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Gradle 关注Paging、Room的版本号和用kapt解析注解，可参考上一篇博文。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"NetworkService 用于获取数据，建议添加一个isFinal字段来判断是否是最后一个。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Database 数据库的三层，entity、dao、databse ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Mediator Mediator是网络与数据库之间的中介，用于将网络中的数据存储到数据库中。我们要完成两项基本工作： 准备路径参数：与api请求路径相关的参数。 确定加载行为：判断是操作是刷新（REFRESH）、向前追加（PREPEND）还是向后追加（APPEND），并据此确定接下来的数据加载行为。 从网络中获取数据：使用NetworkService，获取response，并从中拿到data。 将数据写入数据库：使用Database，获取dao，并通过dao操作将数据写入数据库。 判断是否还有后续数据 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"准备路径参数 我们根据上述提到的工作，需要传入 Databse 数据库。 NetworkService 网络服务，包含Api接口。 Query 请求路径@Path的相关参数（如果不需要也可以不传）。 我们的实体类是User，因此继承RemoteMediator\u003cInt, User\u003e。 class UserMediator( private val database: AppDatabase, private val networkService: NetworkService, private val query: String ) : RemoteMediator\u003cInt, User\u003e() { ... } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"确定加载行为 继承后，我们要实现load方法，该方法包含两个参数 LoadType 加载类型 PagingState\u003cInt, User\u003e 分页状态 并返回MediatorResult。 override suspend fun load(loadType: LoadType, state: PagingState\u003cInt, User\u003e): MediatorResult { ... } 在方法中，我们根据参数loadType来确定加载行为。 LoadType是一个枚举类 enum class LoadType { REFRESH, PREPEND, APPEND } 包含刷新REFRESH、向前追加PREPEND、向后追加APPEND三种状态。 假设我们这是一个下拉加载的列表，我们对这三种状态分别进行处理： 刷新REFRESH，即加载的方式与上一次一样，返回null即可 向前追加PREPEND，不需要上拉加载，所以返回MediatorResult.Success(endOfPaginationReached = true)来说明向前的时候已经没有更多数据了，我们上拉的时候就不会加载数据。 向后追加APPEND，一般是要加载数据的，我们根据参数state来判断一下是不是已经没有后续数据了，如果是就返回MediatorResult.Success(endOfPaginationReached = true)，不是就返回最后一条数据的id，用于后续的网络请求。 // 根据加载类型，设置加载行为的关键字 val loadKey = when (loadType) { // 刷新， LoadType.REFRESH -\u003e null // 向上加载 LoadType.PREPEND -\u003e return MediatorResult.Success(endOfPaginationReached = true) // endOfPaginationReached判读分页是否到底了，即还有没有后续数据 // 向下加载 LoadType.APPEND -\u003e { val lastItem = state.lastItemOrNull() ?: return MediatorResult.Success(endOfPaginationReached = true) lastItem.id } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"从网络中获取数据 我们分别来看我们先前三种状态处理后的关键字，在网络请求中会发生什么： // 从网络获取应答 val response = networkService.getDataByItem( query = query, after = loadKey, limit = when (loadType) { LoadType.REFRESH -\u003e state.config.initialLoadSize else -\u003e state.config.pageSize } ) 假设我们上一次请求了id为1～10号的数据 刷新REFRESH，after==loadKey==null，NetworkService中会据此判断我们需要发送原来的请求，原来请求了id为1～10的数据，现在还是请求id为1～10的数据。此外，limit会根据state中配置的条目initialLoadSize来确定加载数据的数量。 向前追加PREPEND，因为早已返回了RemoteMediator.MediatorResult.Success(endOfPaginationReached = true)，不会执行此段代码。 向后追加APPEND，after==loadKey==lastItem.id==10，NetworkService需要请求11~20号的数据。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"将数据写入数据库 操作数据库需要用到dao层，因此引入UserDao，并通过数据库的事务withTranscation来存入数据。如果是刷新，就先清空原数据，再存入新数据。 class UserMediator( private val database: AppDatabase, private val networkService: NetworkService, private val query: String ) : RemoteMediator\u003cInt, User\u003e() { private val userDao = database.getUserDao() override suspend fun load(loadType: LoadType, state: PagingState\u003cInt, User\u003e): MediatorResult { ... // 将数据写入数据库 database.withTransaction { if (loadType == LoadType.REFRESH) { userDao.clearAll() } userDao.insertAll(response.data) } ... } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:4","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"判断是否还有后续数据 在load方法中，千万不要忘记判断还有没有后续数据，毕竟load方法最后要返回MediatorResult // 根据后台给出的数据判断是否还有后续数据 MediatorResult.Success( endOfPaginationReached = response.isFinal ) ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:5","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"完整代码 // 网络与数据库之间的中转站 @OptIn(ExperimentalPagingApi::class) class UserMediator( private val database: AppDatabase, private val networkService: NetworkService, private val query: String ) : RemoteMediator\u003cInt, User\u003e() { private val userDao = database.getUserDao() override suspend fun load(loadType: LoadType, state: PagingState\u003cInt, User\u003e): MediatorResult { return try { // 根据加载类型进行不同的操作 val loadKey = when (loadType) { // 刷新 LoadType.REFRESH -\u003e null // 向上加载 LoadType.PREPEND -\u003e return MediatorResult.Success(endOfPaginationReached = true) // endOfPaginationReached判读分页是否到底了，即还有没有后续数据 // 向下加载 LoadType.APPEND -\u003e { val lastItem = state.lastItemOrNull() ?: return MediatorResult.Success(endOfPaginationReached = true) lastItem.id } } // 从网络获取应答 val response = networkService.getDataByItem( query = query, after = loadKey, limit = when (loadType) { LoadType.REFRESH -\u003e state.config.initialLoadSize else -\u003e state.config.pageSize } ) // 将数据写入数据库 database.withTransaction { if (loadType == LoadType.REFRESH) { userDao.clearAll() } userDao.insertAll(response.data) } // 根据后台给出的数据判断是否还有后续数据 MediatorResult.Success( endOfPaginationReached = response.isFinal ) } catch (e: IOException) { return MediatorResult.Error(e) } catch (e: HttpException) { return MediatorResult.Error(e) } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:6","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"PaingSource 曾经的“三人组”已被丢弃： PositionalDataSource ItemKeyedDataSource PageKeyedDataSource 已统一为： PagingSource 你可以使用PagingSource来实现“三人组”的功能。 关键在于设置prevKey和nextKey。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"ItemKeyDataSource ItemKeyDataSource继承PagingSource，通过网络请求来直接获得数据。适用于前后加载有关联的数据，例如有序的id等等。此例中就是运用data.firstOrNull()?.id和data.lastOrNull()?.id作为上下加载的关键字prevKey和nextKey。上拉加载就启用prevKey，下拉就在启用nextKey。 // ItemKey，使用条目中的关键信息进行关联查询。 // 适合一些上下有关联的，例如有序的id。 class ItemKeyUserDataSource( private val networkService: NetworkService, private val query: String ) : PagingSource\u003cString, User\u003e() { override suspend fun load(params: LoadParams\u003cString\u003e): LoadResult\u003cString, User\u003e { return try { // 从网络中获取应答 val response = networkService.getDataByItem( // 后端接口查询数据库所需的信息 query = query, // 如果是Append向后追加，就启用after，after是上一次请求的nextKey after = if (params is LoadParams.Append) params.key else null, // 如果是Prepend向前追加，就启用before，before是上一次请求的prevKey before = if (params is LoadParams.Prepend) params.key else null, // 尺寸 limit = params.loadSize ) // 从应答中获取数据 val data = response.data // 构建PageSource作为数据源 // prevKey和nextKey用于下一次加载，根据Append和Prepend来决定加载使用哪一个 LoadResult.Page( data = data, prevKey = data.firstOrNull()?.id, nextKey = data.lastOrNull()?.id ) } catch (e: IOException) { return LoadResult.Error(e) } catch (e: HttpException) { return LoadResult.Error(e) } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"PageKeyDataSource PageKeyDataSource继承PagingSource，使用页码page作为上下加载的关键字prevKey和nextKey。适合已经做好分页的数据，例如翻页书籍。 // PageKey，按页码加载。 // 适用于分页加载的场景。 class PageKeyUserDataSource( private val networkService: NetworkService, private val query: String ) : PagingSource\u003cInt, User\u003e() { override suspend fun load(params: LoadParams\u003cInt\u003e): LoadResult\u003cInt, User\u003e { return try { // 页码 val page = params.key ?: 0 // 从网络中获取应答 val response = networkService.getDataByPage( // 后端接口查询数据库所需的信息 query = query, // 如果是Append向后追加，就启用after，after是上一次请求的nextKey page = params.key, // 尺寸 limit = params.loadSize ) // 从应答中获取数据 val data = response.data // 构建PageSource作为数据源 // prevKey和nextKey用于下一次加载，根据Append和Prepend来决定加载使用哪一个 LoadResult.Page( data = data, // 如果当前页码不为0，则赋值为前一页的页码 prevKey = if (page == 0) null else page - 1, // 如果是最后一页，则下一页为空，否则赋值为下一页的页码 nextKey = if (response.isFinal) null else page + 1 ) } catch (e: IOException) { return LoadResult.Error(e) } catch (e: HttpException) { return LoadResult.Error(e) } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"PositionalKeyDataSource 你自己写吧，反正都一个套路… 核心就是设置prevKey和nextKey。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Repository 针对通过Mediator和直接对接PagingSource的数据，最终都要在Repository中转化为PageData才能供UI使用，我们在ViewModel中调用Repository中的方法来拿到PagingData。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Network+Mediator+Database 对于通过Mediator的数据，我们创建Pager对象时传入中转器和页面配置，并在lambda表达式中进行数据库查询操作，查询的结果作为数据源，最后flow成PagingData。 // 持久化存储，运用remoteMediator将数据库和网络桥接起来，从网络将数据写入数据库 fun getUsersInDb(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize), remoteMediator = UserMediator( database, networkService, query ) ) { database.getUserDao().selectAll() }.flow ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Network+PagingSource 对于直接对接PagingSource的数据，我们创建Pager时传入页面配置，并在lambda表达式中直接创建我们的数据源，最后flow成PagingData。 // 非持久化存储，直接从网络写入内存 fun getUsersInMemory(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize) ) { ItemKeyUserDataSource(networkService, query) }.flow ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"完整代码 class UserRepository(private val database: AppDatabase, private val networkService: NetworkService) { // 持久化存储，运用remoteMediator将数据库和网络桥接起来，从网络将数据写入数据库 fun getUsersInDb(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize), remoteMediator = UserMediator( database, networkService, query ) ) { database.getUserDao().selectAll() }.flow // 非持久化存储，直接从网络写入内存 fun getUsersInMemory(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize) ) { ItemKeyUserDataSource(networkService, query) }.flow } 再往上ViewModel、Adapter…反正大家都会了就不写了，不会的参考我上一篇博文。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"引言 也许你还在RecyclerView的下拉加载而烦恼，也许你还在为做分页缓存而头疼，所以，他来了——Paging分页库。 我将代码存到了gitub上，点击PagingDemo跳转。强烈建议下载代码后，再对照博文阅读。 技巧 别盯着油管上谷歌官方2018年IO大会的教程了，Paging库中的代码早已发生了翻天覆地的变化。时代变了，大人～ ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:0:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"配置 配置我使用versions的写法，请结合Demo查看，我提一下几个要点。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:1:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"注解使用kapt 请确保你使用kapt来解析注解 apply plugin: 'kotlin-kapt' dependencies { kapt deps.room.compiler } 请确保注解解释器的版本大于2.3.0 versions.room = \"2.3.0-alpha01\" 否则你的注解将无法正确解析。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:1:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Kotlin/Java编译器版本 请确保在你的Kotlin/Java版本皆指向1.8。 在module的build.gradle中 android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" freeCompilerArgs += [\"-Xopt-in=kotlin.RequiresOptIn\"] } } 注意 如果你注意以上两点，那么你的程序基本不会因为配置的原因原地爆炸。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:1:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"数据库 数据库包含实体层（Table）、Dao层（SQL）、数据库层（Scheme）。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Entity 为类打上@Entity注解，为主键id打上@PrimaryKey注解并标明自增。 @Entity data class User( @PrimaryKey(autoGenerate = true) val id: Int, val name: String ) ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Dao 定义了三个方法 allUsers查询，我们的终极目的就是查出来 insert插入，后面用于填入模拟数据 deleteAll删除，会清空数据库中所有的数据 重点： 我们的allUsers()返回PagingSource\u003cK, V\u003e @Dao interface UserDao { @Query(\"SELECT * FROM User\") fun allUsers(): PagingSource\u003cInt, User\u003e @Insert fun insert(users: List\u003cUser\u003e) @Query(\"DELETE FROM User\") fun deleteAll() } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Database 为类打上Database注解并指明包含的类和数据库版本，引入了dao层，并且通过静态方法创建静态实例。 技巧 建议大家学会这种方法，不要再在Repositories层或者viewModel层build数据库了，太杂了。 @Database(entities = [User::class], version = 1) abstract class UserDatabase : RoomDatabase() { abstract fun userDao(): UserDao companion object { private var instance: UserDatabase? = null /** * 提供互斥的静态方法用于获取数据库实例 * 如果实例没创建，则创建；已经创建了，直接返回实例 * 减少了创建实例所花费的开销 */ @Synchronized fun get(context: Context): UserDatabase { if (instance == null) { instance = Room.databaseBuilder( context.applicationContext, UserDatabase::class.java, \"UserDatabase\" ).build() } return instance!! } } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"适配器 适配器完成三件事 Layout ViewHolder Adapter ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"layout 为Activity和RecyclerView的item分别建立布局。 Activity 注意RecyclerView要指定layoutManager \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".activity.MainActivity\"\u003e \u003candroidx.recyclerview.widget.RecyclerView android:id=\"@+id/recyclerview\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layoutManager=\"LinearLayoutManager\"/\u003e \u003cButton android:id=\"@+id/delete\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e RecycleView的item 两个文本控件，分别用于显示User的id和name。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"\u003e \u003cTextView android:id=\"@+id/item_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"TextView\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cTextView android:id=\"@+id/item_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"TextView\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/item_id\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"ViewHolder 根据我们创建的item布局和User实体类，我们写一个ViewHolder class UserViewHolder(parent: ViewGroup): RecyclerView.ViewHolder( LayoutInflater.from(parent.context).inflate(R.layout.item, parent, false) ) { // 控件 private val idView = itemView.item_id private val nameView = itemView.item_name // 数据 private var user: User? = null // 用于数据与控件的绑定 fun bindTo(user : User?) { this.user = user idView.text = user?.id.toString() nameView.text = user?.name } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Adapter 重点： 继承了PagingDataAdapter\u003cObject, ViewHolder\u003e diffCallback的判断，建议采用这种变量写法会比较清晰（Kotlin的特性不用白不用） /** * 继承PagingDataAdapter */ class UserAdapter : PagingDataAdapter\u003cUser, UserViewHolder\u003e(diffCallback) { // diffCallback用内部定义的变量 override fun onBindViewHolder(holder: UserViewHolder, position: Int) { // 数据绑定：传入条目的位置信息，将数据绑定到这个位置的条目上 holder.bindTo(getItem(position)) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder { // 布局创建：传入父布局，在父布局中创建布局 return UserViewHolder(parent) } companion object { // 同异判断：分别用于判断条目是否更新和内容是否更新 private val diffCallback = object : DiffUtil.ItemCallback\u003cUser\u003e() { override fun areItemsTheSame(oldItem: User, newItem: User): Boolean { return oldItem.id == newItem.id } override fun areContentsTheSame(oldItem: User, newItem: User): Boolean { return oldItem == newItem } } } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"活动 活动需要完成 ViewModel Activity ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:4:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"ViewModel 重点： 我们的数据由Pager对象构建，PagingConfig作为参数传入，方法体中执行数据库查询操作，最后flow来获得Flow\u003cPagingData\u003cValue\u003e\u003e对象，最终将其赋值给allUsers。 我定义了两个挂起方法和一组模拟数据，我将在Activity中的Kotlin协程中使用它们。 你发现我的模拟数据由id，但是上面的数据库中又指明id是自增的，这很矛盾。其实模拟数据的id只是我用来方便创建对象用的，真正的id由数据库生成，我们最终数据呈现所使用的id也是数据库中的id。但我这样做希望提醒你一点：我在insertAll的map中设置id=0，那么就会启用自增，数据库中的id，与你创建对象的id属性无关。 class MainViewModel(app: Application): AndroidViewModel(app) { private val dao = UserDatabase.get(app).userDao() // 模拟数据，用于填充数据库 private val USER_DATA = arrayListOf\u003cUser\u003e( User(1, \"Name1\"), User(2, \"Name2\"), User(3, \"Name3\"), User(4, \"Name4\"), User(5, \"Name5\") ) /** * 通过Pager的构造方法中的config参数配置分页的参数 * 通过Pager的方法体传入数据 */ val allUsers = Pager( PagingConfig( pageSize = 5, enablePlaceholders = true ) ) { dao.allUsers() }.flow // 删除所有数据 suspend fun deleteAll() { withContext(Dispatchers.IO) { dao.deleteAll() } } // 填充模拟数据 suspend fun insertAll(context: Context) { withContext(Dispatchers.IO) { UserDatabase.get(context.applicationContext).userDao() .insert( USER_DATA.map { User(id = 0, name = it.name) } ) } } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:4:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Activity 重点： 在协程中，你需要adapter.submitData(it)来将数据传递给适配器。 lass MainActivity : AppCompatActivity() { private val viewModel by viewModels\u003cMainViewModel\u003e() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val adapter = UserAdapter() recyclerview.adapter = adapter lifecycleScope.launch { // 插入所有模拟数据 viewModel.insertAll(application) // 更新适配器数据 @OptIn(ExperimentalCoroutinesApi::class) viewModel.allUsers.collectLatest { adapter.submitData(it) } } // 绑定删除数据事件 delete.setOnClickListener { lifecycleScope.launch(Dispatchers.IO) { viewModel.deleteAll() } } } } 总结 这只是一个很基础的Demo。我们平时的开发场景，更多是结合通过网络来进行分页处理。在下一篇博文中，我将陈述如何操作。 我建议你更多的参考Google在Github上留下的Demo。虽然有些写法并不好，但核心的东西都会表达出来，不要再依赖过时的视频来进行学习。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:4:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Gradle"],"content":"引言 你有没有很奇怪，我们的远程引入的依赖库为什么只需要写入源即可？难道还有不需要网络协议就能获取到的资源？怎么可能。那么协议写到了哪里？写到仓库中。位置在project的build.gradle中 buildscript { repositories { // 编译工具用到的仓库 } } allprojects { // 所有项目都用到的仓库 } ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:0:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"google()与jcenter() 当我们创建新项目时，就会看到这样的代码 buildscript { repositories { google() jcenter() } } allprojects { repositories { google() jcenter() } } 通过上述代码引入和google和jcenter的仓库，然后我们填写依赖的源的时候，会根据源自动在这些仓库中搜索合适的库进行引入。 我们打开上述两个方法会发现 public interface RepositoryHandler extends ArtifactRepositoryContainer { MavenArtifactRepository google(); MavenArtifactRepository jcenter(); } 而MavenArtifactRepository中包含对URI的操作 URI getUrl(); void setUrl(URI url); Set\u003cURI\u003e getArtifactUrls(); ... 正是通过这些方法从互联网上获取到远程仓库。 ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:1:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"自定义仓库 你还可以通过maven添加新的仓库 buildscript { repositories { maven { url \"http://repo.mycompany.com/maven2\" } } } ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:2:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"多模块下的仓库管理 我们之前提到过使用versions来管理版本，也可以用它来管理仓库。 在project下新建version.gradle 在versions.gradle中（注意调用方法时，使用符号\u0026） def addRepos(RepositoryHandler handler) { handler.google() handler.jcenter() handler.maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } ext.addRepos = this.\u0026addRepos 在project的build.gradle中 buildscript { // 引入versions.gradle apply from: \"versions.gradle\" // 添加仓库 addRepos(repositories) } allprojects { // 添加仓库 addRepos(repositories) } ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:3:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"引言 很多同学写了Android很久，对于依赖库的引入却是傻傻分不清。因为Gradle随着版本的升级，语义在不断的变化，从compile到implementation，从apt到annotationProcessor…已经绕晕了不少人，今天就来明确下依赖最最基础的依赖库的用法。 注意 很少有关注gradle的变化，认为gradle区区配置不重要，但是对于大规模项目而言，gradle是整个项目的骨架，极为重要。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:0:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"Gradle依赖 Gradle并非孤例运行，他自身也会依赖于一些插件，在project的build.gradle中，使用classpath引入 classpath \"lib-gradle\" ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:1:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"开发依赖库 正式运行时使用的依赖库，对应我们的开发目录。 在module的build.gradle中，使用implementation引入 dependencies { implementation “lib-source” } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:2:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"测试依赖库 测试程序时使用的依赖库，对应androidTest目录。 在module的build.gradle中，使用androidTestImplementation引入 dependencies { androidTestImplementation \"lib-source\" } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:3:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"测试工具依赖库 在module的build.gradle中，使用testImplementation引入 dependencies { testImplementation \"test-tool-source\" } 例如junit的库。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:4:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"本地依赖库 如果是本地依赖库，则需要将依赖库放入module的libs文件夹中，在module的build.gradle中，用fileTree引入 dependencies { // 从文件夹libs中引入后缀为jar文件作为依赖库 implementation fileTree(dir: \"libs\", include: [\"*.jar\"]) } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:5:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"注释处理器 带有注解的代码会通过注释处理器**APT（Annotation Processing Tool）**进行转换，变成不带注解的代码（注解往往都是控制反转用的，我们的虚拟机可运行不了带注解的代码）。对于kotlin和java有不同的配置方式。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:6:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"kotlin 在project的build.gradle中配置 apply plugin: 'kotlin-kapt' kapt { arguments { arg(\"AROUTER_MODULE_NAME\", project.getName()) } } 在module的build.gradle中，先引入kotlin-kapt插件，再通过kapt引入 apply plugin: 'kotlin-kapt' dependencies { kapt \"apt-source\" } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:6:1","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"java 在project的build.gradle中配置 android { defaultConfig { javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } } 在module的build.gradle中，使用annotationProcessor引入 dependencies { annotationProcessor \"apt-source\" } annotationProcessor同时支持javac和jack两种编译方式。 注意 如果你的某个模块是Java和Kotlin混合开发，那么两者都要写上，他们会分别处理.java和.kt文件。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:6:2","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"引言 如果我们的project中有许多module，那么每个module下就会有一个build.gradle用于管理该module的依赖库。多模块对于开发人员的意义就是可以分块开发进而提升效率，但这也意味着沟通成本的提高和冗余工作的增加。 版本无法统一管理 甲引入了moduleA的1.0.0版本，乙在moduleB引入了1.0.1版本，如果需要甲乙统一版本，那就需要确保他们有效沟通。那如果再有丙在moduleC引入了1.0.2版本，丁在moduleD引入了1.0.3版本…每次改个依赖库的版本都是一次群体大会，一个人没统一，代码可能就会由于版本不统一出现问题。 人人研究配置 作为一位Android工程师，研究配置没有错，但是如果每个人每天都在折腾这些版本号，其他活就不用干了。 工作重心不当 你说不怕，我们有全局的build.gradle可以解决这个问题，但是想想，我们传统的一行implementation 'xxx'虽然引入很方便，但是可读性极差。我们对于配置的主要工作不在引入工作，而是版本管理工作，因此我们需要使用一种新的写法来解决版本管理。 注意 针对以上问题，我们引入了version版本控制的写法。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:1:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"创建版本管理文件 在project根目录下创建versions.grale文件，并在project的build.grale中引入 buildscript { apply from: 'versions.gradle' } 这样,versions.gradle就在整个工程中生效了，接下来我们来编写versions.gradle。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:2:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"声明额外属性 我们在Gradle中声明额外属性需要用到ext ext { deps versions } 或 ext.deps = [:] // [:]相当于null ext.version = [:] 上述代码就声明两个额外属性deps和verisons。如果我们定义了这些属性，那么就可以在后续的代码中使用这些属性。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:3:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"依赖版本 在version.gradle中， 阅读过程中注意首尾呼应，区分变量和额外属性。 // 声明额外属性deps，用于存放依赖的信息 ext.deps = [:] // 声明版本变量 def versions = [:] // 版本变量中为各种依赖库创建字段，并赋值版本号 versions.activity = '1.1.0' versions.android_gradle_plugin = '4.0.0' versions.annotations = \"1.0.0\" // 完成版本变量中全部版本号的定义后，将版本变量存入额外属性versions中 ext.versions = versions // 声明依赖库变量 def deps = [:] // 声明activity库变量 def activity = [:] // 为activity库变量的activity_ktx字段赋值来源信息，其中的$version.activity会引入我们上面定义的version.activity activity.activity_ktx = \"androidx.activity:activity-ktx:$versions.activity\" // 将activity库来源信息存入deps的activity字段中 deps.activity = activity // 将android_gralde_plugin库来源信息赋值到deps的字段android_gradle_plugin字段中 deps.android_gradle_plugin = \"com.android.tools.build:gradle:$versions.android_gradle_plugin\" // 将annotations库来源信息赋值到deps的字段nnotations字段中 deps.annotations = \"androidx.annotation:annotation:$versions.annotations\" // 完成所有依赖库中所有依赖的定义后，将依赖变量存入额外属性deps ext.deps = deps 像一些父库（例如activity）都会有各种子库（例如activity.activity_ktx），我们可以采用上述代码中activity的定义方式声明，先定义父库的变量，再在父库中添加子库的字段，最后把父库的变量存入deps。 而一些单一的库（例如android_gradle_plugin、annotations）则可直接赋值到字段中。 定义完后，我们就可以直接在工程中的全局build.gradle和module的build.gradle中使用存入deps中的字段来决定引入的依赖库而不需要纠结版本问题。 implementation deps.activity.activity_ktx implementation deps.android_gradle_plugin implementation deps.annotations 通过这种方式，团队中只需要指定一个人管理库版本即可，其他人仅负责引入。 诶？既然可以用来搞定依赖的版本，是不是也可以用这种方式控制其他版本呢？一个个文件找多累啊！没错，你的直觉是对的。我们还可以用这种方式控制build版本、Java版本。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:4:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"build版本 在versions.gradle中 def build_versions = [:] build_versions.min_sdk = 14 build_versions.compile_sdk = 29 build_versions.target_sdk = 29 build_versions.build_tools = \"29.0.3\" ext.build_versions = build_versions 在module的build.gralde中 android { compileSdkVersion build_versions.compile_sdk buildToolsVersion build_versions.build_tools defaultConfig { minSdkVersion build_versions.min_sdk targetSdkVersion build_versions.target_sdk } ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:5:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"Java版本 在versions.gradle中 def java_version = [:] java_version.source = JavaVersion.VERSION_1_8 java_version.target = JavaVersion.VERSION_1_8 ext.java_version = java_version 在module的build.gralde中 android { compileOptions { sourceCompatibility java_version.source targetCompatibility java_version.target } } ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:6:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Jetpack"],"content":"场景问题 我们在Android开发中会遇到这样一种场景： class MainActivity: AppCompatActivity() { private val component1: Component1 = Component1() private val component1: Component2 = Component2() override fun onCreate(...) { component1.create() component2.create() component3.create() } override fun onStart(...) { component1.start() component2.start() component3.start() } override fun onResume(...) { component1.resume() component2.resume() component3.resume() } override fun onPause(...) { component1.pause() component2.pause() component3.pause() } override fun onStop(...) { component1.stop() component2.stop() component3.stop() } override fun onDistory(...) { component1.distory() component2.distory() component3.distory() } } class Component1 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } class Component2 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } class Component3 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } 组件的特定方法要在特定的生命周期进行调用，如果存在多个这样的组件，则生命周期方法中的代码就会非常冗杂。因此，Android对此进行控制反转，引入了生命周期感应型组件，通过绑定LifecyclerObserver和LifecyclerOwner来解决此类问题。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:1:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecyclerOwner 带有生命周期的组件，例如Activity、Fragment，都持有lifecycleOwner。 不过lifecycleOwner是一个接口，他的表示类为lifecycle，你可以在组件的生命周期方法中获得lifecycle。 以Activity为例，他有 onCreate() onStart() onResume() onPause() onStop() onDistory() 六大生命周期。我们可以通过getLifecycle()在这些生命周期方法中获得lifecycle。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner onCreate() { mLifecycleOwner = lifecycle // 在kotlin中直接写lifecycle即表示getLifecycler() } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:2:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifeObserver 拿到LifecycleOwner后，我们获取他的LifeCycle为其添加观察者LifecycleObserver： mLifecycleOwner.getLifecycle().addObserver(mLifecycleObserver) 观察者中的会随着mLifecycleOwner生命周期的变化而执行不同的方法。观察者是怎样做到这一点的呢？ 实现LifecycleObserver接口 添加生命周期注解 MyObserver: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } 每当mLifecycleOwner进入某一生命周期时，都会触发mLifecycleObserver中带对应的@OnLifecycleEvent(Lifecycle.Event.xxx)注解的函数。例如，当mLifecycleOwner进入onCreate()时，mLifecycleObserver会执行带有@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)注解的方法。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:3:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"代码总结 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"完整代码 我们把代码完整地写一遍： MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { // 获取MainActivity的lifecycleOwner mLifecycleOwner = lifecycle // 初始化lifecycleObserver mLifecycleObserver = MyObserver1() // 绑定两者 mLifecycleOwner.addObserver(mLifecycleObserver) // 再来一遍 mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver2() mLifecycleOwner.addObserver(mLifecycleObserver) // 再来一遍 mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver3() mLifecycleOwner.addObserver(mLifecycleObserver) } } MyObserver1: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } MyObserver2: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } MyObserver3: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } 这样，我们将原来的每个生命周期填写对应的方法的多次操作转化为一次性的绑定操作。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:1","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"进一步优化 对于多个响应生命周期的组件，虽然我们通过上述方法避免了在每一个周期都写一次方法，但我们在一个周期内仍然要写很多重复的绑定操作，因此我们可以进一步优化，将绑定操作封装为函数lifecycleBind。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { lifecycleBind(lifecycle, MyObserver1()) lifecycleBind(lifecycle, MyObserver2()) lifecycleBind(lifecycle, MyObserver3()) ... } } class Util { companion object { fun lifecycleBind( mLifecycleOwner: LifecycleOwner, mLifecycleObserver: LifecycleObserver ) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:2","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"再进一步优化 我们解决了重复操作，但是仍然有一个问题，那就是要执行多个封装好的绑定函数。如果有99个组件，我就要写99行这样的代码。 我们发现在一个生命周期组件的绑定中，LifecycleOwner是固定的，而LifecycleObserver是不固定的。因此，我们可以建立LifecycleObserver数组，进行遍历操作。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner onCreate() { // 一次获取LifecycleOwner val mLifecycleOwner = lifecycle // 建立LifecycleObserver数组 val observers = listof( MyObserver1(), MyObserver2(), MyObserver3() ) // 遍历绑定 for(item in observers) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } class Util { companion object { fun lifecycleBind( mLifecycleOwner: LifecycleOwner, mLifecycleObserver: LifecycleObserver ) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:3","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"状态检查 有时候我们需要检查当前的生命周期状态，以进行特定的操作。例如，你可能会在Pause状态更新一个UI的状态，然后在Resume状态再一次更新他。生命周期感知型组件对此引入了状态检查。 传入lifecycle 检查lifecycle的状态 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver(mLifecycleOwner) mLifecycleOwner.addObserver(mLifecycleObserver) } onResume() { // 检查状态并执行操作 mLifecycleObserver.check() } } class MyObserver: LifecycleObserver( private val lifecycle: Lifecycle ) { fun check() { if(lifecycle.currentState.isAtLeast(Lifecycle.State.RESUMED) { // todo } } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:5:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"Event与State 生命周期中有两个枚举类，分别指向生命周期的事件和状态。 Event源码： public enum Event { ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY } State源码： public enum State { DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; public boolean isAtLeast(@NonNull State state) { return compareTo(state) \u003e= 0; } } 我们在之前的代码中都用过了，Event用作事件注解，State用作状态检查。大家可以结合图例整体把握一下。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:6:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"源码分析 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"getLifecycle() 我们分别来看Activity和Fragment的getLifecycle() // ComponentActivity.java public Lifecycle getLifecycle() { return mLifecycleRegistry; } // Fragment.java public Lifecycle getLifecycle() { return mLifecycleRegistry; } 我们发现两者都返回了mLifecycleRegistry，这是什么呢？ // ComponentActivity.java private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); // Fragment.java LifecycleRegistry mLifecycleRegistry; private void initLifecycle() { mLifecycleRegistry = new LifecycleRegistry(this); mSavedStateRegistryController = SavedStateRegistryController.create(this); if (Build.VERSION.SDK_INT \u003e= 19) { mLifecycleRegistry.addObserver(new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (event == Lifecycle.Event.ON_STOP) { if (mView != null) { mView.cancelPendingInputEvents(); } } } }); } } Build.VERSION.SDK_INT \u003e= 19可见对于Fragemnt的Lifecycle的操作，只有SDK\u003e=19才会启用。 mLifecycleRegistry是LifecycleRegistry的实例。 public class LifecycleRegistry extends Lifecycle { ... } public abstract class Lifecycle { ... } 而Lifecycle是一个抽象类，LifecycleRegistry是Lifecycle的表现类。 由此可见，LifecycleRegistry表现了Lifecycle，而Fragment和Activity中获取到的Lifecycle都是LifecycleRegistry。但Lifecycle本身仅提供了Event和State的枚举类，对于Lifecycle主要的操作方法都在LifecycleRegistry中。当我们需要使用对Lifecycle的操作时，可以查看LifecycleRegistry寻找合适的方法。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:1","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecycleOwner LifecycleOwner只是一个接口，仅提供了getLifecycle()： public interface LifecycleOwner { @NonNull Lifecycle getLifecycle(); } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:2","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecycleObserver LifecycleObserver更狠，一无所有： public interface LifecycleObserver { } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:3","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"代码去哪儿啦？ 你可能会很疑惑，代码去哪儿了？还记得刚才的LifecycleRegistry，没错，其实所有的逻辑代码都在这里。 查看addObserver()方法 // LifecycleRegistry @Override public void addObserver(@NonNull LifecycleObserver observer) { State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); } 然后我们通过addObserver()找到ObserverWithState： // LifecycleRegistry static class ObserverWithState { State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) { mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; } } 我们看到了LifecycleEventObserver，打开源码： // LifecycleEventObserver public interface LifecycleEventObserver extends LifecycleObserver { void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event); } 破案了，观察者LifecycleObserver通过Lifecycling.lifecycleEventObserver()获得LifecycleEventObserver实例，与状态State通过ObserverWithState捆绑实现了生命周期感知的主要逻辑。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:4","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"逻辑图谱 奉上最后的逻辑图谱供读者参考。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:8:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Kotlin"],"content":"引言 Coroutine，一个线程框架，是建立在线程之上的API，用于让代码在各个线程之间反复横跳。 你只需要理解三个概念，就能理解协程： 调度器 挂起 并发 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:1:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"创建协程 协程创建格式 [CoroutineScope].[shift]([DisaptcherName]) { // 包内的代码称为协程 } CoroutineScope协程作用域 LaunchWay运行方式 DisaptcherName调度器名 首先，我们来创建一个协程 // Here are CurrentThread CoroutineScope.lanuch(Dispatchers.Main) { println(\"Hello! Coroutine\") } 注意， { println(\"Hello! Coroutine\") } 叫做协程，前面的CoroutineScope.lanuch(Dispatchers.Default)对协程而言，都只的参数。 这段代码做了什么呢？接下来这段话，请慢慢细读。 CorutineScope.launch是在CurrentThread里的执行的，它会让CurrentThread中开出一个新的协程 { println(\"Hello! Coroutine\") } 然后让调度器Dispatchers把这个协程调度到协程上下文Main所指代的线程中运行（Main指代主线程）。 这就提到我们第一个关键——调度器。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:2:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"调度器 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"原理 协程调度器名有： Dispatchers.Default Dispatchers.Main Dispatchers.IO Dispactchers.Unconfined 分别对应协程调度器： DefaultDisaptcher MainDispatcher IODispatcher UnconfinedDispatcher 分别调度到线程： BackgroundThread 适合CPU密集型。 MainThread 适合更新UI。 IOThread 适合I/O与网络请求。 CurrentThread 诶？你既然在当前线程了，直接写到当前线程下，不就好了吗？调度不是多此一举吗？注意，通过UnconfinedDispatcher调度过来的协程任务与普通的任务都区别在于，调度过来的任务会立即执行，且阻塞当前线程，只有调度过来的协程代码运行完，当前线程才会继续执行后续代码。 如图所示，我们在当前进程CurrentThread开出了多个协程Corotine，那么我们可以通过指定各个调度器名来指定使用对应的调度器，不同的调度器把协程调度到不同的线程上执行。 协程Coroutine1指定调度器名Dispatchers.Default，从而使用调度器DefaultDisaptcher将协程调度到BackgroundThread。 协程Coroutine2指定调度器名Dispatchers.Main，从而使用MainDispatcher将协程调度到MainThread。 协程Coroutine3指定调度器名Dispatchers.IO，从而使用IODispatcher将协程调度到IOThread。 协程Coroutine4指定调度器名Dispactchers.Unconfined，从而指定使用调度器UnconfinedDispatcher将协程调度到CurrentThread。 写成代码就是这样： // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { // Coroutine1 } CoroutineScope.lanuch(Disaptcher.Main) { // Coroutine2 } CoroutineScope.lanuch(Disaptcher.IO) { // Coroutine3 } CoroutineScope.lanuch(Disaptcher.Unconfined) { // Coroutine4 } ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"默认调度器 如果我们不写调度器， // Here are CurrentThread CoroutineScope.launch { // 第一处 CoroutineScope.launch { // 第二处 ... } } 就会默认使用父协程的调度器，第一处会被调度到当前线程，第二处会使用继承第一处，也被调度到当前线程。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"协程与线程 协程的运行方式分为两种： 非阻塞式——使用launch，不会卡住协程运行的线程。 阻塞式——使用runBlocking，会阻塞协程运行的线程。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"非阻塞式 在理解了调度器之后，我们来对比两段代码 不使用协程： // Here are CurrentThread task1() task2() task3() other() 使用协程： // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() task2() task3() } other() 后者的代码执行过程如图所示，通过CoroutineScope.launch(Disaptcher.Default)将协程 { task1() task2() task3() } 切换到BackgroundThread执行，当前线程该干嘛就干嘛，继续执行other()，与协程内容互不相关。 划重点：在协程被调度器调度到其他线程之后，协程就完全脱离当前线程，两者互不相关。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"阻塞式 阻塞式使用runBlocking来运行协程代码 CoroutineScope.launch(Disaptcher.Default) { runBlocking { task1() } task2() task3() } other() 他是用来霸占线程的，当我们运行上述代码，协程被运送到BackgroundThread，这里的runBlocking没有指定调度器，因此继承了父协程的上下文，也被调度到了BackgroundThread（联系上文默认调度器），那么runBlocking马上就像强盗一样霸占了BackgroundThread直到自己的协程 { task1() } 完成，BackgroundThread才能执行其他代码。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"分发到不同线程的执行顺序 刚才的代码，三个task都在同一个线程中运行，如果我想把他们放到不同的线程中运行呢？例如： task1()交给DefaultDisaptcher分发到BackgroundThread去执行。 task2()交给IODisaptcher分发到IOThread去执行。 task3()交给MainDisaptcher分发到MainThread去执行。 第一种写法 你可能首先想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() } CoroutineScope.lanuch(Disaptcher.IO){ task2() } CoroutineScope.lanuch(Disaptcher.Main){ task3() } 它的执行顺序是这样的 第二种写法 你可能会想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() CoroutineScope.lanuch(Disaptcher.IO){ task2() CoroutineScope.lanuch(Disaptcher.Main){ task3() } } } other() 它的执行顺序是这样的 第三种写法 你也可能想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() CoroutineScope.lanuch(Disaptcher.IO){ task2() } CoroutineScope.lanuch(Disaptcher.Main){ task3() } } other() 它的执行顺序是这样的 第四种写法（推荐） 使用withContext，顾名思义，根据当前的协程上下文来运行。例如： CoroutineScope.launch(Disaptcher.Default) { task1() withContext(Disaptcher.IO) { task2() } withContext(Disaptcher.Main) { task3() } } 上述代码的协程上下文为CoroutineScope，则其中的withContext相当于CoroutineScope.launch。 那是不是最外层也使用？像下述代码这样？ // Here are CurrentThread withContext(Disaptcher.Default) { withContext(...) { ... } } 答：无法使用。 我们刚才说了，根据当前协程上下文来运行，写在最外层，没有协程上下文，因此无法使用。 结论：withContext只能在协程中使用。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:3","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"挂起 { // Here are CurrentThread CoroutineScope.launch(Dispatchers.Default) { task1() task2() task3() task4() } other() } fun task1() { println(\"task1\") } suspend fun task2() { withContext(Dispatchers.IO) { println(\"task2\") } } suspend fun task3() { withContext(Dispatchers.Main) { println(\"task3\") } } fun task4() { println(\"task4\") } 首先，你想象自己拿着四封任务函，当前线程就是你的Boss。Boss只知道，首先去Disaptcher.Default窗口找BackgroundThread。于是指示你说：“去Disaptcher.Default窗口找BackgroundThread办理吧”。然后Boss就去处理other()任务，你则去处理这四封任务函。 我们到了Disaptcher.Default窗口排队，BackgroundThread看了看task1()，确认是自己的业务，就办完了并给task1()盖上终章。 但是task2()标明了suspend，表明要换一个窗口，但你并不知道要换哪一个，然后BackgroundThread拆开任务函，看到写着Disaptcher.IO，告诉你到Disaptcher.IO找IOThread办理，临走时他千叮咛万嘱咐，办理完了记得一定要回来找他，每张任务单都最后都需要第一个经手的业务人员盖章。你连连点头。 于是你暂时离开了BackgroundThread，BackgroundThread继续处理排在你后面的人的业务。而你又来到Disaptcher.IO窗口排队，IOThread看到task2()确实是自己的业务，就完成了，你赶紧回到了Disaptcher.Default找BackgroundThread，不过要重新排队。 终于轮到你了，BackgroundThread给task2()盖上终章，然后看了看你下一张任务单task3()标记着suspend，没错，又需要换个窗口，他又拆开任务函，看到写着Disaptcher.Main。他又指示你去Disaptcher.Main窗口找MainThread。临走前，他又嘱咐你办完后一定要回来。于是你又到Disaptcher.Main窗口找MainThread，MainThread完成了task3()。你赶紧回到了Disaptcher.Default窗口找BackgroundThread，不过又要重新排队。 终于轮到你了，BackgroundThread给task3()盖上终章，最后一个任务task4()没有suspend，BackgroundThread完成了task4()，并给task4()盖上了终章。 你的所有任务终于完成了！ 这个过程如下 你每次离开BakcgroundThread都过程就叫挂起Suspend，也就是暂时离开，BakcgroundThread在你离开的期间会处理其他任务，而你办完事儿后要回到BakcgroundThread那里，这个回来的过程叫做恢复Resume。 相信学完挂起，你已经发现了协程存在的意义，他让本应通过各种“异步+回调”完成的代码用同步的方式写出来。 例如 requestName.callback { requestImage.callback { setInfo.callbakc{ ... } } } 这种回调地狱在协程中用同步的方式写出来，每一行可以看作是上一行的回调： CoroutineScope.launch { requestName() requestImage() setInfo() } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo() { withContext(Dispatchers.Main) { ... } } 而可以这么爽的原因，就是因为挂起和恢复。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:5:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"并发 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"async 再仔细看看上面那一段代码，有同学可能要问了，这个requestName()和requestImage()如果没有依赖关系，也可以并发进行呀！没错，协程也为各项任务提供了并发机制。 我们可以使用async来让协程并发工作。 CoroutineScope.launch { async { requestName() } async { requestImage() } setInfo() } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo() { withContext(Dispatchers.Main) { ... } } 通过上述修改，requestName()和requestImage()就能并发工作了，两个并发任务启动（注意，不是执行完毕，是启动），立刻会执行setInfo()。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"await 有同学又要问了，万一你的setInfo()依赖requestName()和requestImage()的结果，那不会有问题了吗？ 没错，所以这就需要我们的await()登场了。 CoroutineScope.launch { val result1 = async { requestName() } val result2 = async { requestImage() } setInfo(result1.await(), result2.await()) } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo(String name, String img) { withContext(Dispatchers.Main) { ... } } 我们为任务的执行结果添加上await()，协程就会等待并发任务执行完毕，再继续运行后续代码。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"惰性并发 有时候我们可能并不希望我们的并发任务立刻执行，那么我们就需要运用惰性并发。 CoroutineScope.launch { val result1 = async(start = CoroutineStart.LAZY) { requestName() } val result2 = async(start = CoroutineStart.LAZY) { requestImage() } result1.await() // await()启动 result2.start() // start()启动 setInfo(result1, rsult2) } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo(String name, String img) { withContext(Dispatchers.Main) { ... } } 我们通过async (start = CoroutineStart.LAZY)将任务变为惰性并发任务，惰性并发任务不会立刻运行，而是在两种情况下运行： result被await()，即其他任务需要他的结果时。 result被start()，即我们手动启动它时。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:3","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Android Framework"],"content":"Module创建 使用Android Studio中的File\u003eNew\u003eNew Module创建Module Module类型 常用Module类型： Application Library Dynamic Delivery Instant Dynamic Delivery Application为主模块，我们需要将Library和Dynamic Delivery引入Application。 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:0:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"Aplication Application为主模块，是应用运行的入口模块，其他的模块被引入Application发挥作用。 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:1:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"Library Library是普通的子模块，是任何情况下，都会打包进入Application的库，。 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:2:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"Dynamic Delivery Dynamic Delivery是按需引入的库，根据是否开启onDemand特性来决定是否引入。 module2的AndroidManifest.xml \u003cdist:module dist:onDemand=\"false\"\u003e \u003c/dist:module\u003e module2的onDamand=\"false\"，表示关闭按需引入，模块会打包进入apk。 module3的onDamand=“true”，表示开启按需引入，模块不会打包进入apk，会以第三方库（:third_party）的形式存在云端，在应用运行过程中根据需要额外下载。 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:3:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"Core :module1、:module2、:module3共同构成共享核心代码库。 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:4:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"Instant Dynamic Delivery 图例中不包含Instant Dynamic Delivery，这是一种特殊的Dynamic Delivery。“Instant”直译为“瞬间”，你们记得应用商店里的快速启动App吗？Instant Dynamic Delivery写出来的Module就是它。 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:5:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"为什么要引入Dynamic Delivery？ 80%的用户使用应用中20%的功能，这意味着你apk中打包的大部分功能对于大部分用户是闲置的，这就很浪费apk的大小空间。引入动态分发，就是为了将冗余的东西尽可能剔除，Library包含用户常用的20%的功能，剩余的模块交给Dynamic Delivery，在用户需要使用的时候再下载这些模块。 Module标注 :app为Application，它的build.gradle apply plugin:'com.android.application' :module1为Library,它的build.gradle使用 apply plugin:'com.android.library' :module2和module3为Dynamic Delivery，它们的build.gradle使用 apply plugin:'com.android.dynamic-feature' Module引入 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:6:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"Application引入Library :app的build.gradle implemetation project(':module1') ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:7:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Android Framework"],"content":"Application引入Dynamic Delivery :app的build.gradle dynamicFeatures = [':module2', ':module3'] Module运行 在Run/Debug Configuration的Dynamic features to deloy中选择动态添加的模块 ","date":"2020-07-27","objectID":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/:8:0","tags":["Android Framework"],"title":"Android模块化开发基础","uri":"/android%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"categories":["Kotlin"],"content":"内联扩展函数是啥玩意儿？答：Kotlin为你打包好的工具包。 如果说Java是一条龙服务，那Koltin就是在一条龙之外还提供了“内联函数”这种免费附赠服务。就好比你买膜，Java只给了你膜，而Kotlin还给了你贴膜工具包，让贴膜的过程无比丝滑。丝滑如下： lambda简化 写过Android的小伙伴肯定认识这样一位软妹OnClickListener， 用Java写是这样的 button.setOnClickListener(new OnClickListener { @Override public void OnClick(View v) { // to do } }) 用Kotlin写是这样的 button.setOnClickListener(object:OnClickListener{ override fun OnClick(v: View?) { // to do } }) 然后呈上我们的“Kotlin+lambda”魔幻大法，它就变成了这样 button.setOnClickListener { v-\u003e // to do } 如果你连OnClick的参数View在to do时都用不到，你甚至可以不写 button.setOnClickListener { // to do } 不仅如此，想用的时候，可以用it来代替参数View（因为只有一个参数，所以可以用it替代，因为it是单参数的隐式名称）。这就像曾经有一份爱情View在你面前，你没有去表达，当你回头想起，你还可以用it来替代View所留下的空白（所以View只是过客，it才是真爱）。 button.setOnClickListener { println(it.id) } 相信很多小伙伴已经懵了，这是什么操作？这叫“一夫一妻制”（我乱起的，别瞎记），如果一个接口只有一个抽象方法，你就可以享受这种服务，多个抽象方法不行。毕竟一夫一妻的时候，你喊一下老婆，谁都知道你在喊谁，但是在一夫多妻制下，呵，还真不知道你喊的是哪一位老婆… 如果这个抽象方法有多个参数怎么办？来，让我们继续魔幻，拿OnEditorActionListener举例 textView.setOnEditorActionListener( object: TextView.OnEditorActionListener { override fun onEditorAction(v: TextView?, actionId: Int, event: KeyEvent?): Boolean { // to do something } }) 他有三个参数v: TextView?, actionId: Int, event: KeyEvent?，取参数名拿逗号隔开即可 textView.setOnEditorActionListener { v, actionId, event -\u003e // to do something } let 写过ES6标准JS的童鞋是不是很熟悉。 作者：你懂我意思吗？ 童鞋：我懂你意思。 （眉目传情ing） 作者：不，你不懂。 let有Kotlin里没用来声明块级作用域内的变量的作用。var在JS里是花花公子，毫无规矩到处沾花惹草，但在Kotlin里已经变成了专注于自身块级作用域的好男人，好男人一个就够了，所以let就去干其他事儿了。什么事儿？简化单对象连续操作代码。 我们经常要初始化一些对象的属性，就会出现下面这种连写的情况 student.setId(id) student.setName(name) student.setAge(age) grade = student.grade 每次初始化设置属性，我们都要写个studnet.然后后接方法，太累了。于是let就闪亮登场了，有了let，你可以用它画个圈圈，然后用it指代你要操作的对象，在这个圈圈里完成对公有属性和公有方法对操作。 student.let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade } 这是什么魔力？没错，这就是爱的魔力，我们可以称之为“转圈圈”（这也是我乱起的，别瞎记）。 你还可以加个问号，用于判空，当student为空的时候，就不会执行let中的代码 student?.let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade } 至于返回值，let会以闭包的形式返回返回值。你可以中途用return表达式，中途没执行return的话会返回最后一行。 var result = let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade 1 // 前面没执行return，则最后一行为作为返回值，这里返回值为1 }) with 你以为let的操作已经最骚了？不，没有最骚，只有更骚。 with不仅可以连操，还可以省略it。 var result = with(student, { setId(id) }) 不过不能像let那样判空。 run 你以为with的操作已经最骚了？Again，没有最骚，只有更骚。 在let和with面前，run就是个儿子。我不是说他菜，恰恰相反，他遗传了父母的优良基因，融合了let的语法和with的神仙操作，可承受男女混合双打，可称之为“塞尔维亚妖王”（我真的是乱起的，你们别瞎记啊）。 run的语法和let一样，可以判空 student.run {} // 不判空 student?.run {} // 判空 圈圈里的写法跟with一样：不需要it。 var result = student?.run { // to do something 1 // 最后一行为返回值，返回值为1 } 综上所述，run比let和with更好用，如果你们的技术总监同意的话，你甚至可以肆意地使用run来替代let和with。相对于let他不需要it，相对于with他增加了判空，实乃集两者之精华。 apply 如果说run是let和with的爸爸的话，那么apply就是run的兄弟。这俩语法一样，唯一不同的是返回值。run比较花心，各种返回值都能返回；apply比较专情，只返回自身对象。没错，无论你怎么搞他，他都只返回自身对象。 所以run几乎啥场景都能用，而apply比较适合对象修改后又赋值给自身的场景。 also also的语法和let一样，但是also返回的是当前对象，而let返回的是闭包。是不是跟apply和run的关系很像。 总结 let，返回闭包，可判空，要用it with，返回闭包，不可判空，省略it run，返回闭包，集let与with之大成，可判空，省略it apply与run一样，但是apply返回当前对象；also与let一样，但是also返回当前对象。 本章结束，完结撒花花～ ","date":"2020-07-15","objectID":"/kotlin%E9%AB%98%E7%BA%A7lambda%E4%B8%8E%E6%89%A9%E5%B1%95%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:0:0","tags":["Kotlin"],"title":"Kotlin高级：lambda与扩展内联函数","uri":"/kotlin%E9%AB%98%E7%BA%A7lambda%E4%B8%8E%E6%89%A9%E5%B1%95%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"}]