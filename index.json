[{"categories":["设计模式"],"content":"释义 外观模式，隐藏内部逻辑的复杂性，仅提供接口供客户端访问，这些接口就是“外观”。 外观模式ce53a2151e332a8cb18993a7dc9970a6 \" 外观模式 ShapeMaker是为客户端提供的接口，Circle和Square接入Shape。客户端通过ShapeMaker中的各种接口在ShapeMaker中创建Shape的各种实例并调用实例的方法。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类 interface Shape { fun draw() } class Circle : Shape { override fun draw() { drawCircle() } } class Square : Shape { override fun draw() { drawSquare() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接口 class ShapeMaker( // 包含的Shape类 private var circle : Circle private var square : Square ) { // 向客户端提供接口 public fun drawCircle() { circle.draw() } public fun drawSquare() { square.draw() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val circle: Circle = Circle() val square: Square = Square() val shapeMaker: ShapeMaker = ShapeMaker(circle, square) // 调用接口 shapeMaker.drawCircle() shapeMaker.drawSqaure() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：外观模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 装饰器模式，在原来的基础上再加一点点。 装饰器模式eff1373ae046481f906c08ce236e9afd \" 装饰器模式 圆Circle和抽象装饰器Decorator都实现了图形Shape接口。圆Circle的draw()只能画出圆，我们可以用红色装饰器RedDecorator来为图形涂上红色：RedDecorator的draw()会在调用圆Shape的draw()的基础上再添加涂成红色的方法。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"图形 interface Shape { fun draw() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"圆 class Circle { override fun draw() { drawCircle() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"装饰器 abstract class Decorator(val shape: Shape): Shape { override fun draw() { shape.draw() } } class RedDecorator(shape: Shape): Shape(shape) { // Shape都可以 override fun draw() { shape.draw() // 调用Shape的方法来画出图形 drawRed(shape) // 把图形“装饰”成红色 } // 涂成红色 override fun drawRed() { ... } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val circle: Circle = Circle() // 被涂成红色的圆形 val redCircle: Decorator = RedDecorator(circle) redCircle.draw() // 会调用RedDecorator中的draw() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：装饰器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 代理模式，自己完不成的事交由另一位能完成的代理人去完成。 代理模式c19c222aa00e32333e041890b84f031e \" 代理模式 作家Write会写作write()。原作家RealWriter有一天需要请加，就请了一位代理作家ProxyWriter来完成自己当天的工作。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"父类 interface Person {} ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"原作家 class RealWriter : Person { fun write() { ... } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代理作家 class ProxyWriter : Person( // 注意引入作家 var writer: Writer ){ // 调用原作家的方法 fun write() { writer.write() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val proxyWriter: ProxyWriter = ProxyWriter() proxyWriter.writer() // 由proxyWriter代为执行，实际上执行的是RealWriter的方法 } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：代理模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 组合模式，将结构相近的对象写为单一对象，并将这个对象作为树的节点类型，然后依据树形结构来构造对象。 组合模式b5768dc89a2325f5d226a85baf271b0d \" 组合模式 职员信息具有相近的结构，包括性别sex、名称name、部门dept、下级subs，可以作为单一对象。我们运用下级subs ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：组合模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单一对象 class Employee ( var sex: String var name: String var dept: String var subs: List\u003cEmployee\u003e = List\u003cEmployee\u003e() ) { fun addSub(sub: Employee) { subs.add(sub) } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：组合模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 创建雇员 val ceo: Employee = Employee( sex = \"男\", name = \"张三\", dept = \"总部\" ) val cto: Employee = Employee( sex = \"男\", name = \"李四\", dept = \"总部\" ) val cfo: Employee = Employee( sex = \"女\", name = \"王五\", dept = \"总部\" ) // 设置下级 ceo.addSub(cto) ceo.addSub(cfo) } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：组合模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 过滤器模式，运用不同标准的过滤器筛选出数据。 过滤器模式769a4d5cf4761be7e9f6a751104aad43 \" 过滤器模式 Male和Female是两个过滤器，分别用于筛选男性和女性。List\u003cPerson\u003e传入两个过滤器后，分别筛选出相应结果。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：过滤器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"过滤器 interface Filter { fun filteBySex() } class Male : Filter { override fun filteBySex(persons: List\u003cPerson\u003e): List\u003cPerson\u003e { val men: List\u003cPerson\u003e = List\u003cPerson\u003e() for(person in persons) { if(person.isMale()) { men.add(person) } else { // do Nothing } } return men } } class Female : Filter { override fun filteBySex(persons: List\u003cPerson\u003e): List\u003cPerson\u003e { val women: List\u003cPerson\u003e = List\u003cPerson\u003e() for(person in persons) { if(person.isFemale()) { women.add(person) } else { // do Nothing } } return women } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：过滤器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 初始化数据 val persons: List\u003cPersons\u003e = List\u003cPersons\u003e persons.add(object : Person(\"male\")) persons.add(object : Person(\"female\")) ... persons.add(object : Person(\"female\")) // 创建过滤器 val male: Male = Male() // 过滤 persons = Male().filteMale(persons) } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：过滤器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 桥接模式，在类的基础上，增加一个接口作为“桥”。接口的实现类和该类都可以独立变换而互不影响。 桥接模式41b8ab4c00e4fb477a9c86b18fe55eae \" 桥接模式 对于抽象类Shape，为他接入接口Drawable。Circle是抽象类Shape的实现类，Rabbit是接口Drawable的实现类。Circle和Rabbit可以互不干扰、独立实现。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"桥 interface Drawable { fun draw() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类 abstract class Shape : Drawable{ override fun draw() fun show() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"桥的实现类 class Rabbit : Drawable{ override fun draw() { drawRabbit() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"基础类的实现类 class Circle : Shape { override fun draw() { drawCircle() } override fun show() { showCircle() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val rabbit: Rabbit = Rabbit() val circle: Circle = Circle() // rabbit实现Drawable，可以draw() rabbit.draw() // circle实现Shape，可以draw()和show() rabbit.draw() rabbit.show() } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["设计模式"],"title":"结构型：桥接模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 适配器模式，实现接口兼容。为对象增加一个适配器，使得其兼容原先无法使用的内容。 适配器模式9c65ccf874a5d487704889f9147b3c1a \" 适配器模式 BasicReader只能读txt格式的文件，AdvancedReader能够读ppt格式和doc格式的文件。为了让BasicReader也能读ppt和doc，我们为其引入适配器ReaderAdapter，适配器中使用了AdvancedReader，因此BasicReader获得了读ppt和doc的能力，实现了对这两种格式的兼容。 ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"被兼容 interface AdvancedReader { fun readPpt() fun readDoc() } class Ppt() { override fun readPpt() { toReadPpt() } override fun readDoc() { // do Nothing } } class Doc() { override fun readPpt() { // do Nothing } override fun readDoc() { toReadDoc() } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"适配器 class ReaderAdapter( val advancedReader: AdvancedReader ) { fun compatOpen(type: String) { when(type) { \"ppt\" -\u003e advancedReader.readPpt() \"doc\" -\u003e advanceReader.readDoc() } } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"兼容 interface BasicReader { fun readTxt() } class Txt(readerAdapter: ReaderAdapter) : BasicReader { override fun readTxt() { toReadTxt() } fun compatRead(type: String) { when(type) { // 如果是txt就调用自身的方法 \"txt\" -\u003e readTxt() // 如果是ppt和doc就通过适配器调用advancedReader的方法 \"doc\" -\u003e readerAdapter .advancedReader .compatOpen(type) \"ppt\" -\u003e readerAdapter .advancedReader .compatOpen(type) } } } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { doc: Doc = Doc() readerAdapter: ReaderAdapter = ReaderAdapter(doc) txt: Txt = Txt(readerAdapter) // txt兼容打开doc txt.compatOpen(\"doc\") } ","date":"2020-08-13","objectID":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"结构型：适配器模式","uri":"/%E7%BB%93%E6%9E%84%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 原型模式，暂存一个原型，当需要创建该类的对象的时候（尤其是需要大量该类对象的时候），直接从这个原型复制一个对象出来而不是从头开始创建。 原型模式a1b59f8549bb36211a237d4f059a3141 \" 原型模式 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接入Cloneable 需要被克隆的类必须接上Cloneable，建议重写clone方法。 class Shape : Cloneable { open var name: String? = null public override fun clone(): Any? { var clone: Any? = null try { clone = super.clone() } catch (e: CloneNotSupportedException) { e.printStackTrace() } return clone } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"子类 Circle class Circle : Shape() { override var name = \"Circle\" ... } Square class Square : Shape() { override var name = \"Square\" ... } Rectangle class Rectangle : Shape() { override var name = \"Rectangle\" ... } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"存入ShapeMap 创建ShapeCache对象来存储ShapeMap class ShapeCache { private var shapeMap: MutableMap\u003cString, Shape\u003e = mutableMapOf() // 向缓存中放入Shape fun loadCache(shape: Shape) { shapeMap?.set(\"name\", shape) } fun getShape(name: String): Shape { return shapeMap.get(name) } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 创建三个对象 val circle: Circle = Circle() val square: Square = Square() val rectangle: Rectangle = Rectangle() // 创建缓存 val shapeCache: ShapeCache = ShapeCache() // 将对象存入缓存 shapeCache.loadCache(circle) shapeCache.loadCache(square) shapeCache.loadCache(rectangle) // 克隆 val circleClone: Circle = shapeCache.get(\"circle\").clone() as Circle val squareClone: Square = shapeCache.get(\"square\").clone() as Square val rectangleClone: Rectangle = shapeCache.get(\"rectangle\").clone() as Rectangle } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"创建型：原型模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 单例模式，对象仅保持一个实例，并且这个实例由自己创建。通常这个实例是静态变量，创建实例的方法为静态方法。 单例模式5e817762086956cc02e9328ff6128b49 \" 单例模式 最直观的例子：数据库对象，创建费时费力，但是复用性很高。因此我们对于数据库对象可以使用单例模式，在首次获取实例时创建实例，后续获取实例则直接返回已存在的实例。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：单例模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"自我实例化 class Database() { companion object { private var instance: Database? = null fun getInstance(): Database { // 如果实例未被创建，则创建，否则直接返回已经存在的实例 if(instance == null) { instance = Database() } return instance } } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：单例模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 首次使用会创建实例 val database1 = Database.getInstance() // 再次使用直接返回已存在的实例 val database2 = Database.getInstance() } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：单例模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"建造者模式 建造者模式，如果一个对象很复杂，我们可以将其分割为各个子类，逐步构造子类，最后完成这个对象的构造，这个过程就像建筑师在建造房子时逐步添砖加瓦的过程。 建造者模式58fd5e8c21538eb3961126744d1d2caa \" 建造者模式 快餐店出售食品Food，食品的菜单是这样的： 饮料Drink 果汁Juice 可乐Cola 主食StapleFood 汉堡Burger 三明治Sandwich 配菜SideDish 鸡肉Chicken 薯条Chips 不过快餐店更希望将这些单品打包成套餐Meal进行出售，所以他们把菜单改成了这样： 套餐A 果汁Juice+汉堡Burger+鸡肉Chicken 套餐B 可乐Cola+三明治Sandwich+薯条Chips ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"套餐Meal class Meal { val drink: Drink val stapleFood: StapleFood val sideDish: SideDish } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"套餐打包器MealBuilder class MealBuilder { fun buildMealA() { val meal: Meal = Meal() meal.drink = Juice() meal.stapleFood = Burger() meal.sideDish = Chicken() return meal } fun buildMealB() { val meal: Meal = Meal() meal.drink = Cola() meal.stapleFood = Sandwich() meal.sideDish = Chips() return meal } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { val mealA = MealBuilder().buildMealA() val mealB = MealBuilder().buildMealB() } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"创建型：建造者模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 抽象工厂模式，在工厂模式的基础上增加了一个能够生产工厂的超级工厂SuperFactory。抽象工厂AbstractFactory可以转变成模具厂ShapeFactory，也可以转变为颜料厂ColorFactory。 客户将订单交给超级工厂，超级工厂根据客户的需求，在抽象工厂的基础上建立模具厂或者颜料厂，并生产所需的产品。 抽象工厂模式9f49ba5a1c1b88338a8058978c9146da \" 抽象工厂模式 这个超级工厂可以生产ShapeFactory和ColorFactory两种工厂，这些工厂再分别去生产各自的产品。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"超级工厂 class SuperFactory { companion object { val COLOR: Int = 0x1 val SHAPE: Int = 0x2 } // 超级工厂根据type生产不同类型的工厂 fun getFactory(type: Int) { when(type) { COLOR -\u003e object : ColorFactory() SHAPE -\u003e object : ShapeFactory() } } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"抽象工厂 我们可以在抽象工厂的基础上建设模具厂或者颜料厂。 abstract class AbstractFactory { fun getShape(): Shape? fun getColor(): Color? } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"子工厂 // 变为模具厂 class ShapeFactory : AbstractFactory() { companion object { val CIRCLE = 0x0 val SQUARE = 0x1 val RECTANGLE = 0x2 } override fun getShape(type: Int): Shape? { // 与工厂模式相同，根据客户提交的type生产所需的产品 when(type) { CIRCLE -\u003e object : Circle() SQUARE -\u003e object : Square() RECTANGLE -\u003e object : Rectangle() } } // 模具厂无法生产颜料 override fun getColor(): Color? { return null } } 颜料厂同理，不赘述。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 // 生产Circle fun main() { val superFactory: SuperFactory = SuerpFactory() val circle: Circle = SuperFactory .getFactory(SuperFactory.SHAPE) .getShape(ShapeFactory.RED) } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"创建型：抽象工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"释义 工厂模式，一个工厂可以生产一类产品，客户在订单中告诉工厂产品的具体要求，工厂为客户生产相应的产品。 工厂模式af6f3cd101a5ff31c42b961f3fc849e3 \" 工厂模式 这是一家生产磨具Shape的模具厂ShapeFactory，Shape包括Circle、Square、Rectangle三种形状。客户告诉模具厂自己想要的形状，模具厂就会为客户生产对应的形状。 ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"产品类 interface Shape {} ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:1","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"产品子类 Circle open class Circle : Shape {} Square open class Square : Shape {} Rectangle open class Rectangle : Shape {} ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:2","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂 通过参数type告诉Factory我们需要的Shape类型。 class ShapeFactory { companion object { val CIRCLE = 0x0 val SQUARE = 0x1 val RECTANGLE = 0x2 } // 传入type参数告诉工厂生产对应的Shape fun getShape(type: Int): Shape { when(type) { CIRCLE -\u003e object : Circle() SQUARE -\u003e object : Square() RECTANGLE -\u003e object : Rectangle() } } } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:3","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用 fun main() { // 生产圆形模具Circle val shapeFactory: ShapeFactory = ShapeFactory() val circle: Circle = shapeFactory.getShape(ShapeFactory.CIRCLE) } ","date":"2020-08-12","objectID":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"创建型：工厂模式","uri":"/%E5%88%9B%E5%BB%BA%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"创建型 在创建对象的同时隐藏创建逻辑。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:1:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"结构型 关注类和对象的组合。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:2:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"行为型 关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:3:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"J2EE型 关注表示层。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） ","date":"2020-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/:4:0","tags":["设计模式"],"title":"设计模式分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"},{"categories":["Jetpack"],"content":"引言 我们在数据加载的过程中需要用到进度组件（例如加载圈、进度条）来显示加载状态。Paging为此提供了一个非常优秀的适配器LoadStateAdapter来支持这些进度组件。 代码用的是谷歌官方的Demo。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:0:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"挂载到PagingDataAdapater 我们在之前的文章中提到到PagingDataAdapater，它是用来给RecyclerView加载PaingData的。我们的LoadStateAdapter需要通过withLoadStateHeaderAndFooter挂载到PagingDataAdapater下。 mPagingDataAdapater.withLoadStateHeaderAndFooter { // 头部加载的适配器 header = mLoadStateAdapter(mPagingDataAdapater), // 底部加载的适配器 footer = mLoadStateAdapter(mPagingDataAdapater) } 我们将PagingDataAdapter传入到LoadStateAdapater中，这样LoadStateAdapter就能拿到PagingDataAdapter的状态了。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:1:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"LoadStateAdapter 然后就是适配器的常规操作，传入ViewHolder，绑定数据与视图。不过这里要注意的是： 绑定的是LoadState ViewHolder是NetworkStateItemViewHolder。这是一个自定义的ViewHolder，用于存放进度组件。 class MyLoadStateAdapter( private val adapter: PostsAdapter ) : LoadStateAdapter\u003cNetworkStateItemViewHolder\u003e() { override fun onBindViewHolder(holder: NetworkStateItemViewHolder, loadState: LoadState) { holder.bindTo(loadState) } override fun onCreateViewHolder( parent: ViewGroup, loadState: LoadState ): NetworkStateItemViewHolder { return NetworkStateItemViewHolder(parent) { adapter.retry() } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:2:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"ViewHolder 布局文件network_state_item.xml \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:padding=\"8dp\"\u003e \u003cTextView android:id=\"@+id/error_msg\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\"/\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" style=\"?android:attr/progressBarStyle\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\"/\u003e \u003cButton android:id=\"@+id/retry_button\" style=\"@style/Widget.AppCompat.Button.Colored\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"@string/retry\"/\u003e \u003c/LinearLayout\u003e ViewHolder实现 class NetworkStateItemViewHolder( parent: ViewGroup, private val retryCallback: () -\u003e Unit ) : RecyclerView.ViewHolder( LayoutInflater.from(parent.context).inflate(R.layout.network_state_item, parent, false) ) { private val binding = NetworkStateItemBinding.bind(itemView) private val progressBar = binding.progressBar private val errorMsg = binding.errorMsg private val retry = binding.retryButton .also { it.setOnClickListener { retryCallback() } } fun bindTo(loadState: LoadState) { progressBar.isVisible = loadState is Loading retry.isVisible = loadState is Error errorMsg.isVisible = !(loadState as? Error)?.error?.message.isNullOrBlank() errorMsg.text = (loadState as? Error)?.error?.message } } 我们在布局文件中放入了三个组件，分别是错误信息显示、加载圈、重试按钮。 我们在ViewHolder中的bindTo方法中，根据LoadState加载状态来改变组件的可见性从而实现加载效果。 这已经可以满足一般性的加载需求，你也可以根据自己的需要适当添加动画，来增强视觉观感。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/:3:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之进度状态","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E8%BF%9B%E5%BA%A6%E7%8A%B6%E6%80%81/"},{"categories":["Jetpack"],"content":"引言 Paging3的模型改了，主要特点是新增了中转器以实现网络数据的持久化存储。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:0:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Paging3模型 Paing数据加载的途径一：如果你希望数据实现持久化存储，你可以使用上述模型，网络与数据库的中转器RemoteMediator，将从NetworkService获取的数据写入数据库中，数据库返回PagingSource作为ViewModel的数据源。 Paing数据加载的途径二：如果你只是想从网络中加载数据而不打算持久化存储他们，你可以直接将创建PagingSource并从NetworkService将数据载入PagingSource。 下面，让我们一起来尝试一下，我将Google官方的Demo进一步简化，以方便你能快速抓住重点。 Demo的代码请点击PagingWithNetworkDemo ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:1:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"前置准备 非重点，一笔带过。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Gradle 关注Paging、Room的版本号和用kapt解析注解，可参考上一篇博文。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"NetworkService 用于获取数据，建议添加一个isFinal字段来判断是否是最后一个。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Database 数据库的三层，entity、dao、databse ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:2:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Mediator Mediator是网络与数据库之间的中介，用于将网络中的数据存储到数据库中。我们要完成两项基本工作： 准备路径参数：与api请求路径相关的参数。 确定加载行为：判断是操作是刷新（REFRESH）、向前追加（PREPEND）还是向后追加（APPEND），并据此确定接下来的数据加载行为。 从网络中获取数据：使用NetworkService，获取response，并从中拿到data。 将数据写入数据库：使用Database，获取dao，并通过dao操作将数据写入数据库。 判断是否还有后续数据 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"准备路径参数 我们根据上述提到的工作，需要传入 Databse 数据库。 NetworkService 网络服务，包含Api接口。 Query 请求路径@Path的相关参数（如果不需要也可以不传）。 我们的实体类是User，因此继承RemoteMediator\u003cInt, User\u003e。 class UserMediator( private val database: AppDatabase, private val networkService: NetworkService, private val query: String ) : RemoteMediator\u003cInt, User\u003e() { ... } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"确定加载行为 继承后，我们要实现load方法，该方法包含两个参数 LoadType 加载类型 PagingState\u003cInt, User\u003e 分页状态 并返回MediatorResult。 override suspend fun load(loadType: LoadType, state: PagingState\u003cInt, User\u003e): MediatorResult { ... } 在方法中，我们根据参数loadType来确定加载行为。 LoadType是一个枚举类 enum class LoadType { REFRESH, PREPEND, APPEND } 包含刷新REFRESH、向前追加PREPEND、向后追加APPEND三种状态。 假设我们这是一个下拉加载的列表，我们对这三种状态分别进行处理： 刷新REFRESH，即加载的方式与上一次一样，返回null即可 向前追加PREPEND，不需要上拉加载，所以返回MediatorResult.Success(endOfPaginationReached = true)来说明向前的时候已经没有更多数据了，我们上拉的时候就不会加载数据。 向后追加APPEND，一般是要加载数据的，我们根据参数state来判断一下是不是已经没有后续数据了，如果是就返回MediatorResult.Success(endOfPaginationReached = true)，不是就返回最后一条数据的id，用于后续的网络请求。 // 根据加载类型，设置加载行为的关键字 val loadKey = when (loadType) { // 刷新， LoadType.REFRESH -\u003e null // 向上加载 LoadType.PREPEND -\u003e return MediatorResult.Success(endOfPaginationReached = true) // endOfPaginationReached判读分页是否到底了，即还有没有后续数据 // 向下加载 LoadType.APPEND -\u003e { val lastItem = state.lastItemOrNull() ?: return MediatorResult.Success(endOfPaginationReached = true) lastItem.id } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"从网络中获取数据 我们分别来看我们先前三种状态处理后的关键字，在网络请求中会发生什么： // 从网络获取应答 val response = networkService.getDataByItem( query = query, after = loadKey, limit = when (loadType) { LoadType.REFRESH -\u003e state.config.initialLoadSize else -\u003e state.config.pageSize } ) 假设我们上一次请求了id为1～10号的数据 刷新REFRESH，after==loadKey==null，NetworkService中会据此判断我们需要发送原来的请求，原来请求了id为1～10的数据，现在还是请求id为1～10的数据。此外，limit会根据state中配置的条目initialLoadSize来确定加载数据的数量。 向前追加PREPEND，因为早已返回了RemoteMediator.MediatorResult.Success(endOfPaginationReached = true)，不会执行此段代码。 向后追加APPEND，after==loadKey==lastItem.id==10，NetworkService需要请求11~20号的数据。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"将数据写入数据库 操作数据库需要用到dao层，因此引入UserDao，并通过数据库的事务withTranscation来存入数据。如果是刷新，就先清空原数据，再存入新数据。 class UserMediator( private val database: AppDatabase, private val networkService: NetworkService, private val query: String ) : RemoteMediator\u003cInt, User\u003e() { private val userDao = database.getUserDao() override suspend fun load(loadType: LoadType, state: PagingState\u003cInt, User\u003e): MediatorResult { ... // 将数据写入数据库 database.withTransaction { if (loadType == LoadType.REFRESH) { userDao.clearAll() } userDao.insertAll(response.data) } ... } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:4","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"判断是否还有后续数据 在load方法中，千万不要忘记判断还有没有后续数据，毕竟load方法最后要返回MediatorResult // 根据后台给出的数据判断是否还有后续数据 MediatorResult.Success( endOfPaginationReached = response.isFinal ) ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:5","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"完整代码 // 网络与数据库之间的中转站 @OptIn(ExperimentalPagingApi::class) class UserMediator( private val database: AppDatabase, private val networkService: NetworkService, private val query: String ) : RemoteMediator\u003cInt, User\u003e() { private val userDao = database.getUserDao() override suspend fun load(loadType: LoadType, state: PagingState\u003cInt, User\u003e): MediatorResult { return try { // 根据加载类型进行不同的操作 val loadKey = when (loadType) { // 刷新 LoadType.REFRESH -\u003e null // 向上加载 LoadType.PREPEND -\u003e return MediatorResult.Success(endOfPaginationReached = true) // endOfPaginationReached判读分页是否到底了，即还有没有后续数据 // 向下加载 LoadType.APPEND -\u003e { val lastItem = state.lastItemOrNull() ?: return MediatorResult.Success(endOfPaginationReached = true) lastItem.id } } // 从网络获取应答 val response = networkService.getDataByItem( query = query, after = loadKey, limit = when (loadType) { LoadType.REFRESH -\u003e state.config.initialLoadSize else -\u003e state.config.pageSize } ) // 将数据写入数据库 database.withTransaction { if (loadType == LoadType.REFRESH) { userDao.clearAll() } userDao.insertAll(response.data) } // 根据后台给出的数据判断是否还有后续数据 MediatorResult.Success( endOfPaginationReached = response.isFinal ) } catch (e: IOException) { return MediatorResult.Error(e) } catch (e: HttpException) { return MediatorResult.Error(e) } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:3:6","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"PaingSource 曾经的“三人组”已被丢弃： PositionalDataSource ItemKeyedDataSource PageKeyedDataSource 已统一为： PagingSource 你可以使用PagingSource来实现“三人组”的功能。 关键在于设置prevKey和nextKey。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"ItemKeyDataSource ItemKeyDataSource继承PagingSource，通过网络请求来直接获得数据。适用于前后加载有关联的数据，例如有序的id等等。此例中就是运用data.firstOrNull()?.id和data.lastOrNull()?.id作为上下加载的关键字prevKey和nextKey。上拉加载就启用prevKey，下拉就在启用nextKey。 // ItemKey，使用条目中的关键信息进行关联查询。 // 适合一些上下有关联的，例如有序的id。 class ItemKeyUserDataSource( private val networkService: NetworkService, private val query: String ) : PagingSource\u003cString, User\u003e() { override suspend fun load(params: LoadParams\u003cString\u003e): LoadResult\u003cString, User\u003e { return try { // 从网络中获取应答 val response = networkService.getDataByItem( // 后端接口查询数据库所需的信息 query = query, // 如果是Append向后追加，就启用after，after是上一次请求的nextKey after = if (params is LoadParams.Append) params.key else null, // 如果是Prepend向前追加，就启用before，before是上一次请求的prevKey before = if (params is LoadParams.Prepend) params.key else null, // 尺寸 limit = params.loadSize ) // 从应答中获取数据 val data = response.data // 构建PageSource作为数据源 // prevKey和nextKey用于下一次加载，根据Append和Prepend来决定加载使用哪一个 LoadResult.Page( data = data, prevKey = data.firstOrNull()?.id, nextKey = data.lastOrNull()?.id ) } catch (e: IOException) { return LoadResult.Error(e) } catch (e: HttpException) { return LoadResult.Error(e) } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"PageKeyDataSource PageKeyDataSource继承PagingSource，使用页码page作为上下加载的关键字prevKey和nextKey。适合已经做好分页的数据，例如翻页书籍。 // PageKey，按页码加载。 // 适用于分页加载的场景。 class PageKeyUserDataSource( private val networkService: NetworkService, private val query: String ) : PagingSource\u003cInt, User\u003e() { override suspend fun load(params: LoadParams\u003cInt\u003e): LoadResult\u003cInt, User\u003e { return try { // 页码 val page = params.key ?: 0 // 从网络中获取应答 val response = networkService.getDataByPage( // 后端接口查询数据库所需的信息 query = query, // 如果是Append向后追加，就启用after，after是上一次请求的nextKey page = params.key, // 尺寸 limit = params.loadSize ) // 从应答中获取数据 val data = response.data // 构建PageSource作为数据源 // prevKey和nextKey用于下一次加载，根据Append和Prepend来决定加载使用哪一个 LoadResult.Page( data = data, // 如果当前页码不为0，则赋值为前一页的页码 prevKey = if (page == 0) null else page - 1, // 如果是最后一页，则下一页为空，否则赋值为下一页的页码 nextKey = if (response.isFinal) null else page + 1 ) } catch (e: IOException) { return LoadResult.Error(e) } catch (e: HttpException) { return LoadResult.Error(e) } } } ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"PositionalKeyDataSource 你自己写吧，反正都一个套路… 核心就是设置prevKey和nextKey。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:4:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Repository 针对通过Mediator和直接对接PagingSource的数据，最终都要在Repository中转化为PageData才能供UI使用，我们在ViewModel中调用Repository中的方法来拿到PagingData。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Network+Mediator+Database 对于通过Mediator的数据，我们创建Pager对象时传入中转器和页面配置，并在lambda表达式中进行数据库查询操作，查询的结果作为数据源，最后flow成PagingData。 // 持久化存储，运用remoteMediator将数据库和网络桥接起来，从网络将数据写入数据库 fun getUsersInDb(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize), remoteMediator = UserMediator( database, networkService, query ) ) { database.getUserDao().selectAll() }.flow ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"Network+PagingSource 对于直接对接PagingSource的数据，我们创建Pager时传入页面配置，并在lambda表达式中直接创建我们的数据源，最后flow成PagingData。 // 非持久化存储，直接从网络写入内存 fun getUsersInMemory(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize) ) { ItemKeyUserDataSource(networkService, query) }.flow ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"完整代码 class UserRepository(private val database: AppDatabase, private val networkService: NetworkService) { // 持久化存储，运用remoteMediator将数据库和网络桥接起来，从网络将数据写入数据库 fun getUsersInDb(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize), remoteMediator = UserMediator( database, networkService, query ) ) { database.getUserDao().selectAll() }.flow // 非持久化存储，直接从网络写入内存 fun getUsersInMemory(query: String, pageSize: Int) = Pager( config = PagingConfig(pageSize) ) { ItemKeyUserDataSource(networkService, query) }.flow } 再往上ViewModel、Adapter…反正大家都会了就不写了，不会的参考我上一篇博文。 ","date":"2020-08-10","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/:5:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库与网络加载","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD/"},{"categories":["Jetpack"],"content":"引言 也许你还在RecyclerView的下拉加载而烦恼，也许你还在为做分页缓存而头疼，所以，他来了——Paging分页库。 我将代码存到了gitub上，点击PagingDemo跳转。强烈建议下载代码后，再对照博文阅读。 技巧 别盯着油管上谷歌官方2018年IO大会的教程了，Paging库中的代码早已发生了翻天覆地的变化。时代变了，大人～ ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:0:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"配置 配置我使用versions的写法，请结合Demo查看，我提一下几个要点。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:1:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"注解使用kapt 请确保你使用kapt来解析注解 apply plugin: 'kotlin-kapt' dependencies { kapt deps.room.compiler } 请确保注解解释器的版本大于2.3.0 versions.room = \"2.3.0-alpha01\" 否则你的注解将无法正确解析。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:1:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Kotlin/Java编译器版本 请确保在你的Kotlin/Java版本皆指向1.8。 在module的build.gradle中 android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" freeCompilerArgs += [\"-Xopt-in=kotlin.RequiresOptIn\"] } } 注意 如果你注意以上两点，那么你的程序基本不会因为配置的原因原地爆炸。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:1:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"数据库 数据库包含实体层（Table）、Dao层（SQL）、数据库层（Scheme）。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Entity 为类打上@Entity注解，为主键id打上@PrimaryKey注解并标明自增。 @Entity data class User( @PrimaryKey(autoGenerate = true) val id: Int, val name: String ) ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Dao 定义了三个方法 allUsers查询，我们的终极目的就是查出来 insert插入，后面用于填入模拟数据 deleteAll删除，会清空数据库中所有的数据 重点： 我们的allUsers()返回PagingSource\u003cK, V\u003e @Dao interface UserDao { @Query(\"SELECT * FROM User\") fun allUsers(): PagingSource\u003cInt, User\u003e @Insert fun insert(users: List\u003cUser\u003e) @Query(\"DELETE FROM User\") fun deleteAll() } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Database 为类打上Database注解并指明包含的类和数据库版本，引入了dao层，并且通过静态方法创建静态实例。 技巧 建议大家学会这种方法，不要再在Repositories层或者viewModel层build数据库了，太杂了。 @Database(entities = [User::class], version = 1) abstract class UserDatabase : RoomDatabase() { abstract fun userDao(): UserDao companion object { private var instance: UserDatabase? = null /** * 提供互斥的静态方法用于获取数据库实例 * 如果实例没创建，则创建；已经创建了，直接返回实例 * 减少了创建实例所花费的开销 */ @Synchronized fun get(context: Context): UserDatabase { if (instance == null) { instance = Room.databaseBuilder( context.applicationContext, UserDatabase::class.java, \"UserDatabase\" ).build() } return instance!! } } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:2:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"适配器 适配器完成三件事 Layout ViewHolder Adapter ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"layout 为Activity和RecyclerView的item分别建立布局。 Activity 注意RecyclerView要指定layoutManager \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".activity.MainActivity\"\u003e \u003candroidx.recyclerview.widget.RecyclerView android:id=\"@+id/recyclerview\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layoutManager=\"LinearLayoutManager\"/\u003e \u003cButton android:id=\"@+id/delete\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e RecycleView的item 两个文本控件，分别用于显示User的id和name。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"\u003e \u003cTextView android:id=\"@+id/item_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"TextView\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cTextView android:id=\"@+id/item_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"TextView\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/item_id\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"ViewHolder 根据我们创建的item布局和User实体类，我们写一个ViewHolder class UserViewHolder(parent: ViewGroup): RecyclerView.ViewHolder( LayoutInflater.from(parent.context).inflate(R.layout.item, parent, false) ) { // 控件 private val idView = itemView.item_id private val nameView = itemView.item_name // 数据 private var user: User? = null // 用于数据与控件的绑定 fun bindTo(user : User?) { this.user = user idView.text = user?.id.toString() nameView.text = user?.name } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Adapter 重点： 继承了PagingDataAdapter\u003cObject, ViewHolder\u003e diffCallback的判断，建议采用这种变量写法会比较清晰（Kotlin的特性不用白不用） /** * 继承PagingDataAdapter */ class UserAdapter : PagingDataAdapter\u003cUser, UserViewHolder\u003e(diffCallback) { // diffCallback用内部定义的变量 override fun onBindViewHolder(holder: UserViewHolder, position: Int) { // 数据绑定：传入条目的位置信息，将数据绑定到这个位置的条目上 holder.bindTo(getItem(position)) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder { // 布局创建：传入父布局，在父布局中创建布局 return UserViewHolder(parent) } companion object { // 同异判断：分别用于判断条目是否更新和内容是否更新 private val diffCallback = object : DiffUtil.ItemCallback\u003cUser\u003e() { override fun areItemsTheSame(oldItem: User, newItem: User): Boolean { return oldItem.id == newItem.id } override fun areContentsTheSame(oldItem: User, newItem: User): Boolean { return oldItem == newItem } } } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:3:3","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"活动 活动需要完成 ViewModel Activity ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:4:0","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"ViewModel 重点： 我们的数据由Pager对象构建，PagingConfig作为参数传入，方法体中执行数据库查询操作，最后flow来获得Flow\u003cPagingData\u003cValue\u003e\u003e对象，最终将其赋值给allUsers。 我定义了两个挂起方法和一组模拟数据，我将在Activity中的Kotlin协程中使用它们。 你发现我的模拟数据由id，但是上面的数据库中又指明id是自增的，这很矛盾。其实模拟数据的id只是我用来方便创建对象用的，真正的id由数据库生成，我们最终数据呈现所使用的id也是数据库中的id。但我这样做希望提醒你一点：我在insertAll的map中设置id=0，那么就会启用自增，数据库中的id，与你创建对象的id属性无关。 class MainViewModel(app: Application): AndroidViewModel(app) { private val dao = UserDatabase.get(app).userDao() // 模拟数据，用于填充数据库 private val USER_DATA = arrayListOf\u003cUser\u003e( User(1, \"Name1\"), User(2, \"Name2\"), User(3, \"Name3\"), User(4, \"Name4\"), User(5, \"Name5\") ) /** * 通过Pager的构造方法中的config参数配置分页的参数 * 通过Pager的方法体传入数据 */ val allUsers = Pager( PagingConfig( pageSize = 5, enablePlaceholders = true ) ) { dao.allUsers() }.flow // 删除所有数据 suspend fun deleteAll() { withContext(Dispatchers.IO) { dao.deleteAll() } } // 填充模拟数据 suspend fun insertAll(context: Context) { withContext(Dispatchers.IO) { UserDatabase.get(context.applicationContext).userDao() .insert( USER_DATA.map { User(id = 0, name = it.name) } ) } } } ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:4:1","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Jetpack"],"content":"Activity 重点： 在协程中，你需要adapter.submitData(it)来将数据传递给适配器。 lass MainActivity : AppCompatActivity() { private val viewModel by viewModels\u003cMainViewModel\u003e() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val adapter = UserAdapter() recyclerview.adapter = adapter lifecycleScope.launch { // 插入所有模拟数据 viewModel.insertAll(application) // 更新适配器数据 @OptIn(ExperimentalCoroutinesApi::class) viewModel.allUsers.collectLatest { adapter.submitData(it) } } // 绑定删除数据事件 delete.setOnClickListener { lifecycleScope.launch(Dispatchers.IO) { viewModel.deleteAll() } } } } 总结 这只是一个很基础的Demo。我们平时的开发场景，更多是结合通过网络来进行分页处理。在下一篇博文中，我将陈述如何操作。 我建议你更多的参考Google在Github上留下的Demo。虽然有些写法并不好，但核心的东西都会表达出来，不要再依赖过时的视频来进行学习。 ","date":"2020-08-05","objectID":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/:4:2","tags":["Jetpack"],"title":"Jetpack：Paging分页库之使用基础","uri":"/jetpackpaging%E5%88%86%E9%A1%B5%E5%BA%93%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"categories":["Gradle"],"content":"引言 你有没有很奇怪，我们的远程引入的依赖库为什么只需要写入源即可？难道还有不需要网络协议就能获取到的资源？怎么可能。那么协议写到了哪里？写到仓库中。位置在project的build.gradle中 buildscript { repositories { // 编译工具用到的仓库 } } allprojects { // 所有项目都用到的仓库 } ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:0:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"google()与jcenter() 当我们创建新项目时，就会看到这样的代码 buildscript { repositories { google() jcenter() } } allprojects { repositories { google() jcenter() } } 通过上述代码引入和google和jcenter的仓库，然后我们填写依赖的源的时候，会根据源自动在这些仓库中搜索合适的库进行引入。 我们打开上述两个方法会发现 public interface RepositoryHandler extends ArtifactRepositoryContainer { MavenArtifactRepository google(); MavenArtifactRepository jcenter(); } 而MavenArtifactRepository中包含对URI的操作 URI getUrl(); void setUrl(URI url); Set\u003cURI\u003e getArtifactUrls(); ... 正是通过这些方法从互联网上获取到远程仓库。 ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:1:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"自定义仓库 你还可以通过maven添加新的仓库 buildscript { repositories { maven { url \"http://repo.mycompany.com/maven2\" } } } ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:2:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"多模块下的仓库管理 我们之前提到过使用versions来管理版本，也可以用它来管理仓库。 在project下新建version.gradle 在versions.gradle中（注意调用方法时，使用符号\u0026） def addRepos(RepositoryHandler handler) { handler.google() handler.jcenter() handler.maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } ext.addRepos = this.\u0026addRepos 在project的build.gradle中 buildscript { // 引入versions.gradle apply from: \"versions.gradle\" // 添加仓库 addRepos(repositories) } allprojects { // 添加仓库 addRepos(repositories) } ","date":"2020-08-04","objectID":"/gradle%E4%BB%93%E5%BA%93/:3:0","tags":["Gradle"],"title":"Gradle：仓库","uri":"/gradle%E4%BB%93%E5%BA%93/"},{"categories":["Gradle"],"content":"引言 很多同学写了Android很久，对于依赖库的引入却是傻傻分不清。因为Gradle随着版本的升级，语义在不断的变化，从compile到implementation，从apt到annotationProcessor…已经绕晕了不少人，今天就来明确下依赖最最基础的依赖库的用法。 注意 很少有关注gradle的变化，认为gradle区区配置不重要，但是对于大规模项目而言，gradle是整个项目的骨架，极为重要。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:0:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"Gradle依赖 Gradle并非孤例运行，他自身也会依赖于一些插件，在project的build.gradle中，使用classpath引入 classpath \"lib-gradle\" ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:1:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"开发依赖库 正式运行时使用的依赖库，对应我们的开发目录。 在module的build.gradle中，使用implementation引入 dependencies { implementation “lib-source” } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:2:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"测试依赖库 测试程序时使用的依赖库，对应androidTest目录。 在module的build.gradle中，使用androidTestImplementation引入 dependencies { androidTestImplementation \"lib-source\" } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:3:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"测试工具依赖库 在module的build.gradle中，使用testImplementation引入 dependencies { testImplementation \"test-tool-source\" } 例如junit的库。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:4:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"本地依赖库 如果是本地依赖库，则需要将依赖库放入module的libs文件夹中，在module的build.gradle中，用fileTree引入 dependencies { // 从文件夹libs中引入后缀为jar文件作为依赖库 implementation fileTree(dir: \"libs\", include: [\"*.jar\"]) } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:5:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"注释处理器 带有注解的代码会通过注释处理器**APT（Annotation Processing Tool）**进行转换，变成不带注解的代码（注解往往都是控制反转用的，我们的虚拟机可运行不了带注解的代码）。对于kotlin和java有不同的配置方式。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:6:0","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"kotlin 在project的build.gradle中配置 apply plugin: 'kotlin-kapt' kapt { arguments { arg(\"AROUTER_MODULE_NAME\", project.getName()) } } 在module的build.gradle中，先引入kotlin-kapt插件，再通过kapt引入 apply plugin: 'kotlin-kapt' dependencies { kapt \"apt-source\" } ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:6:1","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"java 在project的build.gradle中配置 android { defaultConfig { javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } } 在module的build.gradle中，使用annotationProcessor引入 dependencies { annotationProcessor \"apt-source\" } annotationProcessor同时支持javac和jack两种编译方式。 注意 如果你的某个模块是Java和Kotlin混合开发，那么两者都要写上，他们会分别处理.java和.kt文件。 ","date":"2020-08-04","objectID":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/:6:2","tags":["Gradle"],"title":"Gradle：依赖库","uri":"/gradle%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Gradle"],"content":"引言 如果我们的project中有许多module，那么每个module下就会有一个build.gradle用于管理该module的依赖库。多模块对于开发人员的意义就是可以分块开发进而提升效率，但这也意味着沟通成本的提高和冗余工作的增加。 版本无法统一管理 甲引入了moduleA的1.0.0版本，乙在moduleB引入了1.0.1版本，如果需要甲乙统一版本，那就需要确保他们有效沟通。那如果再有丙在moduleC引入了1.0.2版本，丁在moduleD引入了1.0.3版本…每次改个依赖库的版本都是一次群体大会，一个人没统一，代码可能就会由于版本不统一出现问题。 人人研究配置 作为一位Android工程师，研究配置没有错，但是如果每个人每天都在折腾这些版本号，其他活就不用干了。 工作重心不当 你说不怕，我们有全局的build.gradle可以解决这个问题，但是想想，我们传统的一行implementation 'xxx'虽然引入很方便，但是可读性极差。我们对于配置的主要工作不在引入工作，而是版本管理工作，因此我们需要使用一种新的写法来解决版本管理。 注意 针对以上问题，我们引入了version版本控制的写法。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:1:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"创建版本管理文件 在project根目录下创建versions.grale文件，并在project的build.grale中引入 buildscript { apply from: 'versions.gradle' } 这样,versions.gradle就在整个工程中生效了，接下来我们来编写versions.gradle。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:2:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"声明额外属性 我们在Gradle中声明额外属性需要用到ext ext { deps versions } 或 ext.deps = [:] // [:]相当于null ext.version = [:] 上述代码就声明两个额外属性deps和verisons。如果我们定义了这些属性，那么就可以在后续的代码中使用这些属性。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:3:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"依赖版本 在version.gradle中， 阅读过程中注意首尾呼应，区分变量和额外属性。 // 声明额外属性deps，用于存放依赖的信息 ext.deps = [:] // 声明版本变量 def versions = [:] // 版本变量中为各种依赖库创建字段，并赋值版本号 versions.activity = '1.1.0' versions.android_gradle_plugin = '4.0.0' versions.annotations = \"1.0.0\" // 完成版本变量中全部版本号的定义后，将版本变量存入额外属性versions中 ext.versions = versions // 声明依赖库变量 def deps = [:] // 声明activity库变量 def activity = [:] // 为activity库变量的activity_ktx字段赋值来源信息，其中的$version.activity会引入我们上面定义的version.activity activity.activity_ktx = \"androidx.activity:activity-ktx:$versions.activity\" // 将activity库来源信息存入deps的activity字段中 deps.activity = activity // 将android_gralde_plugin库来源信息赋值到deps的字段android_gradle_plugin字段中 deps.android_gradle_plugin = \"com.android.tools.build:gradle:$versions.android_gradle_plugin\" // 将annotations库来源信息赋值到deps的字段nnotations字段中 deps.annotations = \"androidx.annotation:annotation:$versions.annotations\" // 完成所有依赖库中所有依赖的定义后，将依赖变量存入额外属性deps ext.deps = deps 像一些父库（例如activity）都会有各种子库（例如activity.activity_ktx），我们可以采用上述代码中activity的定义方式声明，先定义父库的变量，再在父库中添加子库的字段，最后把父库的变量存入deps。 而一些单一的库（例如android_gradle_plugin、annotations）则可直接赋值到字段中。 定义完后，我们就可以直接在工程中的全局build.gradle和module的build.gradle中使用存入deps中的字段来决定引入的依赖库而不需要纠结版本问题。 implementation deps.activity.activity_ktx implementation deps.android_gradle_plugin implementation deps.annotations 通过这种方式，团队中只需要指定一个人管理库版本即可，其他人仅负责引入。 诶？既然可以用来搞定依赖的版本，是不是也可以用这种方式控制其他版本呢？一个个文件找多累啊！没错，你的直觉是对的。我们还可以用这种方式控制build版本、Java版本。 ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:4:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"build版本 在versions.gradle中 def build_versions = [:] build_versions.min_sdk = 14 build_versions.compile_sdk = 29 build_versions.target_sdk = 29 build_versions.build_tools = \"29.0.3\" ext.build_versions = build_versions 在module的build.gralde中 android { compileSdkVersion build_versions.compile_sdk buildToolsVersion build_versions.build_tools defaultConfig { minSdkVersion build_versions.min_sdk targetSdkVersion build_versions.target_sdk } ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:5:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Gradle"],"content":"Java版本 在versions.gradle中 def java_version = [:] java_version.source = JavaVersion.VERSION_1_8 java_version.target = JavaVersion.VERSION_1_8 ext.java_version = java_version 在module的build.gralde中 android { compileOptions { sourceCompatibility java_version.source targetCompatibility java_version.target } } ","date":"2020-08-04","objectID":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:6:0","tags":["Gradle"],"title":"Gradle：多模块下的版本管理","uri":"/gradle%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Jetpack"],"content":"场景问题 我们在Android开发中会遇到这样一种场景： class MainActivity: AppCompatActivity() { private val component1: Component1 = Component1() private val component1: Component2 = Component2() override fun onCreate(...) { component1.create() component2.create() component3.create() } override fun onStart(...) { component1.start() component2.start() component3.start() } override fun onResume(...) { component1.resume() component2.resume() component3.resume() } override fun onPause(...) { component1.pause() component2.pause() component3.pause() } override fun onStop(...) { component1.stop() component2.stop() component3.stop() } override fun onDistory(...) { component1.distory() component2.distory() component3.distory() } } class Component1 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } class Component2 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } class Component3 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } 组件的特定方法要在特定的生命周期进行调用，如果存在多个这样的组件，则生命周期方法中的代码就会非常冗杂。因此，Android对此进行控制反转，引入了生命周期感应型组件，通过绑定LifecyclerObserver和LifecyclerOwner来解决此类问题。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:1:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecyclerOwner 带有生命周期的组件，例如Activity、Fragment，都持有lifecycleOwner。 不过lifecycleOwner是一个接口，他的表示类为lifecycle，你可以在组件的生命周期方法中获得lifecycle。 以Activity为例，他有 onCreate() onStart() onResume() onPause() onStop() onDistory() 六大生命周期。我们可以通过getLifecycle()在这些生命周期方法中获得lifecycle。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner onCreate() { mLifecycleOwner = lifecycle // 在kotlin中直接写lifecycle即表示getLifecycler() } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:2:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifeObserver 拿到LifecycleOwner后，我们获取他的LifeCycle为其添加观察者LifecycleObserver： mLifecycleOwner.getLifecycle().addObserver(mLifecycleObserver) 观察者中的会随着mLifecycleOwner生命周期的变化而执行不同的方法。观察者是怎样做到这一点的呢？ 实现LifecycleObserver接口 添加生命周期注解 MyObserver: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } 每当mLifecycleOwner进入某一生命周期时，都会触发mLifecycleObserver中带对应的@OnLifecycleEvent(Lifecycle.Event.xxx)注解的函数。例如，当mLifecycleOwner进入onCreate()时，mLifecycleObserver会执行带有@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)注解的方法。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:3:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"代码总结 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"完整代码 我们把代码完整地写一遍： MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { // 获取MainActivity的lifecycleOwner mLifecycleOwner = lifecycle // 初始化lifecycleObserver mLifecycleObserver = MyObserver1() // 绑定两者 mLifecycleOwner.addObserver(mLifecycleObserver) // 再来一遍 mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver2() mLifecycleOwner.addObserver(mLifecycleObserver) // 再来一遍 mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver3() mLifecycleOwner.addObserver(mLifecycleObserver) } } MyObserver1: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } MyObserver2: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } MyObserver3: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } 这样，我们将原来的每个生命周期填写对应的方法的多次操作转化为一次性的绑定操作。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:1","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"进一步优化 对于多个响应生命周期的组件，虽然我们通过上述方法避免了在每一个周期都写一次方法，但我们在一个周期内仍然要写很多重复的绑定操作，因此我们可以进一步优化，将绑定操作封装为函数lifecycleBind。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { lifecycleBind(lifecycle, MyObserver1()) lifecycleBind(lifecycle, MyObserver2()) lifecycleBind(lifecycle, MyObserver3()) ... } } class Util { companion object { fun lifecycleBind( mLifecycleOwner: LifecycleOwner, mLifecycleObserver: LifecycleObserver ) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:2","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"再进一步优化 我们解决了重复操作，但是仍然有一个问题，那就是要执行多个封装好的绑定函数。如果有99个组件，我就要写99行这样的代码。 我们发现在一个生命周期组件的绑定中，LifecycleOwner是固定的，而LifecycleObserver是不固定的。因此，我们可以建立LifecycleObserver数组，进行遍历操作。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner onCreate() { // 一次获取LifecycleOwner val mLifecycleOwner = lifecycle // 建立LifecycleObserver数组 val observers = listof( MyObserver1(), MyObserver2(), MyObserver3() ) // 遍历绑定 for(item in observers) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } class Util { companion object { fun lifecycleBind( mLifecycleOwner: LifecycleOwner, mLifecycleObserver: LifecycleObserver ) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:3","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"状态检查 有时候我们需要检查当前的生命周期状态，以进行特定的操作。例如，你可能会在Pause状态更新一个UI的状态，然后在Resume状态再一次更新他。生命周期感知型组件对此引入了状态检查。 传入lifecycle 检查lifecycle的状态 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver(mLifecycleOwner) mLifecycleOwner.addObserver(mLifecycleObserver) } onResume() { // 检查状态并执行操作 mLifecycleObserver.check() } } class MyObserver: LifecycleObserver( private val lifecycle: Lifecycle ) { fun check() { if(lifecycle.currentState.isAtLeast(Lifecycle.State.RESUMED) { // todo } } } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:5:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"Event与State 生命周期中有两个枚举类，分别指向生命周期的事件和状态。 Event源码： public enum Event { ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY } State源码： public enum State { DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; public boolean isAtLeast(@NonNull State state) { return compareTo(state) \u003e= 0; } } 我们在之前的代码中都用过了，Event用作事件注解，State用作状态检查。大家可以结合图例整体把握一下。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:6:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"源码分析 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"getLifecycle() 我们分别来看Activity和Fragment的getLifecycle() // ComponentActivity.java public Lifecycle getLifecycle() { return mLifecycleRegistry; } // Fragment.java public Lifecycle getLifecycle() { return mLifecycleRegistry; } 我们发现两者都返回了mLifecycleRegistry，这是什么呢？ // ComponentActivity.java private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); // Fragment.java LifecycleRegistry mLifecycleRegistry; private void initLifecycle() { mLifecycleRegistry = new LifecycleRegistry(this); mSavedStateRegistryController = SavedStateRegistryController.create(this); if (Build.VERSION.SDK_INT \u003e= 19) { mLifecycleRegistry.addObserver(new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (event == Lifecycle.Event.ON_STOP) { if (mView != null) { mView.cancelPendingInputEvents(); } } } }); } } Build.VERSION.SDK_INT \u003e= 19可见对于Fragemnt的Lifecycle的操作，只有SDK\u003e=19才会启用。 mLifecycleRegistry是LifecycleRegistry的实例。 public class LifecycleRegistry extends Lifecycle { ... } public abstract class Lifecycle { ... } 而Lifecycle是一个抽象类，LifecycleRegistry是Lifecycle的表现类。 由此可见，LifecycleRegistry表现了Lifecycle，而Fragment和Activity中获取到的Lifecycle都是LifecycleRegistry。但Lifecycle本身仅提供了Event和State的枚举类，对于Lifecycle主要的操作方法都在LifecycleRegistry中。当我们需要使用对Lifecycle的操作时，可以查看LifecycleRegistry寻找合适的方法。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:1","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecycleOwner LifecycleOwner只是一个接口，仅提供了getLifecycle()： public interface LifecycleOwner { @NonNull Lifecycle getLifecycle(); } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:2","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecycleObserver LifecycleObserver更狠，一无所有： public interface LifecycleObserver { } ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:3","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"代码去哪儿啦？ 你可能会很疑惑，代码去哪儿了？还记得刚才的LifecycleRegistry，没错，其实所有的逻辑代码都在这里。 查看addObserver()方法 // LifecycleRegistry @Override public void addObserver(@NonNull LifecycleObserver observer) { State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); } 然后我们通过addObserver()找到ObserverWithState： // LifecycleRegistry static class ObserverWithState { State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) { mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; } } 我们看到了LifecycleEventObserver，打开源码： // LifecycleEventObserver public interface LifecycleEventObserver extends LifecycleObserver { void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event); } 破案了，观察者LifecycleObserver通过Lifecycling.lifecycleEventObserver()获得LifecycleEventObserver实例，与状态State通过ObserverWithState捆绑实现了生命周期感知的主要逻辑。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:4","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"逻辑图谱 奉上最后的逻辑图谱供读者参考。 ","date":"2020-08-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:8:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Kotlin"],"content":"引言 Coroutine，一个线程框架，是建立在线程之上的API，用于让代码在各个线程之间反复横跳。 你只需要理解三个概念，就能理解协程： 调度器 挂起 并发 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:1:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"创建协程 协程创建格式 [CoroutineScope].[shift]([DisaptcherName]) { // 包内的代码称为协程 } CoroutineScope协程作用域 LaunchWay运行方式 DisaptcherName调度器名 首先，我们来创建一个协程 // Here are CurrentThread CoroutineScope.lanuch(Dispatchers.Main) { println(\"Hello! Coroutine\") } 注意， { println(\"Hello! Coroutine\") } 叫做协程，前面的CoroutineScope.lanuch(Dispatchers.Default)对协程而言，都只的参数。 这段代码做了什么呢？接下来这段话，请慢慢细读。 CorutineScope.launch是在CurrentThread里的执行的，它会让CurrentThread中开出一个新的协程 { println(\"Hello! Coroutine\") } 然后让调度器Dispatchers把这个协程调度到协程上下文Main所指代的线程中运行（Main指代主线程）。 这就提到我们第一个关键——调度器。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:2:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"调度器 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"原理 协程调度器名有： Dispatchers.Default Dispatchers.Main Dispatchers.IO Dispactchers.Unconfined 分别对应协程调度器： DefaultDisaptcher MainDispatcher IODispatcher UnconfinedDispatcher 分别调度到线程： BackgroundThread 适合CPU密集型。 MainThread 适合更新UI。 IOThread 适合I/O与网络请求。 CurrentThread 诶？你既然在当前线程了，直接写到当前线程下，不就好了吗？调度不是多此一举吗？注意，通过UnconfinedDispatcher调度过来的协程任务与普通的任务都区别在于，调度过来的任务会立即执行，且阻塞当前线程，只有调度过来的协程代码运行完，当前线程才会继续执行后续代码。 如图所示，我们在当前进程CurrentThread开出了多个协程Corotine，那么我们可以通过指定各个调度器名来指定使用对应的调度器，不同的调度器把协程调度到不同的线程上执行。 协程Coroutine1指定调度器名Dispatchers.Default，从而使用调度器DefaultDisaptcher将协程调度到BackgroundThread。 协程Coroutine2指定调度器名Dispatchers.Main，从而使用MainDispatcher将协程调度到MainThread。 协程Coroutine3指定调度器名Dispatchers.IO，从而使用IODispatcher将协程调度到IOThread。 协程Coroutine4指定调度器名Dispactchers.Unconfined，从而指定使用调度器UnconfinedDispatcher将协程调度到CurrentThread。 写成代码就是这样： // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { // Coroutine1 } CoroutineScope.lanuch(Disaptcher.Main) { // Coroutine2 } CoroutineScope.lanuch(Disaptcher.IO) { // Coroutine3 } CoroutineScope.lanuch(Disaptcher.Unconfined) { // Coroutine4 } ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"默认调度器 如果我们不写调度器， // Here are CurrentThread CoroutineScope.launch { // 第一处 CoroutineScope.launch { // 第二处 ... } } 就会默认使用父协程的调度器，第一处会被调度到当前线程，第二处会使用继承第一处，也被调度到当前线程。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"协程与线程 协程的运行方式分为两种： 非阻塞式——使用launch，不会卡住协程运行的线程。 阻塞式——使用runBlocking，会阻塞协程运行的线程。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"非阻塞式 在理解了调度器之后，我们来对比两段代码 不使用协程： // Here are CurrentThread task1() task2() task3() other() 使用协程： // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() task2() task3() } other() 后者的代码执行过程如图所示，通过CoroutineScope.launch(Disaptcher.Default)将协程 { task1() task2() task3() } 切换到BackgroundThread执行，当前线程该干嘛就干嘛，继续执行other()，与协程内容互不相关。 划重点：在协程被调度器调度到其他线程之后，协程就完全脱离当前线程，两者互不相关。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"阻塞式 阻塞式使用runBlocking来运行协程代码 CoroutineScope.launch(Disaptcher.Default) { runBlocking { task1() } task2() task3() } other() 他是用来霸占线程的，当我们运行上述代码，协程被运送到BackgroundThread，这里的runBlocking没有指定调度器，因此继承了父协程的上下文，也被调度到了BackgroundThread（联系上文默认调度器），那么runBlocking马上就像强盗一样霸占了BackgroundThread直到自己的协程 { task1() } 完成，BackgroundThread才能执行其他代码。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"分发到不同线程的执行顺序 刚才的代码，三个task都在同一个线程中运行，如果我想把他们放到不同的线程中运行呢？例如： task1()交给DefaultDisaptcher分发到BackgroundThread去执行。 task2()交给IODisaptcher分发到IOThread去执行。 task3()交给MainDisaptcher分发到MainThread去执行。 第一种写法 你可能首先想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() } CoroutineScope.lanuch(Disaptcher.IO){ task2() } CoroutineScope.lanuch(Disaptcher.Main){ task3() } 它的执行顺序是这样的 第二种写法 你可能会想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() CoroutineScope.lanuch(Disaptcher.IO){ task2() CoroutineScope.lanuch(Disaptcher.Main){ task3() } } } other() 它的执行顺序是这样的 第三种写法 你也可能想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() CoroutineScope.lanuch(Disaptcher.IO){ task2() } CoroutineScope.lanuch(Disaptcher.Main){ task3() } } other() 它的执行顺序是这样的 第四种写法（推荐） 使用withContext，顾名思义，根据当前的协程上下文来运行。例如： CoroutineScope.launch(Disaptcher.Default) { task1() withContext(Disaptcher.IO) { task2() } withContext(Disaptcher.Main) { task3() } } 上述代码的协程上下文为CoroutineScope，则其中的withContext相当于CoroutineScope.launch。 那是不是最外层也使用？像下述代码这样？ // Here are CurrentThread withContext(Disaptcher.Default) { withContext(...) { ... } } 答：无法使用。 我们刚才说了，根据当前协程上下文来运行，写在最外层，没有协程上下文，因此无法使用。 结论：withContext只能在协程中使用。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:3","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"挂起 { // Here are CurrentThread CoroutineScope.launch(Dispatchers.Default) { task1() task2() task3() task4() } other() } fun task1() { println(\"task1\") } suspend fun task2() { withContext(Dispatchers.IO) { println(\"task2\") } } suspend fun task3() { withContext(Dispatchers.Main) { println(\"task3\") } } fun task4() { println(\"task4\") } 首先，你想象自己拿着四封任务函，当前线程就是你的Boss。Boss只知道，首先去Disaptcher.Default窗口找BackgroundThread。于是指示你说：“去Disaptcher.Default窗口找BackgroundThread办理吧”。然后Boss就去处理other()任务，你则去处理这四封任务函。 我们到了Disaptcher.Default窗口排队，BackgroundThread看了看task1()，确认是自己的业务，就办完了并给task1()盖上终章。 但是task2()标明了suspend，表明要换一个窗口，但你并不知道要换哪一个，然后BackgroundThread拆开任务函，看到写着Disaptcher.IO，告诉你到Disaptcher.IO找IOThread办理，临走时他千叮咛万嘱咐，办理完了记得一定要回来找他，每张任务单都最后都需要第一个经手的业务人员盖章。你连连点头。 于是你暂时离开了BackgroundThread，BackgroundThread继续处理排在你后面的人的业务。而你又来到Disaptcher.IO窗口排队，IOThread看到task2()确实是自己的业务，就完成了，你赶紧回到了Disaptcher.Default找BackgroundThread，不过要重新排队。 终于轮到你了，BackgroundThread给task2()盖上终章，然后看了看你下一张任务单task3()标记着suspend，没错，又需要换个窗口，他又拆开任务函，看到写着Disaptcher.Main。他又指示你去Disaptcher.Main窗口找MainThread。临走前，他又嘱咐你办完后一定要回来。于是你又到Disaptcher.Main窗口找MainThread，MainThread完成了task3()。你赶紧回到了Disaptcher.Default窗口找BackgroundThread，不过又要重新排队。 终于轮到你了，BackgroundThread给task3()盖上终章，最后一个任务task4()没有suspend，BackgroundThread完成了task4()，并给task4()盖上了终章。 你的所有任务终于完成了！ 这个过程如下 你每次离开BakcgroundThread都过程就叫挂起Suspend，也就是暂时离开，BakcgroundThread在你离开的期间会处理其他任务，而你办完事儿后要回到BakcgroundThread那里，这个回来的过程叫做恢复Resume。 相信学完挂起，你已经发现了协程存在的意义，他让本应通过各种“异步+回调”完成的代码用同步的方式写出来。 例如 requestName.callback { requestImage.callback { setInfo.callbakc{ ... } } } 这种回调地狱在协程中用同步的方式写出来，每一行可以看作是上一行的回调： CoroutineScope.launch { requestName() requestImage() setInfo() } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo() { withContext(Dispatchers.Main) { ... } } 而可以这么爽的原因，就是因为挂起和恢复。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:5:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"并发 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"async 再仔细看看上面那一段代码，有同学可能要问了，这个requestName()和requestImage()如果没有依赖关系，也可以并发进行呀！没错，协程也为各项任务提供了并发机制。 我们可以使用async来让协程并发工作。 CoroutineScope.launch { async { requestName() } async { requestImage() } setInfo() } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo() { withContext(Dispatchers.Main) { ... } } 通过上述修改，requestName()和requestImage()就能并发工作了，两个并发任务启动（注意，不是执行完毕，是启动），立刻会执行setInfo()。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"await 有同学又要问了，万一你的setInfo()依赖requestName()和requestImage()的结果，那不会有问题了吗？ 没错，所以这就需要我们的await()登场了。 CoroutineScope.launch { val result1 = async { requestName() } val result2 = async { requestImage() } setInfo(result1.await(), result2.await()) } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo(String name, String img) { withContext(Dispatchers.Main) { ... } } 我们为任务的执行结果添加上await()，协程就会等待并发任务执行完毕，再继续运行后续代码。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"惰性并发 有时候我们可能并不希望我们的并发任务立刻执行，那么我们就需要运用惰性并发。 CoroutineScope.launch { val result1 = async(start = CoroutineStart.LAZY) { requestName() } val result2 = async(start = CoroutineStart.LAZY) { requestImage() } result1.await() // await()启动 result2.start() // start()启动 setInfo(result1, rsult2) } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo(String name, String img) { withContext(Dispatchers.Main) { ... } } 我们通过async (start = CoroutineStart.LAZY)将任务变为惰性并发任务，惰性并发任务不会立刻运行，而是在两种情况下运行： result被await()，即其他任务需要他的结果时。 result被start()，即我们手动启动它时。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:3","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Android"],"content":"Module创建 使用Android Studio中的File\u003eNew\u003eNew Module创建Module Module类型 常用Module类型： Application Library Dynamic Delivery Instant Dynamic Delivery Application为主模块，我们需要将Library和Dynamic Delivery引入Application。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:0:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Aplication Application为主模块，是应用运行的入口模块，其他的模块被引入Application发挥作用。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:1:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Library Library是普通的子模块，是任何情况下，都会打包进入Application的库，。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:2:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Dynamic Delivery Dynamic Delivery是按需引入的库，根据是否开启onDemand特性来决定是否引入。 module2的AndroidManifest.xml \u003cdist:module dist:onDemand=\"false\"\u003e \u003c/dist:module\u003e module2的onDamand=\"false\"，表示关闭按需引入，模块会打包进入apk。 module3的onDamand=“true”，表示开启按需引入，模块不会打包进入apk，会以第三方库（:third_party）的形式存在云端，在应用运行过程中根据需要额外下载。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:3:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Core :module1、:module2、:module3共同构成共享核心代码库。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:4:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Instant Dynamic Delivery 图例中不包含Instant Dynamic Delivery，这是一种特殊的Dynamic Delivery。“Instant”直译为“瞬间”，你们记得应用商店里的快速启动App吗？Instant Dynamic Delivery写出来的Module就是它。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:5:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"为什么要引入Dynamic Delivery？ 80%的用户使用应用中20%的功能，这意味着你apk中打包的大部分功能对于大部分用户是闲置的，这就很浪费apk的大小空间。引入动态分发，就是为了将冗余的东西尽可能剔除，Library包含用户常用的20%的功能，剩余的模块交给Dynamic Delivery，在用户需要使用的时候再下载这些模块。 Module标注 :app为Application，它的build.gradle apply plugin:'com.android.application' :module1为Library,它的build.gradle使用 apply plugin:'com.android.library' :module2和module3为Dynamic Delivery，它们的build.gradle使用 apply plugin:'com.android.dynamic-feature' Module引入 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:6:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Application引入Library :app的build.gradle implemetation project(':module1') ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:7:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Application引入Dynamic Delivery :app的build.gradle dynamicFeatures = [':module2', ':module3'] Module运行 在Run/Debug Configuration的Dynamic features to deloy中选择动态添加的模块 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:8:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":" 前言：模块化开发系列旨在为读者建立起模块化的基本轮廓。 引入依赖库常用的有两种方式： api implementation 两者的区别，存在于传递依赖方面。 ","date":"2020-07-26","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/:0:0","tags":["Android"],"title":"Android地阶：模块化开发（一）——api与implementation","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/"},{"categories":["Android"],"content":"implementation 该依赖方式所依赖的库不会传递。 A implementation B B implementation C A无法使用C。 ","date":"2020-07-26","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/:1:0","tags":["Android"],"title":"Android地阶：模块化开发（一）——api与implementation","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/"},{"categories":["Android"],"content":"api 该依赖方式会传递所依赖的库。 A implementation B B api C A可以使用C。 ","date":"2020-07-26","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/:2:0","tags":["Android"],"title":"Android地阶：模块化开发（一）——api与implementation","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/"},{"categories":["Android"],"content":"Context直译为“上下文”。Android四大组件中最核心的便是Activity，Activity最核心的便是Context，Activity是Context的子类。那么他究竟做了什么使得他如此重要呢？ 阅读建议：您不需要记住那些方法的参数，我列举参数仅为方便您浏览，但您应当注意概念、方法名称以及标签，我所提到的概念也仅为协助您理解而不是公认的至理。您的阅读目标应当是了解Context的基本轮廓。 内容简述：我将对存储管理和Context组件做详细介绍，其他内容则一笔带过。这并不是偷懒，而是Context的内容太多，人们无法短时间内一下子接受太多知识，而且其他内容结合其他系列文章讲解更加合适。 存储管理 Android中主要的存储管理方式包括： 文件File 首选项Preferences 数据库Database Context分别为三者定义了模式常量、模式接口、入口抽象方法。（Tip：我之所以称之为入口抽象方法，是因为这些方法仅包含get、set、open、close的逻辑，并不提供具体的内部操作）。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:0:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"文件File ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"File模式常量 @IntDef(flag = true, prefix = { \"MODE_\" }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_APPEND, }) 常量的具体含义 // 默认的模式，创建的文件只可被调用它的应用程序或者其他拥有相同用户id的应用程序调用 public static final int MODE_PRIVATE = 0x0000; // 允许其他应用程序读取文件 public static final int MODE_WORLD_READABLE = 0x0001; // 允许其他应用程序写文件 public static final int MODE_WORLD_WRITEABLE = 0x0002; // 在文件末尾追加写入 public static final int MODE_APPEND = 0x8000; ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"File模式接口 @Retention(RetentionPolicy.SOURCE) public @interface FileMode {} ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"File入口抽象方法 私有文件 首先约定一个概念：私有，即当前应用程序拥有。例如，私有文件，即仅属于当前应用程序的文件。后续所写的私有都是这个涵义。 // 打开私有文件，用于文件读取 public abstract FileInputStream openFileInput(String name) throws FileNotFoundException; // 打开或创建与私有文件，用于文件写入 public abstract FileOutputStream openFileOutput( String name, FileMode int mode ) throws FileNotFoundException; // 获取私有文件 public abstract File getDataDir(); // 获取文件创建 public abstract File getFileStreamPath(String name); // 获取文件 public abstract File getFilesDir(); // 删除私有文件 public abstract boolean deleteFile(String name); // 获取私有文件的列表 public abstract String[] fileList(); // 检索或创建一个路径用于存放私有自定义文件 public abstract File getDir( String name, @FileMode int mode ); openFileOutput和getDir方法的参数@FileMode int mode使用了模式变量，根据传入的模式变量决定访问权限与访问方式。模式常量已在上文陈述。 注意getDataDir和getFilesDir，getDataDir应用范围为私有文件，而getFilesDir应用范围为文件系统中openFileOutput存储文件的目录。 外部存储 对于文件管理还包括外部存储。外部存储的定义较为广泛，它包括一些外置SD卡、共享存储空间，甚至是一些外部连接设备上的存储设备。不过好在，只要将这些挂载到Android系统中，Android系统就会为其设定路径，开发者可以很轻松地访问到他们。 // 获取外部文件 public abstract File getExternalFilesDir(@Nullable String type); // 获取外部文件的列表 public abstract File[] getExternalFilesDirs(String type); // 获取Obb类型文件 public abstract File getObbDir(); // 获取Obb类型文件的列表 public abstract File[] getObbDirs(); // 获取外部多媒体文件的列表 public abstract File[] getExternalMediaDirs(); getObbDir和getObbDirsObb，获取Obb类型文件。Obb类型文件在游戏App中经常用到，经常作为数据包。 缓存 // 获取缓存 public abstract File getCacheDir(); // 获取二进制缓存 public abstract File getCodeCacheDir(); // 获取应用预加载缓存 @SystemApi public abstract File getPreloadsFileCache(); // 获取外部存储的缓存 public abstract File[] getExternalCacheDirs(); // 获取外部存储的缓存的列表 public abstract File[] getExternalCacheDirs(); getPreloadsFileCache，获取应用预加载缓存。拥有@SystemApi,仅系统可用。由此可见，应用启动时并不是直接页面加载我们指定的一些数据，而是在加载前先通过getPreloadsFileCache加载了一些特定的缓存数据。 @SystemApi标记表示方法面向系统而非开发者，带有@SystemApi的方法将会对开发者隐藏，即开发者无法调用。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"首选项Preferences ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Preferences模式常量 @IntDef(flag = true, prefix = { \"MODE_\" }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_MULTI_PROCESS, }) 与File模式常量有相同之处，都拥有MODE_PRIVATE、MODE_WORLD_READABLE、MODE_WORLD_WRITEABLE，涵义也相同。不同是多了MODE_MULTI_PROCESS。 // 允许应用程序的多个进程写入相同的Preferences文件 @Deprecated public static final int MODE_MULTI_PROCESS = 0x0004; 注意，MODE_MULTI_PROCESS被打上了@Deprecated（即将弃用），这将意味着不久的将来它会被删除。因此，我们应当避免使用它。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Preferences模式接口 @Retention(RetentionPolicy.SOURCE) public @interface PreferencesMode {} ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Preferences入口抽象方法 // 通过文件名，检索并保存首选项文件的内容 public abstract SharedPreferences getSharedPreferences(String name, @PreferencesMode int mode); // 通过文件对象，检索并保存首选项文件的内容 public abstract SharedPreferences getSharedPreferences(File file, @PreferencesMode int mode); // 获取首选项文件 public abstract File getSharedPreferencesPath(String name); // 从给定的源Context中将已存在的首选项移到当前Context中 public abstract boolean moveSharedPreferencesFrom(Context sourceContext, String name); // 删除首选项文件 public abstract boolean deleteSharedPreferences(String name); // 重载首选项文件 public abstract void reloadSharedPreferences(); // 获取不备份的文件路径 public abstract File getNoBackupFilesDir(); getSharedPreferences的参数@PreferencesMode int mode使用了模式常量，根据传入的模式常量决定首选项的访问权限与访问方式。模式常量已在上文陈述。 我们注意到一个很特别的方法moveSharedPreferencesFrom(Context sourceContext, String name)，它能将首选项从一个Context移动到另一个Context，这是一种极为重要的操作。我们开篇说过， Android四大组件中最核心的便是Activity，Activity最核心的便是Context，Activity是Context的子类。因此，moveSharedPreferencesFrom(Context sourceContext, String name)意味着首选项可以在Activity之间进行传递，这无疑对Activity之间的数据共享尤为重要。 我们还注意到一个即将弃用的方法getSharedPrefsFile，我们发现它返回了getSharedPreferencesPath的执行结果。 @Deprecated public File getSharedPrefsFile(String name) { return getSharedPreferencesPath(name); } 这种兼容方式这是Android进行版本过渡的常用方法，为避免突如其来的弃用导致开发者不知道选择什么方法，便在过渡的1～2个版本中保留了即将弃用的方法，并在开发过程中提示开发者，使之快速找到新版本的方法。若以后我们要开发自己的移动操作系统的SDK，这种方式值得借鉴。 getNoBackupFilesDir，获取不备份的文件路径。Android能够通过BackupAgent对文件进行自动备份，而一些不需要备份的文件就可以放到无需备份文件的目录下，例如一些临时文件，我们可以通过getNoBackupFilesDir获取到存放无需备份文件的绝对路径，并将无需备份的文件存入其中。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"数据库Database ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Database模式常量 @IntDef(flag = true, prefix = { \"MODE_\" }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_ENABLE_WRITE_AHEAD_LOGGING, MODE_NO_LOCALIZED_COLLATORS, }) 与File、Preferences的模式常量有相同之处，都拥有MODE_PRIVATE、MODE_WORLD_READABLE、MODE_WORLD_WRITEABLE，涵义也相同。不同是MODE_MULTI_PROCESS与MODE_NO_LOCALIZED_COLLATORS。 涵义如下 // 数据库启用预写式日志 public static final int MODE_ENABLE_WRITE_AHEAD_LOGGING = 0x0008; // 数据库支持本地排序器 public static final int MODE_NO_LOCALIZED_COLLATORS = 0x0010; 预写式日志（WAL，Write-Ahead Logging）是在数据库写入数据之前，现将数据写入到日志中，这对于数据库通过日志记录恢复有着举足轻重的作用。 本地排序即排序过程中采取本地的排序规则，仍然建议各端数据库尽量使用相同的排序规则，否则数据库的开销很大。 这些都是数据库的知识，挖个坑，以后有机会再填。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Database模式接口 @Retention(RetentionPolicy.SOURCE) public @interface DatabaseMode {} ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Database入口抽象方法 // 打开或创建数据库对象 public abstract SQLiteDatabase openOrCreateDatabase( String name, @DatabaseMode int mode, CursorFactory factory ); // 从给定的源Context中将已存在的数据库对象移到当前Context中 public abstract boolean moveDatabaseFrom( Context sourceContext, String name ); // 获取数据库文件 public abstract File getDatabasePath(String name); // 删除数据库对象 public abstract boolean deleteDatabase(String name); // 获取私有数据库对象列表 public abstract String[] databaseList(); openOrCreateDatabase openOrCreateDatabase的参数@DatabaseMode int mode使用了模式常量，根据传入的模式常量决定数据库的访问权限和访问特性。模式常量已在上文陈述。 moveDatabaseFrom 相信你已经联想到了首选项中的moveSharedPreferencesFrom(Context sourceContext, String name)，不错，moveDatabaseFrom(Context sourceContext, String name)在这里也是同样的涵义，它允许Database对象在Context对象之间，也意味着在Activity之间传递。 Context与四大组件 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Activity Activity是Context的子类，Context定义了对Activity的启动操作。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:4:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"面向开发者的启动 单启动 提到启动Activity，最熟悉的莫过于startActivity这位老熟人。 // 启动Activity public abstract void startActivity( @RequiresPermission Intent intent ); 多启动 大多数场景下，我们往往一次只启动一个Activity，但是有些时候我需要同时启动多个Activity，就需要用到startActivities。 // 启动多个Activity public abstract void startActivities( @RequiresPermission Intent[] intents ); // public abstract void startActivities( @RequiresPermission Intent[] intents, Bundle options ); 获取回调数据 我们还可以通过startActivityForResult来获取回调数据，注意，这个方法仅支持Fragment和View。 // 获取启动Activity的回调 public void startActivityForResult( @NonNull String who, Intent intent, int requestCode, @Nullable Bundle options ) { throw new RuntimeException(\"This method is only implemented for Activity-based Contexts. \"+ \"Check canStartActivityForResult() before calling.\"); } ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:4:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"面向系统的启动 Activity的启动不仅面向开发者，还面向系统。 startActivityAsUser startActivityAsUser指定特定的用户来启动Activity @SystemApi public void startActivityAsUser( @RequiresPermission @NonNull Intent intent, @NonNull UserHandle user ) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:4:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Service Context定义了Service的启动、绑定、解绑、停止的基本操作。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:5:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"启动 启动服务 // 启动服务 public abstract ComponentName startService(Intent service); // 指定用户启动服务 public abstract ComponentName startServiceAsUser( Intent service, UserHandle user ); 启动前台服务 // 启动前台服务 public abstract ComponentName startForegroundService(Intent service); // 指定用户启动前台服务 public abstract ComponentName startForegroundServiceAsUser( Intent service, UserHandle user ); 停止服务 // 停止服务 public abstract boolean stopServiceAsUser(Intent service, UserHandle user); // 指定用户停止服务 public abstract boolean stopServiceAsUser(Intent service, UserHandle user); ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:5:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"绑定 绑定服务常量 @IntDef(flag = true, prefix = { \"BIND_\" }, value = { BIND_AUTO_CREATE, BIND_DEBUG_UNBIND, BIND_NOT_FOREGROUND, BIND_ABOVE_CLIENT, BIND_ALLOW_OOM_MANAGEMENT, BIND_WAIVE_PRIORITY, BIND_IMPORTANT, BIND_ADJUST_WITH_ACTIVITY, BIND_NOT_PERCEPTIBLE, BIND_INCLUDE_CAPABILITIES }) @Retention(RetentionPolicy.SOURCE) public @interface BindServiceFlags {} 绑定服务入口方法 // 绑定服务 public abstract boolean bindService( @RequiresPermission Intent service, @NonNull ServiceConnection conn, @BindServiceFlags int flags ); public boolean bindService( @RequiresPermission @NonNull Intent service, @BindServiceFlags int flags, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn ) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } // 指定用户绑定服务 @SystemApi public boolean bindServiceAsUser( @RequiresPermission Intent service, ServiceConnection conn, int flags, UserHandle user) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } public boolean bindServiceAsUser( Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } // 多个服务实例绑定单个组件 public boolean bindIsolatedService( @RequiresPermission @NonNull Intent service, @BindServiceFlags int flags, @NonNull String instanceName, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn ) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } // 更新服务组（包含bindIsolatedService相关的多个服务实例） public void updateServiceGroup( @NonNull ServiceConnection conn, int group, int importance) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } 解绑 public abstract void unbindService(@NonNull ServiceConnection conn); 绑定用到的参数@BindServiceFlags int flags需要使用到绑定常量，这将决定服务与Context的绑定的方式。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:5:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Broadcast Receiver Conext定义了Broadcast Receiver的接收、注册、接收的基本操作。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"接收 允许接收广播需要执行IntentSensor。 允许接收 通过startIntentSender执行IntentSensor： public abstract void startIntentSender( IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues,int extraFlags ) throws IntentSender.SendIntentException; public abstract void startIntentSender( IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues, int extraFlags, @Nullable Bundle options ) throws IntentSender.SendIntentException; ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"注册 注册广播 public abstract Intent registerReceiver( @Nullable BroadcastReceiver receiver, IntentFilter filter ); public abstract Intent registerReceiver( @Nullable BroadcastReceiver receiver, IntentFilter filter, @RegisterReceiverFlags int flags ); public abstract Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler ); public abstract Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags ); // 指定用户注册广播 public abstract Intent registerReceiverAsUser( BroadcastReceiver receiver, UserHandle user, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler ); registerReceiver 注册广播。 registerReceiverAsUser 指定用户注册广播 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"注销广播 public abstract void unregisterReceiver(BroadcastReceiver receiver); unregisterReceiver 用于注销广播 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"发送 无序广播 // 无序广播 @SystemApi public abstract void sendBroadcast( Intent intent, @Nullable String receiverPermission, @Nullable Bundle options ); public abstract void sendBroadcast( Intent intent, String receiverPermission, int appOp ); // 指定用户无序广播 public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user ); public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission ); @SystemApi public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, @Nullable Bundle options ); public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp ); sendBroadcast 无序广播 sendBroadcastAsUser 指定用户无序广播 有序广播 // 有序广播 public abstract void sendOrderedBroadcast( @RequiresPermission Intent intent, @Nullable String receiverPermission ); public abstract void sendOrderedBroadcast( @RequiresPermission @NonNull Intent intent, @Nullable String receiverPermission, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); // 指定用户有序广播 public abstract void sendOrderedBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); public abstract void sendOrderedBroadcastAsUser( Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); public abstract void sendOrderedBroadcastAsUser( Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, @Nullable Bundle options, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); sendOrderedBroadcast 有序广播 sendOrderedBroadcastAsUser 指定用户有序广播 强制广播 // 强制权限数组中权限被准许，并向所有相关的广播接收器发送广播 public abstract void sendBroadcastMultiplePermissions( Intent intent, String[] receiverPermissions ); // 对于指定用户，强制权限数组中权限被准许，并向所有相关的广播接收器发送广播 public abstract void sendBroadcastAsUserMultiplePermissions( Intent intent, UserHandle user, String[] receiverPermissions ); sendBroadcastMultiplePermissions与sendBroadcastAsUserMultiplePermissions全被隐藏（注释中带有@hide），开发者无法调用。 @hide意味着该方法对开发者不可见，即开发者无法调用。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:4","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Notification Context与Notification无直接关联。 其他 Context还包括其他一些格外重要的内容，但本章仅作简述，不铺陈开。这些内容将在另一系列的章节中详细陈述，你现在仅需要知道他们的存在。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:7:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"权限管理 public abstract PackageManager getPackageManager(); ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:8:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"消息管理 public abstract Looper getMainLooper(); ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:9:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"资源管理 public abstract AssetManager getAssets(); public abstract Resources getResources(); 总结 Context是个大熔炉，一切都在这里汇聚，组件关联、存储管理、权限管理、消息管理、资源管理等等。 也许您会有以下疑问，Context为什么涉及这么多？PackageManager为什么跟权限有关？Looper为什么跟消息管理有关？资源管理为什么有两块？您当然可以自行检索答案，在未来不久的日子我也会更新相关的知识模块供您参考。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:10:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"在我们写Activity的时候，很多方法需要传入参数Context，官方文档告诉我们传入this。 为什么可以传入this？this不是Activity？为什么Context参数可以是Activity？你猜的没错，Activity就是Context的子类，其中还蕴涵着一套“套娃”。 后续几个篇章，Neville就带大家一起学习这组“套娃”，彻底透析源码。 套娃层次 先呈上一组继承关系 class AppCompatActivity : FragmentActivity {...} class FragmentActivity : ComponentActivity {...} class ComponentActivity : Activity {...} class Activity : ContextThemeWrapper {...} class ContextThemeWrapper : ContextWrapper {...} class ContextWrapper : Context {...} 发现套娃链路： AppCompatActivity =\u003eFragmentActivity =\u003eComponentActivity =\u003eActivity =\u003eContextThemeWrapper =\u003eContextWrapper =\u003eContext 我们的七位葫芦娃闪亮登场，让我们向他们打个招呼吧！ Context：上下文抽象类，实现了逻辑实现。 ContextWrapper：对Context进行打包，并实现Context中的抽象方法。 ContextThemeWrapper ：在ContextWrapper基础上，引入了对主题资源的打包。 Activity：最基础的活动组件类。 ComponentActivity： FragmentActivity： AppComatActivity：实现了对低版本API对兼容，是Android Studio中创建组件Activity时的默认类型。 在后续的篇章中，让我们与他们深入交流～ ","date":"2020-07-20","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%B8%80%E5%A5%97%E5%A8%83/:0:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（一）——套娃","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%B8%80%E5%A5%97%E5%A8%83/"},{"categories":["Kotlin"],"content":"内联扩展函数是啥玩意儿？答：Kotlin为你打包好的工具包。 如果说Java是一条龙服务，那Koltin就是在一条龙之外还提供了“内联函数”这种免费附赠服务。就好比你买膜，Java只给了你膜，而Kotlin还给了你贴膜工具包，让贴膜的过程无比丝滑。丝滑如下： lambda简化 写过Android的小伙伴肯定认识这样一位软妹OnClickListener， 用Java写是这样的 button.setOnClickListener(new OnClickListener { @Override public void OnClick(View v) { // to do } }) 用Kotlin写是这样的 button.setOnClickListener(object:OnClickListener{ override fun OnClick(v: View?) { // to do } }) 然后呈上我们的“Kotlin+lambda”魔幻大法，它就变成了这样 button.setOnClickListener { v-\u003e // to do } 如果你连OnClick的参数View在to do时都用不到，你甚至可以不写 button.setOnClickListener { // to do } 不仅如此，想用的时候，可以用it来代替参数View（因为只有一个参数，所以可以用it替代，因为it是单参数的隐式名称）。这就像曾经有一份爱情View在你面前，你没有去表达，当你回头想起，你还可以用it来替代View所留下的空白（所以View只是过客，it才是真爱）。 button.setOnClickListener { println(it.id) } 相信很多小伙伴已经懵了，这是什么操作？这叫“一夫一妻制”（我乱起的，别瞎记），如果一个接口只有一个抽象方法，你就可以享受这种服务，多个抽象方法不行。毕竟一夫一妻的时候，你喊一下老婆，谁都知道你在喊谁，但是在一夫多妻制下，呵，还真不知道你喊的是哪一位老婆… 如果这个抽象方法有多个参数怎么办？来，让我们继续魔幻，拿OnEditorActionListener举例 textView.setOnEditorActionListener( object: TextView.OnEditorActionListener { override fun onEditorAction(v: TextView?, actionId: Int, event: KeyEvent?): Boolean { // to do something } }) 他有三个参数v: TextView?, actionId: Int, event: KeyEvent?，取参数名拿逗号隔开即可 textView.setOnEditorActionListener { v, actionId, event -\u003e // to do something } let 写过ES6标准JS的童鞋是不是很熟悉。 作者：你懂我意思吗？ 童鞋：我懂你意思。 （眉目传情ing） 作者：不，你不懂。 let有Kotlin里没用来声明块级作用域内的变量的作用。var在JS里是花花公子，毫无规矩到处沾花惹草，但在Kotlin里已经变成了专注于自身块级作用域的好男人，好男人一个就够了，所以let就去干其他事儿了。什么事儿？简化单对象连续操作代码。 我们经常要初始化一些对象的属性，就会出现下面这种连写的情况 student.setId(id) student.setName(name) student.setAge(age) grade = student.grade 每次初始化设置属性，我们都要写个studnet.然后后接方法，太累了。于是let就闪亮登场了，有了let，你可以用它画个圈圈，然后用it指代你要操作的对象，在这个圈圈里完成对公有属性和公有方法对操作。 student.let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade } 这是什么魔力？没错，这就是爱的魔力，我们可以称之为“转圈圈”（这也是我乱起的，别瞎记）。 你还可以加个问号，用于判空，当student为空的时候，就不会执行let中的代码 student?.let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade } 至于返回值，let会以闭包的形式返回返回值。你可以中途用return表达式，中途没执行return的话会返回最后一行。 var result = let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade 1 // 前面没执行return，则最后一行为作为返回值，这里返回值为1 }) with 你以为let的操作已经最骚了？不，没有最骚，只有更骚。 with不仅可以连操，还可以省略it。 var result = with(student, { setId(id) }) 不过不能像let那样判空。 run 你以为with的操作已经最骚了？Again，没有最骚，只有更骚。 在let和with面前，run就是个儿子。我不是说他菜，恰恰相反，他遗传了父母的优良基因，融合了let的语法和with的神仙操作，可承受男女混合双打，可称之为“塞尔维亚妖王”（我真的是乱起的，你们别瞎记啊）。 run的语法和let一样，可以判空 student.run {} // 不判空 student?.run {} // 判空 圈圈里的写法跟with一样：不需要it。 var result = student?.run { // to do something 1 // 最后一行为返回值，返回值为1 } 综上所述，run比let和with更好用，如果你们的技术总监同意的话，你甚至可以肆意地使用run来替代let和with。相对于let他不需要it，相对于with他增加了判空，实乃集两者之精华。 apply 如果说run是let和with的爸爸的话，那么apply就是run的兄弟。这俩语法一样，唯一不同的是返回值。run比较花心，各种返回值都能返回；apply比较专情，只返回自身对象。没错，无论你怎么搞他，他都只返回自身对象。 所以run几乎啥场景都能用，而apply比较适合对象修改后又赋值给自身的场景。 also also的语法和let一样，但是also返回的是当前对象，而let返回的是闭包。是不是跟apply和run的关系很像。 总结 let，返回闭包，可判空，要用it with，返回闭包，不可判空，省略it run，返回闭包，集let与with之大成，可判空，省略it apply与run一样，但是apply返回当前对象；also与let一样，但是also返回当前对象。 本章结束，完结撒花花～ ","date":"2020-07-15","objectID":"/kotlin%E9%AB%98%E7%BA%A7lambda%E4%B8%8E%E6%89%A9%E5%B1%95%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:0:0","tags":["Kotlin"],"title":"Kotlin高级：lambda与扩展内联函数","uri":"/kotlin%E9%AB%98%E7%BA%A7lambda%E4%B8%8E%E6%89%A9%E5%B1%95%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"}]