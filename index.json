[{"categories":["Kotlin"],"content":"引言 Coroutine，一个线程框架，是建立在线程之上的API，用于让代码在各个线程之间反复横跳。 你只需要理解三个概念，就能理解协程： 调度器 挂起 并发 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:1:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"创建协程 协程创建格式 [CoroutineScope].[shift]([DisaptcherName]) { // 包内的代码称为协程 } CoroutineScope协程作用域 LaunchWay运行方式 DisaptcherName调度器名 首先，我们来创建一个协程 // Here are CurrentThread CoroutineScope.lanuch(Dispatchers.Main) { println(\"Hello! Coroutine\") } 注意， { println(\"Hello! Coroutine\") } 叫做协程，前面的CoroutineScope.lanuch(Dispatchers.Default)对协程而言，都只的参数。 这段代码做了什么呢？接下来这段话，请慢慢细读。 CorutineScope.launch是在CurrentThread里的执行的，它会让CurrentThread中开出一个新的协程 { println(\"Hello! Coroutine\") } 然后让调度器Dispatchers把这个协程调度到协程上下文Main所指代的线程中运行（Main指代主线程）。 这就提到我们第一个关键——调度器。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:2:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"调度器 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"原理 协程调度器名有： Dispatchers.Default Dispatchers.Main Dispatchers.IO Dispactchers.Unconfined 分别对应协程调度器： DefaultDisaptcher MainDispatcher IODispatcher UnconfinedDispatcher 分别调度到线程： BackgroundThread 适合CPU密集型。 MainThread 适合更新UI。 IOThread 适合I/O与网络请求。 CurrentThread 诶？你既然在当前线程了，直接写到当前线程下，不就好了吗？调度不是多此一举吗？注意，通过UnconfinedDispatcher调度过来的协程任务与普通的任务都区别在于，调度过来的任务会立即执行，且阻塞当前线程，只有调度过来的协程代码运行完，当前线程才会继续执行后续代码。 如图所示，我们在当前进程CurrentThread开出了多个协程Corotine，那么我们可以通过指定各个调度器名来指定使用对应的调度器，不同的调度器把协程调度到不同的线程上执行。 协程Coroutine1指定调度器名Dispatchers.Default，从而使用调度器DefaultDisaptcher将协程调度到BackgroundThread。 协程Coroutine2指定调度器名Dispatchers.Main，从而使用MainDispatcher将协程调度到MainThread。 协程Coroutine3指定调度器名Dispatchers.IO，从而使用IODispatcher将协程调度到IOThread。 协程Coroutine4指定调度器名Dispactchers.Unconfined，从而指定使用调度器UnconfinedDispatcher将协程调度到CurrentThread。 写成代码就是这样： // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { // Coroutine1 } CoroutineScope.lanuch(Disaptcher.Main) { // Coroutine2 } CoroutineScope.lanuch(Disaptcher.IO) { // Coroutine3 } CoroutineScope.lanuch(Disaptcher.Unconfined) { // Coroutine4 } ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"默认调度器 如果我们不写调度器， // Here are CurrentThread CoroutineScope.launch { // 第一处 CoroutineScope.launch { // 第二处 ... } } 就会默认使用父协程的调度器，第一处会被调度到当前线程，第二处会使用继承第一处，也被调度到当前线程。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:3:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"协程与线程 协程的运行方式分为两种： 非阻塞式——使用launch，不会卡住协程运行的线程。 阻塞式——使用runBlocking，会阻塞协程运行的线程。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"非阻塞式 在理解了调度器之后，我们来对比两段代码 不使用协程： // Here are CurrentThread task1() task2() task3() other() 使用协程： // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() task2() task3() } other() 后者的代码执行过程如图所示，通过CoroutineScope.launch(Disaptcher.Default)将协程 { task1() task2() task3() } 切换到BackgroundThread执行，当前线程该干嘛就干嘛，继续执行other()，与协程内容互不相关。 划重点：在协程被调度器调度到其他线程之后，协程就完全脱离当前线程，两者互不相关。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"阻塞式 阻塞式使用runBlocking来运行协程代码 CoroutineScope.launch(Disaptcher.Default) { runBlocking { task1() } task2() task3() } other() 他是用来霸占线程的，当我们运行上述代码，协程被运送到BackgroundThread，这里的runBlocking没有指定调度器，因此继承了父协程的上下文，也被调度到了BackgroundThread（联系上文默认调度器），那么runBlocking马上就像强盗一样霸占了BackgroundThread直到自己的协程 { task1() } 完成，BackgroundThread才能执行其他代码。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"分发到不同线程的执行顺序 刚才的代码，三个task都在同一个线程中运行，如果我想把他们放到不同的线程中运行呢？例如： task1()交给DefaultDisaptcher分发到BackgroundThread去执行。 task2()交给IODisaptcher分发到IOThread去执行。 task3()交给MainDisaptcher分发到MainThread去执行。 第一种写法 你可能首先想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() } CoroutineScope.lanuch(Disaptcher.IO){ task2() } CoroutineScope.lanuch(Disaptcher.Main){ task3() } 它的执行顺序是这样的 第二种写法 你可能会想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() CoroutineScope.lanuch(Disaptcher.IO){ task2() CoroutineScope.lanuch(Disaptcher.Main){ task3() } } } other() 它的执行顺序是这样的 第三种写法 你也可能想到这样写 // Here are CurrentThread CoroutineScope.launch(Disaptcher.Default) { task1() CoroutineScope.lanuch(Disaptcher.IO){ task2() } CoroutineScope.lanuch(Disaptcher.Main){ task3() } } other() 它的执行顺序是这样的 第四种写法（推荐） 使用withContext，顾名思义，根据当前的协程上下文来运行。例如： CoroutineScope.launch(Disaptcher.Default) { task1() withContext(Disaptcher.IO) { task2() } withContext(Disaptcher.Main) { task3() } } 上述代码的协程上下文为CoroutineScope，则其中的withContext相当于CoroutineScope.launch。 那是不是最外层也使用？像下述代码这样？ // Here are CurrentThread withContext(Disaptcher.Default) { withContext(...) { ... } } 答：无法使用。 我们刚才说了，根据当前协程上下文来运行，写在最外层，没有协程上下文，因此无法使用。 结论：withContext只能在协程中使用。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:4:3","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"挂起 { // Here are CurrentThread CoroutineScope.launch(Dispatchers.Default) { task1() task2() task3() task4() } other() } fun task1() { println(\"task1\") } suspend fun task2() { withContext(Dispatchers.IO) { println(\"task2\") } } suspend fun task3() { withContext(Dispatchers.Main) { println(\"task3\") } } fun task4() { println(\"task4\") } 首先，你想象自己拿着四封任务函，当前线程就是你的Boss。Boss只知道，首先去Disaptcher.Default窗口找BackgroundThread。于是指示你说：“去Disaptcher.Default窗口找BackgroundThread办理吧”。然后Boss就去处理other()任务，你则去处理这四封任务函。 我们到了Disaptcher.Default窗口排队，BackgroundThread看了看task1()，确认是自己的业务，就办完了并给task1()盖上终章。 但是task2()标明了suspend，表明要换一个窗口，但你并不知道要换哪一个，然后BackgroundThread拆开任务函，看到写着Disaptcher.IO，告诉你到Disaptcher.IO找IOThread办理，临走时他千叮咛万嘱咐，办理完了记得一定要回来找他，每张任务单都最后都需要第一个经手的业务人员盖章。你连连点头。 于是你暂时离开了BackgroundThread，BackgroundThread继续处理排在你后面的人的业务。而你又来到Disaptcher.IO窗口排队，IOThread看到task2()确实是自己的业务，就完成了，你赶紧回到了Disaptcher.Default找BackgroundThread，不过要重新排队。 终于轮到你了，BackgroundThread给task2()盖上终章，然后看了看你下一张任务单task3()标记着suspend，没错，又需要换个窗口，他又拆开任务函，看到写着Disaptcher.Main。他又指示你去Disaptcher.Main窗口找MainThread。临走前，他又嘱咐你办完后一定要回来。于是你又到Disaptcher.Main窗口找MainThread，MainThread完成了task3()。你赶紧回到了Disaptcher.Default窗口找BackgroundThread，不过又要重新排队。 终于轮到你了，BackgroundThread给task3()盖上终章，最后一个任务task4()没有suspend，BackgroundThread完成了task4()，并给task4()盖上了终章。 你的所有任务终于完成了！ 这个过程如下 你每次离开BakcgroundThread都过程就叫挂起Suspend，也就是暂时离开，BakcgroundThread在你离开的期间会处理其他任务，而你办完事儿后要回到BakcgroundThread那里，这个回来的过程叫做恢复Resume。 相信学完挂起，你已经发现了协程存在的意义，他让本应通过各种“异步+回调”完成的代码用同步的方式写出来。 例如 requestName.callback { requestImage.callback { setInfo.callbakc{ ... } } } 这种回调地狱在协程中用同步的方式写出来，每一行可以看作是上一行的回调： CoroutineScope.launch { requestName() requestImage() setInfo() } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo() { withContext(Dispatchers.Main) { ... } } 而可以这么爽的原因，就是因为挂起和恢复。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:5:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"并发 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:0","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"async 再仔细看看上面那一段代码，有同学可能要问了，这个requestName()和requestImage()如果没有依赖关系，也可以并发进行呀！没错，协程也为各项任务提供了并发机制。 我们可以使用async来让协程并发工作。 CoroutineScope.launch { async { requestName() } async { requestImage() } setInfo() } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo() { withContext(Dispatchers.Main) { ... } } 通过上述修改，requestName()和requestImage()就能并发工作了，两个并发任务启动（注意，不是执行完毕，是启动），立刻会执行setInfo()。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:1","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"await 有同学又要问了，万一你的setInfo()依赖requestName()和requestImage()的结果，那不会有问题了吗？ 没错，所以这就需要我们的await()登场了。 CoroutineScope.launch { val result1 = async { requestName() } val result2 = async { requestImage() } setInfo(result1.await(), result2.await()) } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo(String name, String img) { withContext(Dispatchers.Main) { ... } } 我们为任务的执行结果添加上await()，协程就会等待并发任务执行完毕，再继续运行后续代码。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:2","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Kotlin"],"content":"惰性并发 有时候我们可能并不希望我们的并发任务立刻执行，那么我们就需要运用惰性并发。 CoroutineScope.launch { val result1 = async(start = CoroutineStart.LAZY) { requestName() } val result2 = async(start = CoroutineStart.LAZY) { requestImage() } result1.await() // await()启动 result2.start() // start()启动 setInfo(result1, rsult2) } suspend fun requestName() { withContext(Dispatchers.IO) { ... } } suspend fun requestImage() { withContext(Dispatchers.IO) { ... } } suspend fun setInfo(String name, String img) { withContext(Dispatchers.Main) { ... } } 我们通过async (start = CoroutineStart.LAZY)将任务变为惰性并发任务，惰性并发任务不会立刻运行，而是在两种情况下运行： result被await()，即其他任务需要他的结果时。 result被start()，即我们手动启动它时。 ","date":"2020-07-30","objectID":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/:6:3","tags":["Kotlin"],"title":"Kotlin高级：协程","uri":"/kotlin%E9%AB%98%E7%BA%A7%E5%8D%8F%E7%A8%8B/"},{"categories":["Android"],"content":"Module创建 使用Android Studio中的File\u003eNew\u003eNew Module创建Module Module类型 常用Module类型： Application Library Dynamic Delivery Instant Dynamic Delivery Application为主模块，我们需要将Library和Dynamic Delivery引入Application。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:0:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Aplication Application为主模块，是应用运行的入口模块，其他的模块被引入Application发挥作用。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:1:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Library Library是普通的子模块，是任何情况下，都会打包进入Application的库，。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:2:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Dynamic Delivery Dynamic Delivery是按需引入的库，根据是否开启onDemand特性来决定是否引入。 module2的AndroidManifest.xml \u003cdist:module dist:onDemand=\"false\"\u003e \u003c/dist:module\u003e module2的onDamand=\"false\"，表示关闭按需引入，模块会打包进入apk。 module3的onDamand=“true”，表示开启按需引入，模块不会打包进入apk，会以第三方库（:third_party）的形式存在云端，在应用运行过程中根据需要额外下载。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:3:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Core :module1、:module2、:module3共同构成共享核心代码库。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:4:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Instant Dynamic Delivery 图例中不包含Instant Dynamic Delivery，这是一种特殊的Dynamic Delivery。“Instant”直译为“瞬间”，你们记得应用商店里的快速启动App吗？Instant Dynamic Delivery写出来的Module就是它。 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:5:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"为什么要引入Dynamic Delivery？ 80%的用户使用应用中20%的功能，这意味着你apk中打包的大部分功能对于大部分用户是闲置的，这就很浪费apk的大小空间。引入动态分发，就是为了将冗余的东西尽可能剔除，Library包含用户常用的20%的功能，剩余的模块交给Dynamic Delivery，在用户需要使用的时候再下载这些模块。 Module标注 :app为Application，它的build.gradle apply plugin:'com.android.application' :module1为Library,它的build.gradle使用 apply plugin:'com.android.library' :module2和module3为Dynamic Delivery，它们的build.gradle使用 apply plugin:'com.android.dynamic-feature' Module引入 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:6:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Application引入Library :app的build.gradle implemetation project(':module1') ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:7:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":"Application引入Dynamic Delivery :app的build.gradle dynamicFeatures = [':module2', ':module3'] Module运行 在Run/Debug Configuration的Dynamic features to deloy中选择动态添加的模块 ","date":"2020-07-27","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/:8:0","tags":["Android"],"title":"Android地阶：模块化开发（二）——Module","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%BA%8Cmodule/"},{"categories":["Android"],"content":" 前言：模块化开发系列旨在为读者建立起模块化的基本轮廓。 引入依赖库常用的有两种方式： api implementation 两者的区别，存在于传递依赖方面。 ","date":"2020-07-26","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/:0:0","tags":["Android"],"title":"Android地阶：模块化开发（一）——api与implementation","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/"},{"categories":["Android"],"content":"implementation 该依赖方式所依赖的库不会传递。 A implementation B B implementation C A无法使用C。 ","date":"2020-07-26","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/:1:0","tags":["Android"],"title":"Android地阶：模块化开发（一）——api与implementation","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/"},{"categories":["Android"],"content":"api 该依赖方式会传递所依赖的库。 A implementation B B api C A可以使用C。 ","date":"2020-07-26","objectID":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/:2:0","tags":["Android"],"title":"Android地阶：模块化开发（一）——api与implementation","uri":"/android%E5%9C%B0%E9%98%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%80api%E4%B8%8Eimplementation/"},{"categories":["Android"],"content":"Context直译为“上下文”。Android四大组件中最核心的便是Activity，Activity最核心的便是Context，Activity是Context的子类。那么他究竟做了什么使得他如此重要呢？ 阅读建议：您不需要记住那些方法的参数，我列举参数仅为方便您浏览，但您应当注意概念、方法名称以及标签，我所提到的概念也仅为协助您理解而不是公认的至理。您的阅读目标应当是了解Context的基本轮廓。 内容简述：我将对存储管理和Context组件做详细介绍，其他内容则一笔带过。这并不是偷懒，而是Context的内容太多，人们无法短时间内一下子接受太多知识，而且其他内容结合其他系列文章讲解更加合适。 存储管理 Android中主要的存储管理方式包括： 文件File 首选项Preferences 数据库Database Context分别为三者定义了模式常量、模式接口、入口抽象方法。（Tip：我之所以称之为入口抽象方法，是因为这些方法仅包含get、set、open、close的逻辑，并不提供具体的内部操作）。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:0:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"文件File ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"File模式常量 @IntDef(flag = true, prefix = { \"MODE_\" }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_APPEND, }) 常量的具体含义 // 默认的模式，创建的文件只可被调用它的应用程序或者其他拥有相同用户id的应用程序调用 public static final int MODE_PRIVATE = 0x0000; // 允许其他应用程序读取文件 public static final int MODE_WORLD_READABLE = 0x0001; // 允许其他应用程序写文件 public static final int MODE_WORLD_WRITEABLE = 0x0002; // 在文件末尾追加写入 public static final int MODE_APPEND = 0x8000; ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"File模式接口 @Retention(RetentionPolicy.SOURCE) public @interface FileMode {} ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"File入口抽象方法 私有文件 首先约定一个概念：私有，即当前应用程序拥有。例如，私有文件，即仅属于当前应用程序的文件。后续所写的私有都是这个涵义。 // 打开私有文件，用于文件读取 public abstract FileInputStream openFileInput(String name) throws FileNotFoundException; // 打开或创建与私有文件，用于文件写入 public abstract FileOutputStream openFileOutput( String name, FileMode int mode ) throws FileNotFoundException; // 获取私有文件 public abstract File getDataDir(); // 获取文件创建 public abstract File getFileStreamPath(String name); // 获取文件 public abstract File getFilesDir(); // 删除私有文件 public abstract boolean deleteFile(String name); // 获取私有文件的列表 public abstract String[] fileList(); // 检索或创建一个路径用于存放私有自定义文件 public abstract File getDir( String name, @FileMode int mode ); openFileOutput和getDir方法的参数@FileMode int mode使用了模式变量，根据传入的模式变量决定访问权限与访问方式。模式常量已在上文陈述。 注意getDataDir和getFilesDir，getDataDir应用范围为私有文件，而getFilesDir应用范围为文件系统中openFileOutput存储文件的目录。 外部存储 对于文件管理还包括外部存储。外部存储的定义较为广泛，它包括一些外置SD卡、共享存储空间，甚至是一些外部连接设备上的存储设备。不过好在，只要将这些挂载到Android系统中，Android系统就会为其设定路径，开发者可以很轻松地访问到他们。 // 获取外部文件 public abstract File getExternalFilesDir(@Nullable String type); // 获取外部文件的列表 public abstract File[] getExternalFilesDirs(String type); // 获取Obb类型文件 public abstract File getObbDir(); // 获取Obb类型文件的列表 public abstract File[] getObbDirs(); // 获取外部多媒体文件的列表 public abstract File[] getExternalMediaDirs(); getObbDir和getObbDirsObb，获取Obb类型文件。Obb类型文件在游戏App中经常用到，经常作为数据包。 缓存 // 获取缓存 public abstract File getCacheDir(); // 获取二进制缓存 public abstract File getCodeCacheDir(); // 获取应用预加载缓存 @SystemApi public abstract File getPreloadsFileCache(); // 获取外部存储的缓存 public abstract File[] getExternalCacheDirs(); // 获取外部存储的缓存的列表 public abstract File[] getExternalCacheDirs(); getPreloadsFileCache，获取应用预加载缓存。拥有@SystemApi,仅系统可用。由此可见，应用启动时并不是直接页面加载我们指定的一些数据，而是在加载前先通过getPreloadsFileCache加载了一些特定的缓存数据。 @SystemApi标记表示方法面向系统而非开发者，带有@SystemApi的方法将会对开发者隐藏，即开发者无法调用。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:1:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"首选项Preferences ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Preferences模式常量 @IntDef(flag = true, prefix = { \"MODE_\" }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_MULTI_PROCESS, }) 与File模式常量有相同之处，都拥有MODE_PRIVATE、MODE_WORLD_READABLE、MODE_WORLD_WRITEABLE，涵义也相同。不同是多了MODE_MULTI_PROCESS。 // 允许应用程序的多个进程写入相同的Preferences文件 @Deprecated public static final int MODE_MULTI_PROCESS = 0x0004; 注意，MODE_MULTI_PROCESS被打上了@Deprecated（即将弃用），这将意味着不久的将来它会被删除。因此，我们应当避免使用它。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Preferences模式接口 @Retention(RetentionPolicy.SOURCE) public @interface PreferencesMode {} ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Preferences入口抽象方法 // 通过文件名，检索并保存首选项文件的内容 public abstract SharedPreferences getSharedPreferences(String name, @PreferencesMode int mode); // 通过文件对象，检索并保存首选项文件的内容 public abstract SharedPreferences getSharedPreferences(File file, @PreferencesMode int mode); // 获取首选项文件 public abstract File getSharedPreferencesPath(String name); // 从给定的源Context中将已存在的首选项移到当前Context中 public abstract boolean moveSharedPreferencesFrom(Context sourceContext, String name); // 删除首选项文件 public abstract boolean deleteSharedPreferences(String name); // 重载首选项文件 public abstract void reloadSharedPreferences(); // 获取不备份的文件路径 public abstract File getNoBackupFilesDir(); getSharedPreferences的参数@PreferencesMode int mode使用了模式常量，根据传入的模式常量决定首选项的访问权限与访问方式。模式常量已在上文陈述。 我们注意到一个很特别的方法moveSharedPreferencesFrom(Context sourceContext, String name)，它能将首选项从一个Context移动到另一个Context，这是一种极为重要的操作。我们开篇说过， Android四大组件中最核心的便是Activity，Activity最核心的便是Context，Activity是Context的子类。因此，moveSharedPreferencesFrom(Context sourceContext, String name)意味着首选项可以在Activity之间进行传递，这无疑对Activity之间的数据共享尤为重要。 我们还注意到一个即将弃用的方法getSharedPrefsFile，我们发现它返回了getSharedPreferencesPath的执行结果。 @Deprecated public File getSharedPrefsFile(String name) { return getSharedPreferencesPath(name); } 这种兼容方式这是Android进行版本过渡的常用方法，为避免突如其来的弃用导致开发者不知道选择什么方法，便在过渡的1～2个版本中保留了即将弃用的方法，并在开发过程中提示开发者，使之快速找到新版本的方法。若以后我们要开发自己的移动操作系统的SDK，这种方式值得借鉴。 getNoBackupFilesDir，获取不备份的文件路径。Android能够通过BackupAgent对文件进行自动备份，而一些不需要备份的文件就可以放到无需备份文件的目录下，例如一些临时文件，我们可以通过getNoBackupFilesDir获取到存放无需备份文件的绝对路径，并将无需备份的文件存入其中。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:2:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"数据库Database ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Database模式常量 @IntDef(flag = true, prefix = { \"MODE_\" }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_ENABLE_WRITE_AHEAD_LOGGING, MODE_NO_LOCALIZED_COLLATORS, }) 与File、Preferences的模式常量有相同之处，都拥有MODE_PRIVATE、MODE_WORLD_READABLE、MODE_WORLD_WRITEABLE，涵义也相同。不同是MODE_MULTI_PROCESS与MODE_NO_LOCALIZED_COLLATORS。 涵义如下 // 数据库启用预写式日志 public static final int MODE_ENABLE_WRITE_AHEAD_LOGGING = 0x0008; // 数据库支持本地排序器 public static final int MODE_NO_LOCALIZED_COLLATORS = 0x0010; 预写式日志（WAL，Write-Ahead Logging）是在数据库写入数据之前，现将数据写入到日志中，这对于数据库通过日志记录恢复有着举足轻重的作用。 本地排序即排序过程中采取本地的排序规则，仍然建议各端数据库尽量使用相同的排序规则，否则数据库的开销很大。 这些都是数据库的知识，挖个坑，以后有机会再填。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Database模式接口 @Retention(RetentionPolicy.SOURCE) public @interface DatabaseMode {} ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"Database入口抽象方法 // 打开或创建数据库对象 public abstract SQLiteDatabase openOrCreateDatabase( String name, @DatabaseMode int mode, CursorFactory factory ); // 从给定的源Context中将已存在的数据库对象移到当前Context中 public abstract boolean moveDatabaseFrom( Context sourceContext, String name ); // 获取数据库文件 public abstract File getDatabasePath(String name); // 删除数据库对象 public abstract boolean deleteDatabase(String name); // 获取私有数据库对象列表 public abstract String[] databaseList(); openOrCreateDatabase openOrCreateDatabase的参数@DatabaseMode int mode使用了模式常量，根据传入的模式常量决定数据库的访问权限和访问特性。模式常量已在上文陈述。 moveDatabaseFrom 相信你已经联想到了首选项中的moveSharedPreferencesFrom(Context sourceContext, String name)，不错，moveDatabaseFrom(Context sourceContext, String name)在这里也是同样的涵义，它允许Database对象在Context对象之间，也意味着在Activity之间传递。 Context与四大组件 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:3:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Activity Activity是Context的子类，Context定义了对Activity的启动操作。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:4:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"面向开发者的启动 单启动 提到启动Activity，最熟悉的莫过于startActivity这位老熟人。 // 启动Activity public abstract void startActivity( @RequiresPermission Intent intent ); 多启动 大多数场景下，我们往往一次只启动一个Activity，但是有些时候我需要同时启动多个Activity，就需要用到startActivities。 // 启动多个Activity public abstract void startActivities( @RequiresPermission Intent[] intents ); // public abstract void startActivities( @RequiresPermission Intent[] intents, Bundle options ); 获取回调数据 我们还可以通过startActivityForResult来获取回调数据，注意，这个方法仅支持Fragment和View。 // 获取启动Activity的回调 public void startActivityForResult( @NonNull String who, Intent intent, int requestCode, @Nullable Bundle options ) { throw new RuntimeException(\"This method is only implemented for Activity-based Contexts. \"+ \"Check canStartActivityForResult() before calling.\"); } ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:4:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"面向系统的启动 Activity的启动不仅面向开发者，还面向系统。 startActivityAsUser startActivityAsUser指定特定的用户来启动Activity @SystemApi public void startActivityAsUser( @RequiresPermission @NonNull Intent intent, @NonNull UserHandle user ) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:4:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Service Context定义了Service的启动、绑定、解绑、停止的基本操作。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:5:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"启动 启动服务 // 启动服务 public abstract ComponentName startService(Intent service); // 指定用户启动服务 public abstract ComponentName startServiceAsUser( Intent service, UserHandle user ); 启动前台服务 // 启动前台服务 public abstract ComponentName startForegroundService(Intent service); // 指定用户启动前台服务 public abstract ComponentName startForegroundServiceAsUser( Intent service, UserHandle user ); 停止服务 // 停止服务 public abstract boolean stopServiceAsUser(Intent service, UserHandle user); // 指定用户停止服务 public abstract boolean stopServiceAsUser(Intent service, UserHandle user); ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:5:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"绑定 绑定服务常量 @IntDef(flag = true, prefix = { \"BIND_\" }, value = { BIND_AUTO_CREATE, BIND_DEBUG_UNBIND, BIND_NOT_FOREGROUND, BIND_ABOVE_CLIENT, BIND_ALLOW_OOM_MANAGEMENT, BIND_WAIVE_PRIORITY, BIND_IMPORTANT, BIND_ADJUST_WITH_ACTIVITY, BIND_NOT_PERCEPTIBLE, BIND_INCLUDE_CAPABILITIES }) @Retention(RetentionPolicy.SOURCE) public @interface BindServiceFlags {} 绑定服务入口方法 // 绑定服务 public abstract boolean bindService( @RequiresPermission Intent service, @NonNull ServiceConnection conn, @BindServiceFlags int flags ); public boolean bindService( @RequiresPermission @NonNull Intent service, @BindServiceFlags int flags, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn ) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } // 指定用户绑定服务 @SystemApi public boolean bindServiceAsUser( @RequiresPermission Intent service, ServiceConnection conn, int flags, UserHandle user) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } public boolean bindServiceAsUser( Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } // 多个服务实例绑定单个组件 public boolean bindIsolatedService( @RequiresPermission @NonNull Intent service, @BindServiceFlags int flags, @NonNull String instanceName, @NonNull @CallbackExecutor Executor executor, @NonNull ServiceConnection conn ) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } // 更新服务组（包含bindIsolatedService相关的多个服务实例） public void updateServiceGroup( @NonNull ServiceConnection conn, int group, int importance) { throw new RuntimeException(\"Not implemented. Must override in a subclass.\"); } 解绑 public abstract void unbindService(@NonNull ServiceConnection conn); 绑定用到的参数@BindServiceFlags int flags需要使用到绑定常量，这将决定服务与Context的绑定的方式。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:5:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Broadcast Receiver Conext定义了Broadcast Receiver的接收、注册、接收的基本操作。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"接收 允许接收广播需要执行IntentSensor。 允许接收 通过startIntentSender执行IntentSensor： public abstract void startIntentSender( IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues,int extraFlags ) throws IntentSender.SendIntentException; public abstract void startIntentSender( IntentSender intent, @Nullable Intent fillInIntent, @Intent.MutableFlags int flagsMask, @Intent.MutableFlags int flagsValues, int extraFlags, @Nullable Bundle options ) throws IntentSender.SendIntentException; ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:1","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"注册 注册广播 public abstract Intent registerReceiver( @Nullable BroadcastReceiver receiver, IntentFilter filter ); public abstract Intent registerReceiver( @Nullable BroadcastReceiver receiver, IntentFilter filter, @RegisterReceiverFlags int flags ); public abstract Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler ); public abstract Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler, @RegisterReceiverFlags int flags ); // 指定用户注册广播 public abstract Intent registerReceiverAsUser( BroadcastReceiver receiver, UserHandle user, IntentFilter filter, @Nullable String broadcastPermission, @Nullable Handler scheduler ); registerReceiver 注册广播。 registerReceiverAsUser 指定用户注册广播 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:2","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"注销广播 public abstract void unregisterReceiver(BroadcastReceiver receiver); unregisterReceiver 用于注销广播 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:3","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"发送 无序广播 // 无序广播 @SystemApi public abstract void sendBroadcast( Intent intent, @Nullable String receiverPermission, @Nullable Bundle options ); public abstract void sendBroadcast( Intent intent, String receiverPermission, int appOp ); // 指定用户无序广播 public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user ); public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission ); @SystemApi public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, @Nullable Bundle options ); public abstract void sendBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp ); sendBroadcast 无序广播 sendBroadcastAsUser 指定用户无序广播 有序广播 // 有序广播 public abstract void sendOrderedBroadcast( @RequiresPermission Intent intent, @Nullable String receiverPermission ); public abstract void sendOrderedBroadcast( @RequiresPermission @NonNull Intent intent, @Nullable String receiverPermission, @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); // 指定用户有序广播 public abstract void sendOrderedBroadcastAsUser( @RequiresPermission Intent intent, UserHandle user, @Nullable String receiverPermission, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); public abstract void sendOrderedBroadcastAsUser( Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); public abstract void sendOrderedBroadcastAsUser( Intent intent, UserHandle user, @Nullable String receiverPermission, int appOp, @Nullable Bundle options, BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras ); sendOrderedBroadcast 有序广播 sendOrderedBroadcastAsUser 指定用户有序广播 强制广播 // 强制权限数组中权限被准许，并向所有相关的广播接收器发送广播 public abstract void sendBroadcastMultiplePermissions( Intent intent, String[] receiverPermissions ); // 对于指定用户，强制权限数组中权限被准许，并向所有相关的广播接收器发送广播 public abstract void sendBroadcastAsUserMultiplePermissions( Intent intent, UserHandle user, String[] receiverPermissions ); sendBroadcastMultiplePermissions与sendBroadcastAsUserMultiplePermissions全被隐藏（注释中带有@hide），开发者无法调用。 @hide意味着该方法对开发者不可见，即开发者无法调用。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:6:4","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"与Notification Context与Notification无直接关联。 其他 Context还包括其他一些格外重要的内容，但本章仅作简述，不铺陈开。这些内容将在另一系列的章节中详细陈述，你现在仅需要知道他们的存在。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:7:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"权限管理 public abstract PackageManager getPackageManager(); ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:8:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"消息管理 public abstract Looper getMainLooper(); ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:9:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"资源管理 public abstract AssetManager getAssets(); public abstract Resources getResources(); 总结 Context是个大熔炉，一切都在这里汇聚，组件关联、存储管理、权限管理、消息管理、资源管理等等。 也许您会有以下疑问，Context为什么涉及这么多？PackageManager为什么跟权限有关？Looper为什么跟消息管理有关？资源管理为什么有两块？您当然可以自行检索答案，在未来不久的日子我也会更新相关的知识模块供您参考。 ","date":"2020-07-21","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/:10:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（二）——Context","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%BA%8Ccontext/"},{"categories":["Android"],"content":"在我们写Activity的时候，很多方法需要传入参数Context，官方文档告诉我们传入this。 为什么可以传入this？this不是Activity？为什么Context参数可以是Activity？你猜的没错，Activity就是Context的子类，其中还蕴涵着一套“套娃”。 后续几个篇章，Neville就带大家一起学习这组“套娃”，彻底透析源码。 套娃层次 先呈上一组继承关系 class AppCompatActivity : FragmentActivity {...} class FragmentActivity : ComponentActivity {...} class ComponentActivity : Activity {...} class Activity : ContextThemeWrapper {...} class ContextThemeWrapper : ContextWrapper {...} class ContextWrapper : Context {...} 发现套娃链路： AppCompatActivity =\u003eFragmentActivity =\u003eComponentActivity =\u003eActivity =\u003eContextThemeWrapper =\u003eContextWrapper =\u003eContext 我们的七位葫芦娃闪亮登场，让我们向他们打个招呼吧！ Context：上下文抽象类，实现了逻辑实现。 ContextWrapper：对Context进行打包，并实现Context中的抽象方法。 ContextThemeWrapper ：在ContextWrapper基础上，引入了对主题资源的打包。 Activity：最基础的活动组件类。 ComponentActivity： FragmentActivity： AppComatActivity：实现了对低版本API对兼容，是Android Studio中创建组件Activity时的默认类型。 在后续的篇章中，让我们与他们深入交流～ ","date":"2020-07-20","objectID":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%B8%80%E5%A5%97%E5%A8%83/:0:0","tags":["Android"],"title":"Android玄阶：七个葫芦娃（一）——套娃","uri":"/android%E7%8E%84%E9%98%B6%E4%B8%83%E4%B8%AA%E8%91%AB%E8%8A%A6%E5%A8%83%E4%B8%80%E5%A5%97%E5%A8%83/"},{"categories":["Kotlin"],"content":"内联扩展函数是啥玩意儿？答：Kotlin为你打包好的工具包。 如果说Java是一条龙服务，那Koltin就是在一条龙之外还提供了“内联函数”这种免费附赠服务。就好比你买膜，Java只给了你膜，而Kotlin还给了你贴膜工具包，让贴膜的过程无比丝滑。丝滑如下： lambda简化 写过Android的小伙伴肯定认识这样一位软妹OnClickListener， 用Java写是这样的 button.setOnClickListener(new OnClickListener { @Override public void OnClick(View v) { // to do } }) 用Kotlin写是这样的 button.setOnClickListener(object:OnClickListener{ override fun OnClick(v: View?) { // to do } }) 然后呈上我们的“Kotlin+lambda”魔幻大法，它就变成了这样 button.setOnClickListener { v-\u003e // to do } 如果你连OnClick的参数View在to do时都用不到，你甚至可以不写 button.setOnClickListener { // to do } 不仅如此，想用的时候，可以用it来代替参数View（因为只有一个参数，所以可以用it替代，因为it是单参数的隐式名称）。这就像曾经有一份爱情View在你面前，你没有去表达，当你回头想起，你还可以用it来替代View所留下的空白（所以View只是过客，it才是真爱）。 button.setOnClickListener { println(it.id) } 相信很多小伙伴已经懵了，这是什么操作？这叫“一夫一妻制”（我乱起的，别瞎记），如果一个接口只有一个抽象方法，你就可以享受这种服务，多个抽象方法不行。毕竟一夫一妻的时候，你喊一下老婆，谁都知道你在喊谁，但是在一夫多妻制下，呵，还真不知道你喊的是哪一位老婆… 如果这个抽象方法有多个参数怎么办？来，让我们继续魔幻，拿OnEditorActionListener举例 textView.setOnEditorActionListener( object: TextView.OnEditorActionListener { override fun onEditorAction(v: TextView?, actionId: Int, event: KeyEvent?): Boolean { // to do something } }) 他有三个参数v: TextView?, actionId: Int, event: KeyEvent?，取参数名拿逗号隔开即可 textView.setOnEditorActionListener { v, actionId, event -\u003e // to do something } let 写过ES6标准JS的童鞋是不是很熟悉。 作者：你懂我意思吗？ 童鞋：我懂你意思。 （眉目传情ing） 作者：不，你不懂。 let有Kotlin里没用来声明块级作用域内的变量的作用。var在JS里是花花公子，毫无规矩到处沾花惹草，但在Kotlin里已经变成了专注于自身块级作用域的好男人，好男人一个就够了，所以let就去干其他事儿了。什么事儿？简化单对象连续操作代码。 我们经常要初始化一些对象的属性，就会出现下面这种连写的情况 student.setId(id) student.setName(name) student.setAge(age) grade = student.grade 每次初始化设置属性，我们都要写个studnet.然后后接方法，太累了。于是let就闪亮登场了，有了let，你可以用它画个圈圈，然后用it指代你要操作的对象，在这个圈圈里完成对公有属性和公有方法对操作。 student.let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade } 这是什么魔力？没错，这就是爱的魔力，我们可以称之为“转圈圈”（这也是我乱起的，别瞎记）。 你还可以加个问号，用于判空，当student为空的时候，就不会执行let中的代码 student?.let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade } 至于返回值，let会以闭包的形式返回返回值。你可以中途用return表达式，中途没执行return的话会返回最后一行。 var result = let { it.setId(id) it.setName(name) it.setAge(age) grade = it.grade 1 // 前面没执行return，则最后一行为作为返回值，这里返回值为1 }) with 你以为let的操作已经最骚了？不，没有最骚，只有更骚。 with不仅可以连操，还可以省略it。 var result = with(student, { setId(id) }) 不过不能像let那样判空。 run 你以为with的操作已经最骚了？Again，没有最骚，只有更骚。 在let和with面前，run就是个儿子。我不是说他菜，恰恰相反，他遗传了父母的优良基因，融合了let的语法和with的神仙操作，可承受男女混合双打，可称之为“塞尔维亚妖王”（我真的是乱起的，你们别瞎记啊）。 run的语法和let一样，可以判空 student.run {} // 不判空 student?.run {} // 判空 圈圈里的写法跟with一样：不需要it。 var result = student?.run { // to do something 1 // 最后一行为返回值，返回值为1 } 综上所述，run比let和with更好用，如果你们的技术总监同意的话，你甚至可以肆意地使用run来替代let和with。相对于let他不需要it，相对于with他增加了判空，实乃集两者之精华。 apply 如果说run是let和with的爸爸的话，那么apply就是run的兄弟。这俩语法一样，唯一不同的是返回值。run比较花心，各种返回值都能返回；apply比较专情，只返回自身对象。没错，无论你怎么搞他，他都只返回自身对象。 所以run几乎啥场景都能用，而apply比较适合对象修改后又赋值给自身的场景。 also also的语法和let一样，但是also返回的是当前对象，而let返回的是闭包。是不是跟apply和run的关系很像。 总结 let，返回闭包，可判空，要用it with，返回闭包，不可判空，省略it run，返回闭包，集let与with之大成，可判空，省略it apply与run一样，但是apply返回当前对象；also与let一样，但是also返回当前对象。 本章结束，完结撒花花～ ","date":"2020-07-15","objectID":"/kotlin%E9%AB%98%E7%BA%A7lambda%E4%B8%8E%E6%89%A9%E5%B1%95%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:0:0","tags":["Kotlin"],"title":"Kotlin高级：lambda与扩展内联函数","uri":"/kotlin%E9%AB%98%E7%BA%A7lambda%E4%B8%8E%E6%89%A9%E5%B1%95%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Jetpack"],"content":"场景问题 我们在Android开发中会遇到这样一种场景： class MainActivity: AppCompatActivity() { private val component1: Component1 = Component1() private val component1: Component2 = Component2() override fun onCreate(...) { component1.create() component2.create() component3.create() } override fun onStart(...) { component1.start() component2.start() component3.start() } override fun onResume(...) { component1.resume() component2.resume() component3.resume() } override fun onPause(...) { component1.pause() component2.pause() component3.pause() } override fun onStop(...) { component1.stop() component2.stop() component3.stop() } override fun onDistory(...) { component1.distory() component2.distory() component3.distory() } } class Component1 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } class Component2 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } class Component3 { fun create() {} fun start() {} fun resume() {} fun stop() {} fun distory() {} } 组件的特定方法要在特定的生命周期进行调用，如果存在多个这样的组件，则生命周期方法中的代码就会非常冗杂。因此，Android对此进行控制反转，引入了生命周期感应型组件，通过绑定LifecyclerObserver和LifecyclerOwner来解决此类问题。 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:1:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecyclerOwner 带有生命周期的组件，例如Activity、Fragment，都持有lifecycleOwner。 不过lifecycleOwner是一个接口，他的表示类为lifecycle，你可以在组件的生命周期方法中获得lifecycle。 以Activity为例，他有 onCreate() onStart() onResume() onPause() onStop() onDistory() 六大生命周期。我们可以通过getLifecycle()在这些生命周期方法中获得lifecycle。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner onCreate() { mLifecycleOwner = lifecycle // 在kotlin中直接写lifecycle即表示getLifecycler() } } ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:2:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifeObserver 拿到LifecycleOwner后，我们获取他的LifeCycle为其添加观察者LifecycleObserver： mLifecycleOwner.getLifecycle().addObserver(mLifecycleObserver) 观察者中的会随着mLifecycleOwner生命周期的变化而执行不同的方法。观察者是怎样做到这一点的呢？ 实现LifecycleObserver接口 添加生命周期注解 MyObserver: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } 每当mLifecycleOwner进入某一生命周期时，都会触发mLifecycleObserver中带对应的@OnLifecycleEvent(Lifecycle.Event.xxx)注解的函数。例如，当mLifecycleOwner进入onCreate()时，mLifecycleObserver会执行带有@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)注解的方法。 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:3:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"代码总结 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"完整代码 我们把代码完整地写一遍： MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { // 获取MainActivity的lifecycleOwner mLifecycleOwner = lifecycle // 初始化lifecycleObserver mLifecycleObserver = MyObserver1() // 绑定两者 mLifecycleOwner.addObserver(mLifecycleObserver) // 再来一遍 mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver2() mLifecycleOwner.addObserver(mLifecycleObserver) // 再来一遍 mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver3() mLifecycleOwner.addObserver(mLifecycleObserver) } } MyObserver1: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } MyObserver2: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } MyObserver3: LifecyclerObserver() { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() {} @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() {} @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() {} @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() {} @OnLifecycleEvent(Lifecycle.Event.ON_DISTORY) fun distory() {} } 这样，我们将原来的每个生命周期填写对应的方法的多次操作转化为一次性的绑定操作。 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:1","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"进一步优化 对于多个响应生命周期的组件，虽然我们通过上述方法避免了在每一个周期都写一次方法，但我们在一个周期内仍然要写很多重复的绑定操作，因此我们可以进一步优化，将绑定操作封装为函数lifecycleBind。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { lifecycleBind(lifecycle, MyObserver1()) lifecycleBind(lifecycle, MyObserver2()) lifecycleBind(lifecycle, MyObserver3()) ... } } class Util { companion object { fun lifecycleBind( mLifecycleOwner: LifecycleOwner, mLifecycleObserver: LifecycleObserver ) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:2","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"再进一步优化 我们解决了重复操作，但是仍然有一个问题，那就是要执行多个封装好的绑定函数。如果有99个组件，我就要写99行这样的代码。 我们发现在一个生命周期组件的绑定中，LifecycleOwner是固定的，而LifecycleObserver是不固定的。因此，我们可以建立LifecycleObserver数组，进行遍历操作。 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner onCreate() { // 一次获取LifecycleOwner val mLifecycleOwner = lifecycle // 建立LifecycleObserver数组 val observers = listof( MyObserver1(), MyObserver2(), MyObserver3() ) // 遍历绑定 for(item in observers) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } class Util { companion object { fun lifecycleBind( mLifecycleOwner: LifecycleOwner, mLifecycleObserver: LifecycleObserver ) { mLifecycleOwner.addObserver(mLifecycleObserver) } } } ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:4:3","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"状态检查 有时候我们需要检查当前的生命周期状态，以进行特定的操作。例如，你可能会在Pause状态更新一个UI的状态，然后在Resume状态再一次更新他。生命周期感知型组件对此引入了状态检查。 传入lifecycle 检查lifecycle的状态 MainActivity: AppCompatActivity() { private lateinit var mLifecycleOwner: LifecycleOwner private lateinit var mLifecycleObserver: LifecycleObserver onCreate() { mLifecycleOwner = lifecycle mLifecycleObserver = MyObserver(mLifecycleOwner) mLifecycleOwner.addObserver(mLifecycleObserver) } onResume() { // 检查状态并执行操作 mLifecycleObserver.check() } } class MyObserver: LifecycleObserver( private val lifecycle: Lifecycle ) { fun check() { if(lifecycle.currentState.isAtLeast(Lifecycle.State.RESUMED) { // todo } } } ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:5:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"Event与State 生命周期中有两个枚举类，分别指向生命周期的事件和状态。 Event源码： public enum Event { ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY } State源码： public enum State { DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; public boolean isAtLeast(@NonNull State state) { return compareTo(state) \u003e= 0; } } 我们在之前的代码中都用过了，Event用作事件注解，State用作状态检查。大家可以结合图例整体把握一下。 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:6:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"源码分析 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"getLifecycle() 我们分别来看Activity和Fragment的getLifecycle() // ComponentActivity.java public Lifecycle getLifecycle() { return mLifecycleRegistry; } // Fragment.java public Lifecycle getLifecycle() { return mLifecycleRegistry; } 我们发现两者都返回了mLifecycleRegistry，这是什么呢？ // ComponentActivity.java private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); // Fragment.java LifecycleRegistry mLifecycleRegistry; private void initLifecycle() { mLifecycleRegistry = new LifecycleRegistry(this); mSavedStateRegistryController = SavedStateRegistryController.create(this); if (Build.VERSION.SDK_INT \u003e= 19) { mLifecycleRegistry.addObserver(new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (event == Lifecycle.Event.ON_STOP) { if (mView != null) { mView.cancelPendingInputEvents(); } } } }); } } Build.VERSION.SDK_INT \u003e= 19可见对于Fragemnt的Lifecycle的操作，只有SDK\u003e=19才会启用。 mLifecycleRegistry是LifecycleRegistry的实例。 public class LifecycleRegistry extends Lifecycle { ... } public abstract class Lifecycle { ... } 而Lifecycle是一个抽象类，LifecycleRegistry是Lifecycle的表现类。 由此可见，LifecycleRegistry表现了Lifecycle，而Fragment和Activity中获取到的Lifecycle都是LifecycleRegistry。但Lifecycle本身仅提供了Event和State的枚举类，对于Lifecycle主要的操作方法都在LifecycleRegistry中。当我们需要使用对Lifecycle的操作时，可以查看LifecycleRegistry寻找合适的方法。 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:1","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecycleOwner LifecycleOwner只是一个接口，仅提供了getLifecycle()： public interface LifecycleOwner { @NonNull Lifecycle getLifecycle(); } ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:2","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"LifecycleObserver LifecycleObserver更狠，一无所有： public interface LifecycleObserver { } ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:3","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"代码去哪儿啦？ 你可能会很疑惑，代码去哪儿了？还记得刚才的LifecycleRegistry，没错，其实所有的逻辑代码都在这里。 查看addObserver()方法 // LifecycleRegistry @Override public void addObserver(@NonNull LifecycleObserver observer) { State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); } 然后我们通过addObserver()找到ObserverWithState： // LifecycleRegistry static class ObserverWithState { State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) { mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; } } 我们看到了LifecycleEventObserver，打开源码： // LifecycleEventObserver public interface LifecycleEventObserver extends LifecycleObserver { void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event); } 破案了，观察者LifecycleObserver通过Lifecycling.lifecycleEventObserver()获得LifecycleEventObserver实例，与状态State通过ObserverWithState捆绑实现了生命周期感知的主要逻辑。 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:7:4","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":["Jetpack"],"content":"逻辑图谱 奉上最后的逻辑图谱供读者参考。 ","date":"0001-01-01","objectID":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/:8:0","tags":["Jetpack"],"title":"Jetpack：生命周期组件","uri":"/jetpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%84%E4%BB%B6/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"}]